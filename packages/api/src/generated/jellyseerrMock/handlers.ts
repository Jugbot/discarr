// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/**
 * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/zoubingwu/msw-auto-mock)
 * Feel free to commit/edit it as you need.
 */
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
import { HttpResponse, http } from 'msw'
import { faker } from '@faker-js/faker'

faker.seed(1)

const baseURL = 'http://localhost:3001/api/v1'
const MAX_ARRAY_LENGTH = 20

// Map to store counters for each API endpoint
const apiCounters = new Map<string, number>()

const next = (apiKey: string) => {
  let currentCount = apiCounters.get(apiKey) ?? 0
  if (currentCount === Number.MAX_SAFE_INTEGER - 1) {
    currentCount = 0
  }
  apiCounters.set(apiKey, currentCount + 1)
  return currentCount
}

export const handlers = [
  http.get(`${baseURL}/status`, async () => {
    const resultArray = [[getGetStatus200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /status`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/status/appdata`, async () => {
    const resultArray = [
      [getGetStatusAppdata200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /status/appdata`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/main`, async () => {
    const resultArray = [
      [getGetSettingsMain200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/main`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/main`, async () => {
    const resultArray = [
      [getPostSettingsMain200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/main`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/network`, async () => {
    const resultArray = [
      [getGetSettingsNetwork200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/network`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/network`, async () => {
    const resultArray = [
      [getPostSettingsNetwork200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/network`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/main/regenerate`, async () => {
    const resultArray = [
      [getPostSettingsMainRegenerate200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/main/regenerate`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/jellyfin`, async () => {
    const resultArray = [
      [getGetSettingsJellyfin200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/jellyfin`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/jellyfin`, async () => {
    const resultArray = [
      [getPostSettingsJellyfin200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/jellyfin`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/jellyfin/library`, async () => {
    const resultArray = [
      [getGetSettingsJellyfinLibrary200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/jellyfin/library`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/jellyfin/users`, async () => {
    const resultArray = [
      [getGetSettingsJellyfinUsers200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/jellyfin/users`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/jellyfin/sync`, async () => {
    const resultArray = [
      [getGetSettingsJellyfinSync200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/jellyfin/sync`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/jellyfin/sync`, async () => {
    const resultArray = [
      [getPostSettingsJellyfinSync200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/jellyfin/sync`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/plex`, async () => {
    const resultArray = [
      [getGetSettingsPlex200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/plex`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/plex`, async () => {
    const resultArray = [
      [getPostSettingsPlex200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/plex`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/plex/library`, async () => {
    const resultArray = [
      [getGetSettingsPlexLibrary200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/plex/library`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/plex/sync`, async () => {
    const resultArray = [
      [getGetSettingsPlexSync200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/plex/sync`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/plex/sync`, async () => {
    const resultArray = [
      [getPostSettingsPlexSync200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/plex/sync`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/plex/devices/servers`, async () => {
    const resultArray = [
      [getGetSettingsPlexDevicesServers200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/plex/devices/servers`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/plex/users`, async () => {
    const resultArray = [
      [getGetSettingsPlexUsers200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/plex/users`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/tautulli`, async () => {
    const resultArray = [
      [getGetSettingsTautulli200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/tautulli`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/tautulli`, async () => {
    const resultArray = [
      [getPostSettingsTautulli200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/tautulli`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/radarr`, async () => {
    const resultArray = [
      [getGetSettingsRadarr200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/radarr`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/radarr`, async () => {
    const resultArray = [
      [getPostSettingsRadarr201Response(), { status: 201 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/radarr`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/radarr/test`, async () => {
    const resultArray = [
      [getPostSettingsRadarrTest200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/radarr/test`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/settings/radarr/:radarrId`, async () => {
    const resultArray = [
      [getPutSettingsRadarrRadarrId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /settings/radarr/:radarrId`) % resultArray.length
      ],
    )
  }),
  http.delete(`${baseURL}/settings/radarr/:radarrId`, async () => {
    const resultArray = [
      [getDeleteSettingsRadarrRadarrId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /settings/radarr/:radarrId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/radarr/:radarrId/profiles`, async () => {
    const resultArray = [
      [getGetSettingsRadarrRadarrIdProfiles200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/radarr/:radarrId/profiles`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/sonarr`, async () => {
    const resultArray = [
      [getGetSettingsSonarr200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/sonarr`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/sonarr`, async () => {
    const resultArray = [
      [getPostSettingsSonarr201Response(), { status: 201 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/sonarr`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/sonarr/test`, async () => {
    const resultArray = [
      [getPostSettingsSonarrTest200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/sonarr/test`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/settings/sonarr/:sonarrId`, async () => {
    const resultArray = [
      [getPutSettingsSonarrSonarrId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /settings/sonarr/:sonarrId`) % resultArray.length
      ],
    )
  }),
  http.delete(`${baseURL}/settings/sonarr/:sonarrId`, async () => {
    const resultArray = [
      [getDeleteSettingsSonarrSonarrId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /settings/sonarr/:sonarrId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/public`, async () => {
    const resultArray = [
      [getGetSettingsPublic200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/public`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/initialize`, async () => {
    const resultArray = [
      [getPostSettingsInitialize200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/initialize`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/jobs`, async () => {
    const resultArray = [
      [getGetSettingsJobs200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/jobs`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/jobs/:jobId/run`, async () => {
    const resultArray = [
      [getPostSettingsJobsJobIdRun200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/jobs/:jobId/run`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/jobs/:jobId/cancel`, async () => {
    const resultArray = [
      [getPostSettingsJobsJobIdCancel200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/jobs/:jobId/cancel`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/jobs/:jobId/schedule`, async () => {
    const resultArray = [
      [getPostSettingsJobsJobIdSchedule200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/jobs/:jobId/schedule`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/cache`, async () => {
    const resultArray = [
      [getGetSettingsCache200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/cache`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/cache/:cacheId/flush`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/cache/:cacheId/flush`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/logs`, async () => {
    const resultArray = [
      [getGetSettingsLogs200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/logs`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/notifications/email`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsEmail200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/email`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/email`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsEmail200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/email`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/email/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/email/test`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/discord`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsDiscord200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/discord`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/discord`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsDiscord200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/discord`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/discord/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/discord/test`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/lunasea`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsLunasea200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/lunasea`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/lunasea`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsLunasea200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/lunasea`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/lunasea/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/lunasea/test`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/pushbullet`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsPushbullet200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/pushbullet`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/pushbullet`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsPushbullet200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/pushbullet`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/pushbullet/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/pushbullet/test`) %
          resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/pushover`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsPushover200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/pushover`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/pushover`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsPushover200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/pushover`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/pushover/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/pushover/test`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/pushover/sounds`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsPushoverSounds200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/pushover/sounds`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/gotify`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsGotify200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/gotify`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/gotify`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsGotify200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/gotify`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/gotify/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/gotify/test`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/slack`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsSlack200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/slack`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/slack`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsSlack200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/slack`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/slack/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/slack/test`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/telegram`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsTelegram200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/telegram`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/telegram`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsTelegram200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/telegram`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/telegram/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/telegram/test`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/webpush`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsWebpush200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/webpush`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/webpush`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsWebpush200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/webpush`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/webpush/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/webpush/test`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/notifications/webhook`, async () => {
    const resultArray = [
      [getGetSettingsNotificationsWebhook200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /settings/notifications/webhook`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/webhook`, async () => {
    const resultArray = [
      [getPostSettingsNotificationsWebhook200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/webhook`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/notifications/webhook/test`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /settings/notifications/webhook/test`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/settings/discover`, async () => {
    const resultArray = [
      [getGetSettingsDiscover200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/discover`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/settings/discover`, async () => {
    const resultArray = [
      [getPostSettingsDiscover200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/discover`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/settings/discover/:sliderId`, async () => {
    const resultArray = [
      [getPutSettingsDiscoverSliderId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /settings/discover/:sliderId`) % resultArray.length
      ],
    )
  }),
  http.delete(`${baseURL}/settings/discover/:sliderId`, async () => {
    const resultArray = [
      [getDeleteSettingsDiscoverSliderId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /settings/discover/:sliderId`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/settings/discover/add`, async () => {
    const resultArray = [
      [getPostSettingsDiscoverAdd200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /settings/discover/add`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/discover/reset`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/discover/reset`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/settings/about`, async () => {
    const resultArray = [
      [getGetSettingsAbout200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /settings/about`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/auth/me`, async () => {
    const resultArray = [[getGetAuthMe200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /auth/me`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/auth/plex`, async () => {
    const resultArray = [[getPostAuthPlex200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /auth/plex`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/auth/jellyfin`, async () => {
    const resultArray = [
      [getPostAuthJellyfin200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /auth/jellyfin`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/auth/local`, async () => {
    const resultArray = [[getPostAuthLocal200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /auth/local`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/auth/logout`, async () => {
    const resultArray = [[getPostAuthLogout200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /auth/logout`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/auth/reset-password`, async () => {
    const resultArray = [
      [getPostAuthResetPassword200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /auth/reset-password`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/auth/reset-password/:guid`, async () => {
    const resultArray = [
      [getPostAuthResetPasswordGuid200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /auth/reset-password/:guid`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/user`, async () => {
    const resultArray = [[getGetUser200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /user`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/user`, async () => {
    const resultArray = [[getPostUser201Response(), { status: 201 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /user`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/user`, async () => {
    const resultArray = [[getPutUser200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`put /user`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/user/import-from-plex`, async () => {
    const resultArray = [
      [getPostUserImportFromPlex201Response(), { status: 201 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /user/import-from-plex`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/user/import-from-jellyfin`, async () => {
    const resultArray = [
      [getPostUserImportFromJellyfin201Response(), { status: 201 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /user/import-from-jellyfin`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/user/registerPushSubscription`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /user/registerPushSubscription`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/user/:userId`, async () => {
    const resultArray = [[getGetUserUserId200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /user/:userId`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/user/:userId`, async () => {
    const resultArray = [[getPutUserUserId200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`put /user/:userId`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/user/:userId`, async () => {
    const resultArray = [
      [getDeleteUserUserId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`delete /user/:userId`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/user/:userId/requests`, async () => {
    const resultArray = [
      [getGetUserUserIdRequests200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /user/:userId/requests`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/user/:userId/quota`, async () => {
    const resultArray = [
      [getGetUserUserIdQuota200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /user/:userId/quota`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/blacklist`, async () => {
    const resultArray = [[getGetBlacklist200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /blacklist`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/blacklist`, async () => {
    const resultArray = [
      [undefined, { status: 201 }],
      [undefined, { status: 412 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /blacklist`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/blacklist/:tmdbId`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /blacklist/:tmdbId`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/blacklist/:tmdbId`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /blacklist/:tmdbId`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/watchlist`, async () => {
    const resultArray = [[getPostWatchlist200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /watchlist`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/watchlist/:tmdbId`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /watchlist/:tmdbId`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/user/:userId/watchlist`, async () => {
    const resultArray = [
      [getGetUserUserIdWatchlist200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /user/:userId/watchlist`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/user/:userId/settings/main`, async () => {
    const resultArray = [
      [getGetUserUserIdSettingsMain200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /user/:userId/settings/main`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/user/:userId/settings/main`, async () => {
    const resultArray = [
      [getPostUserUserIdSettingsMain200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /user/:userId/settings/main`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/user/:userId/settings/password`, async () => {
    const resultArray = [
      [getGetUserUserIdSettingsPassword200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /user/:userId/settings/password`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/user/:userId/settings/password`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /user/:userId/settings/password`) % resultArray.length
      ],
    )
  }),
  http.post(
    `${baseURL}/user/:userId/settings/linked-accounts/plex`,
    async () => {
      const resultArray = [
        [undefined, { status: 204 }],
        [undefined, { status: 403 }],
        [undefined, { status: 422 }],
      ] as [any, { status: number }][]

      return HttpResponse.json(
        ...resultArray[
          next(`post /user/:userId/settings/linked-accounts/plex`) %
            resultArray.length
        ],
      )
    },
  ),
  http.delete(
    `${baseURL}/user/:userId/settings/linked-accounts/plex`,
    async () => {
      const resultArray = [
        [undefined, { status: 204 }],
        [undefined, { status: 400 }],
        [undefined, { status: 404 }],
      ] as [any, { status: number }][]

      return HttpResponse.json(
        ...resultArray[
          next(`delete /user/:userId/settings/linked-accounts/plex`) %
            resultArray.length
        ],
      )
    },
  ),
  http.post(
    `${baseURL}/user/:userId/settings/linked-accounts/jellyfin`,
    async () => {
      const resultArray = [
        [undefined, { status: 204 }],
        [undefined, { status: 403 }],
        [undefined, { status: 422 }],
      ] as [any, { status: number }][]

      return HttpResponse.json(
        ...resultArray[
          next(`post /user/:userId/settings/linked-accounts/jellyfin`) %
            resultArray.length
        ],
      )
    },
  ),
  http.delete(
    `${baseURL}/user/:userId/settings/linked-accounts/jellyfin`,
    async () => {
      const resultArray = [
        [undefined, { status: 204 }],
        [undefined, { status: 400 }],
        [undefined, { status: 404 }],
      ] as [any, { status: number }][]

      return HttpResponse.json(
        ...resultArray[
          next(`delete /user/:userId/settings/linked-accounts/jellyfin`) %
            resultArray.length
        ],
      )
    },
  ),
  http.get(`${baseURL}/user/:userId/settings/notifications`, async () => {
    const resultArray = [
      [getGetUserUserIdSettingsNotifications200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /user/:userId/settings/notifications`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/user/:userId/settings/notifications`, async () => {
    const resultArray = [
      [getPostUserUserIdSettingsNotifications200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /user/:userId/settings/notifications`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/user/:userId/settings/permissions`, async () => {
    const resultArray = [
      [getGetUserUserIdSettingsPermissions200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /user/:userId/settings/permissions`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/user/:userId/settings/permissions`, async () => {
    const resultArray = [
      [getPostUserUserIdSettingsPermissions200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /user/:userId/settings/permissions`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/user/:userId/watch_data`, async () => {
    const resultArray = [
      [getGetUserUserIdWatchData200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /user/:userId/watch_data`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/search`, async () => {
    const resultArray = [[getGetSearch200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /search`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/search/keyword`, async () => {
    const resultArray = [
      [getGetSearchKeyword200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /search/keyword`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/search/company`, async () => {
    const resultArray = [
      [getGetSearchCompany200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /search/company`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/discover/movies`, async () => {
    const resultArray = [
      [getGetDiscoverMovies200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /discover/movies`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/discover/movies/genre/:genreId`, async () => {
    const resultArray = [
      [getGetDiscoverMoviesGenreGenreId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /discover/movies/genre/:genreId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/discover/movies/language/:language`, async () => {
    const resultArray = [
      [getGetDiscoverMoviesLanguageLanguage200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /discover/movies/language/:language`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/discover/movies/studio/:studioId`, async () => {
    const resultArray = [
      [getGetDiscoverMoviesStudioStudioId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /discover/movies/studio/:studioId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/discover/movies/upcoming`, async () => {
    const resultArray = [
      [getGetDiscoverMoviesUpcoming200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /discover/movies/upcoming`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/discover/tv`, async () => {
    const resultArray = [[getGetDiscoverTv200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /discover/tv`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/discover/tv/language/:language`, async () => {
    const resultArray = [
      [getGetDiscoverTvLanguageLanguage200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /discover/tv/language/:language`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/discover/tv/genre/:genreId`, async () => {
    const resultArray = [
      [getGetDiscoverTvGenreGenreId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /discover/tv/genre/:genreId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/discover/tv/network/:networkId`, async () => {
    const resultArray = [
      [getGetDiscoverTvNetworkNetworkId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /discover/tv/network/:networkId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/discover/tv/upcoming`, async () => {
    const resultArray = [
      [getGetDiscoverTvUpcoming200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /discover/tv/upcoming`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/discover/trending`, async () => {
    const resultArray = [
      [getGetDiscoverTrending200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /discover/trending`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/discover/keyword/:keywordId/movies`, async () => {
    const resultArray = [
      [getGetDiscoverKeywordKeywordIdMovies200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /discover/keyword/:keywordId/movies`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/discover/genreslider/movie`, async () => {
    const resultArray = [
      [getGetDiscoverGenresliderMovie200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /discover/genreslider/movie`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/discover/genreslider/tv`, async () => {
    const resultArray = [
      [getGetDiscoverGenresliderTv200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /discover/genreslider/tv`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/discover/watchlist`, async () => {
    const resultArray = [
      [getGetDiscoverWatchlist200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /discover/watchlist`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/request`, async () => {
    const resultArray = [[getGetRequest200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /request`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/request`, async () => {
    const resultArray = [[getPostRequest201Response(), { status: 201 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /request`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/request/count`, async () => {
    const resultArray = [
      [getGetRequestCount200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /request/count`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/request/:requestId`, async () => {
    const resultArray = [
      [getGetRequestRequestId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /request/:requestId`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/request/:requestId`, async () => {
    const resultArray = [
      [getPutRequestRequestId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /request/:requestId`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/request/:requestId`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /request/:requestId`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/request/:requestId/retry`, async () => {
    const resultArray = [
      [getPostRequestRequestIdRetry200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /request/:requestId/retry`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/request/:requestId/:status`, async () => {
    const resultArray = [
      [getPostRequestRequestIdStatus200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /request/:requestId/:status`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/movie/:movieId`, async () => {
    const resultArray = [
      [getGetMovieMovieId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /movie/:movieId`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/movie/:movieId/recommendations`, async () => {
    const resultArray = [
      [getGetMovieMovieIdRecommendations200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /movie/:movieId/recommendations`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/movie/:movieId/similar`, async () => {
    const resultArray = [
      [getGetMovieMovieIdSimilar200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /movie/:movieId/similar`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/movie/:movieId/ratings`, async () => {
    const resultArray = [
      [getGetMovieMovieIdRatings200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /movie/:movieId/ratings`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/movie/:movieId/ratingscombined`, async () => {
    const resultArray = [
      [getGetMovieMovieIdRatingscombined200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /movie/:movieId/ratingscombined`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/tv/:tvId`, async () => {
    const resultArray = [[getGetTvTvId200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /tv/:tvId`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/tv/:tvId/season/:seasonId`, async () => {
    const resultArray = [
      [getGetTvTvIdSeasonSeasonId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /tv/:tvId/season/:seasonId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/tv/:tvId/recommendations`, async () => {
    const resultArray = [
      [getGetTvTvIdRecommendations200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /tv/:tvId/recommendations`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/tv/:tvId/similar`, async () => {
    const resultArray = [
      [getGetTvTvIdSimilar200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /tv/:tvId/similar`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/tv/:tvId/ratings`, async () => {
    const resultArray = [
      [getGetTvTvIdRatings200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /tv/:tvId/ratings`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/person/:personId`, async () => {
    const resultArray = [
      [getGetPersonPersonId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /person/:personId`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/person/:personId/combined_credits`, async () => {
    const resultArray = [
      [getGetPersonPersonIdCombinedCredits200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /person/:personId/combined_credits`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/media`, async () => {
    const resultArray = [[getGetMedia200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /media`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/media/:mediaId`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /media/:mediaId`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/media/:mediaId/file`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /media/:mediaId/file`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/media/:mediaId/:status`, async () => {
    const resultArray = [
      [getPostMediaMediaIdStatus200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /media/:mediaId/:status`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/media/:mediaId/watch_data`, async () => {
    const resultArray = [
      [getGetMediaMediaIdWatchData200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /media/:mediaId/watch_data`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/collection/:collectionId`, async () => {
    const resultArray = [
      [getGetCollectionCollectionId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /collection/:collectionId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/service/radarr`, async () => {
    const resultArray = [
      [getGetServiceRadarr200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /service/radarr`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/service/radarr/:radarrId`, async () => {
    const resultArray = [
      [getGetServiceRadarrRadarrId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /service/radarr/:radarrId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/service/sonarr`, async () => {
    const resultArray = [
      [getGetServiceSonarr200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /service/sonarr`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/service/sonarr/:sonarrId`, async () => {
    const resultArray = [
      [getGetServiceSonarrSonarrId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /service/sonarr/:sonarrId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/service/sonarr/lookup/:tmdbId`, async () => {
    const resultArray = [
      [getGetServiceSonarrLookupTmdbId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /service/sonarr/lookup/:tmdbId`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/regions`, async () => {
    const resultArray = [[getGetRegions200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /regions`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/languages`, async () => {
    const resultArray = [[getGetLanguages200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /languages`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/studio/:studioId`, async () => {
    const resultArray = [
      [getGetStudioStudioId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /studio/:studioId`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/network/:networkId`, async () => {
    const resultArray = [
      [getGetNetworkNetworkId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /network/:networkId`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/genres/movie`, async () => {
    const resultArray = [[getGetGenresMovie200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /genres/movie`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/genres/tv`, async () => {
    const resultArray = [[getGetGenresTv200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /genres/tv`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/backdrops`, async () => {
    const resultArray = [[getGetBackdrops200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /backdrops`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/issue`, async () => {
    const resultArray = [[getGetIssue200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /issue`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/issue`, async () => {
    const resultArray = [[getPostIssue201Response(), { status: 201 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /issue`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/issue/count`, async () => {
    const resultArray = [[getGetIssueCount200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /issue/count`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/issue/:issueId`, async () => {
    const resultArray = [
      [getGetIssueIssueId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /issue/:issueId`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/issue/:issueId`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /issue/:issueId`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/issue/:issueId/comment`, async () => {
    const resultArray = [
      [getPostIssueIssueIdComment200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /issue/:issueId/comment`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/issueComment/:commentId`, async () => {
    const resultArray = [
      [getGetIssueCommentCommentId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /issueComment/:commentId`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/issueComment/:commentId`, async () => {
    const resultArray = [
      [getPutIssueCommentCommentId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /issueComment/:commentId`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/issueComment/:commentId`, async () => {
    const resultArray = [[undefined, { status: 204 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /issueComment/:commentId`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/issue/:issueId/:status`, async () => {
    const resultArray = [
      [getPostIssueIssueIdStatus200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /issue/:issueId/:status`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/keyword/:keywordId`, async () => {
    const resultArray = [
      [getGetKeywordKeywordId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /keyword/:keywordId`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/watchproviders/regions`, async () => {
    const resultArray = [
      [getGetWatchprovidersRegions200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /watchproviders/regions`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/watchproviders/movies`, async () => {
    const resultArray = [
      [getGetWatchprovidersMovies200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /watchproviders/movies`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/watchproviders/tv`, async () => {
    const resultArray = [
      [getGetWatchprovidersTv200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /watchproviders/tv`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/overrideRule`, async () => {
    const resultArray = [
      [getGetOverrideRule200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /overrideRule`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/overrideRule`, async () => {
    const resultArray = [
      [getPostOverrideRule200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /overrideRule`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/overrideRule/:ruleId`, async () => {
    const resultArray = [
      [getPutOverrideRuleRuleId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /overrideRule/:ruleId`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/overrideRule/:ruleId`, async () => {
    const resultArray = [
      [getDeleteOverrideRuleRuleId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`delete /overrideRule/:ruleId`) % resultArray.length],
    )
  }),
]

export function getGetStatus200Response() {
  return {
    version: '1.0.0',
    commitTag: faker.lorem.words(),
    updateAvailable: faker.datatype.boolean(),
    commitsBehind: faker.number.int(),
    restartRequired: faker.datatype.boolean(),
  }
}

export function getGetStatusAppdata200Response() {
  return {
    appData: true,
    appDataPath: '/app/config',
    appDataPermissions: true,
  }
}

export function getGetSettingsMain200Response() {
  return {
    apiKey: faker.lorem.words(),
    appLanguage: 'en',
    applicationTitle: 'Jellyseerr',
    applicationUrl: 'https://os.example.com',
    hideAvailable: faker.datatype.boolean(),
    partialRequestsEnabled: faker.datatype.boolean(),
    localLogin: true,
    mediaServerType: 1,
    newPlexLogin: true,
    defaultPermissions: 32,
    enableSpecialEpisodes: faker.datatype.boolean(),
  }
}

export function getPostSettingsMain200Response() {
  return {
    apiKey: faker.lorem.words(),
    appLanguage: 'en',
    applicationTitle: 'Jellyseerr',
    applicationUrl: 'https://os.example.com',
    hideAvailable: faker.datatype.boolean(),
    partialRequestsEnabled: faker.datatype.boolean(),
    localLogin: true,
    mediaServerType: 1,
    newPlexLogin: true,
    defaultPermissions: 32,
    enableSpecialEpisodes: faker.datatype.boolean(),
  }
}

export function getGetSettingsNetwork200Response() {
  return {
    apiKey: faker.lorem.words(),
    appLanguage: 'en',
    applicationTitle: 'Jellyseerr',
    applicationUrl: 'https://os.example.com',
    hideAvailable: faker.datatype.boolean(),
    partialRequestsEnabled: faker.datatype.boolean(),
    localLogin: true,
    mediaServerType: 1,
    newPlexLogin: true,
    defaultPermissions: 32,
    enableSpecialEpisodes: faker.datatype.boolean(),
  }
}

export function getPostSettingsNetwork200Response() {
  return {
    csrfProtection: faker.datatype.boolean(),
    forceIpv4First: faker.datatype.boolean(),
    trustProxy: true,
  }
}

export function getPostSettingsMainRegenerate200Response() {
  return {
    apiKey: faker.lorem.words(),
    appLanguage: 'en',
    applicationTitle: 'Jellyseerr',
    applicationUrl: 'https://os.example.com',
    hideAvailable: faker.datatype.boolean(),
    partialRequestsEnabled: faker.datatype.boolean(),
    localLogin: true,
    mediaServerType: 1,
    newPlexLogin: true,
    defaultPermissions: 32,
    enableSpecialEpisodes: faker.datatype.boolean(),
  }
}

export function getGetSettingsJellyfin200Response() {
  return {
    name: 'Main Server',
    hostname: 'http://my.jellyfin.host',
    externalHostname: 'http://my.jellyfin.host',
    jellyfinForgotPasswordUrl:
      'http://my.jellyfin.host/web/index.html#!/forgotpassword.html',
    adminUser: 'admin',
    adminPass: 'mypassword',
    libraries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    })),
    serverID: faker.string.uuid(),
  }
}

export function getPostSettingsJellyfin200Response() {
  return {
    name: 'Main Server',
    hostname: 'http://my.jellyfin.host',
    externalHostname: 'http://my.jellyfin.host',
    jellyfinForgotPasswordUrl:
      'http://my.jellyfin.host/web/index.html#!/forgotpassword.html',
    adminUser: 'admin',
    adminPass: 'mypassword',
    libraries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    })),
    serverID: faker.string.uuid(),
  }
}

export function getGetSettingsJellyfinLibrary200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.string.uuid(),
    name: 'Movies',
    enabled: faker.datatype.boolean(),
  }))
}

export function getGetSettingsJellyfinUsers200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    username: faker.person.fullName(),
    userId: faker.number.int(),
  }))
}

export function getGetSettingsJellyfinSync200Response() {
  return {
    running: faker.datatype.boolean(),
    progress: faker.number.int(),
    total: 100,
    currentLibrary: {
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    },
    libraries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    })),
  }
}

export function getPostSettingsJellyfinSync200Response() {
  return {
    running: faker.datatype.boolean(),
    progress: faker.number.int(),
    total: 100,
    currentLibrary: {
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    },
    libraries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    })),
  }
}

export function getGetSettingsPlex200Response() {
  return {
    name: 'Main Server',
    machineId: '1234123412341234',
    ip: '127.0.0.1',
    port: 32400,
    useSsl: faker.datatype.boolean(),
    libraries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    })),
    webAppUrl: 'https://app.plex.tv/desktop',
  }
}

export function getPostSettingsPlex200Response() {
  return {
    name: 'Main Server',
    machineId: '1234123412341234',
    ip: '127.0.0.1',
    port: 32400,
    useSsl: faker.datatype.boolean(),
    libraries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    })),
    webAppUrl: 'https://app.plex.tv/desktop',
  }
}

export function getGetSettingsPlexLibrary200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.string.uuid(),
    name: 'Movies',
    enabled: faker.datatype.boolean(),
  }))
}

export function getGetSettingsPlexSync200Response() {
  return {
    running: faker.datatype.boolean(),
    progress: faker.number.int(),
    total: 100,
    currentLibrary: {
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    },
    libraries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    })),
  }
}

export function getPostSettingsPlexSync200Response() {
  return {
    running: faker.datatype.boolean(),
    progress: faker.number.int(),
    total: 100,
    currentLibrary: {
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    },
    libraries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.string.uuid(),
      name: 'Movies',
      enabled: faker.datatype.boolean(),
    })),
  }
}

export function getGetSettingsPlexDevicesServers200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    name: 'My Plex Server',
    product: 'Plex Media Server',
    productVersion: '1.21',
    platform: 'Linux',
    platformVersion: 'default/linux/amd64/17.1/systemd',
    device: 'PC',
    clientIdentifier: '85a943ce-a0cc-4d2a-a4ec-f74f06e40feb',
    createdAt: '2021-01-01T00:00:00.000Z',
    lastSeenAt: '2021-01-01T00:00:00.000Z',
    provides: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => 'server'),
    owned: true,
    ownerID: '12345',
    home: true,
    sourceTitle: 'xyzabc',
    accessToken: 'supersecretaccesstoken',
    publicAddress: '127.0.0.1',
    httpsRequired: true,
    synced: true,
    relay: true,
    dnsRebindingProtection: faker.datatype.boolean(),
    natLoopbackSupported: faker.datatype.boolean(),
    publicAddressMatches: faker.datatype.boolean(),
    presence: true,
    connection: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      protocol: 'https',
      address: '127.0.0.1',
      port: 32400,
      uri: 'https://127-0-0-1.2ab6ce1a093d465e910def96cf4e4799.plex.direct:32400',
      local: true,
      status: 200,
      message: 'OK',
    })),
  }))
}

export function getGetSettingsPlexUsers200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.string.uuid(),
    title: faker.lorem.words(),
    username: faker.person.fullName(),
    email: faker.internet.email(),
    thumb: faker.lorem.words(),
  }))
}

export function getGetSettingsTautulli200Response() {
  return {
    hostname: 'tautulli.example.com',
    port: 8181,
    useSsl: faker.datatype.boolean(),
    apiKey: faker.lorem.words(),
    externalUrl: faker.internet.url(),
  }
}

export function getPostSettingsTautulli200Response() {
  return {
    hostname: 'tautulli.example.com',
    port: 8181,
    useSsl: faker.datatype.boolean(),
    apiKey: faker.lorem.words(),
    externalUrl: faker.internet.url(),
  }
}

export function getGetSettingsRadarr200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: 'Radarr Main',
    hostname: '127.0.0.1',
    port: 7878,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/movies',
    is4k: faker.datatype.boolean(),
    minimumAvailability: 'In Cinema',
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }))
}

export function getPostSettingsRadarr201Response() {
  return {
    id: faker.number.int(),
    name: 'Radarr Main',
    hostname: '127.0.0.1',
    port: 7878,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/movies',
    is4k: faker.datatype.boolean(),
    minimumAvailability: 'In Cinema',
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }
}

export function getPostSettingsRadarrTest200Response() {
  return {
    profiles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      name: '720p/1080p',
    })),
  }
}

export function getPutSettingsRadarrRadarrId200Response() {
  return {
    id: faker.number.int(),
    name: 'Radarr Main',
    hostname: '127.0.0.1',
    port: 7878,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/movies',
    is4k: faker.datatype.boolean(),
    minimumAvailability: 'In Cinema',
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }
}

export function getDeleteSettingsRadarrRadarrId200Response() {
  return {
    id: faker.number.int(),
    name: 'Radarr Main',
    hostname: '127.0.0.1',
    port: 7878,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/movies',
    is4k: faker.datatype.boolean(),
    minimumAvailability: 'In Cinema',
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }
}

export function getGetSettingsRadarrRadarrIdProfiles200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 1,
    name: '720p/1080p',
  }))
}

export function getGetSettingsSonarr200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: 'Sonarr Main',
    hostname: '127.0.0.1',
    port: 8989,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/tv/',
    activeLanguageProfileId: 1,
    activeAnimeProfileId: faker.number.int(),
    activeAnimeLanguageProfileId: faker.number.int(),
    activeAnimeProfileName: '720p/1080p',
    activeAnimeDirectory: faker.lorem.words(),
    is4k: faker.datatype.boolean(),
    enableSeasonFolders: faker.datatype.boolean(),
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }))
}

export function getPostSettingsSonarr201Response() {
  return {
    id: faker.number.int(),
    name: 'Sonarr Main',
    hostname: '127.0.0.1',
    port: 8989,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/tv/',
    activeLanguageProfileId: 1,
    activeAnimeProfileId: faker.number.int(),
    activeAnimeLanguageProfileId: faker.number.int(),
    activeAnimeProfileName: '720p/1080p',
    activeAnimeDirectory: faker.lorem.words(),
    is4k: faker.datatype.boolean(),
    enableSeasonFolders: faker.datatype.boolean(),
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }
}

export function getPostSettingsSonarrTest200Response() {
  return {
    profiles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      name: '720p/1080p',
    })),
  }
}

export function getPutSettingsSonarrSonarrId200Response() {
  return {
    id: faker.number.int(),
    name: 'Sonarr Main',
    hostname: '127.0.0.1',
    port: 8989,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/tv/',
    activeLanguageProfileId: 1,
    activeAnimeProfileId: faker.number.int(),
    activeAnimeLanguageProfileId: faker.number.int(),
    activeAnimeProfileName: '720p/1080p',
    activeAnimeDirectory: faker.lorem.words(),
    is4k: faker.datatype.boolean(),
    enableSeasonFolders: faker.datatype.boolean(),
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }
}

export function getDeleteSettingsSonarrSonarrId200Response() {
  return {
    id: faker.number.int(),
    name: 'Sonarr Main',
    hostname: '127.0.0.1',
    port: 8989,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/tv/',
    activeLanguageProfileId: 1,
    activeAnimeProfileId: faker.number.int(),
    activeAnimeLanguageProfileId: faker.number.int(),
    activeAnimeProfileName: '720p/1080p',
    activeAnimeDirectory: faker.lorem.words(),
    is4k: faker.datatype.boolean(),
    enableSeasonFolders: faker.datatype.boolean(),
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }
}

export function getGetSettingsPublic200Response() {
  return {
    initialized: faker.datatype.boolean(),
  }
}

export function getPostSettingsInitialize200Response() {
  return {
    initialized: faker.datatype.boolean(),
  }
}

export function getGetSettingsJobs200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 'job-name',
    type: faker.helpers.arrayElement(['process', 'command']),
    interval: faker.helpers.arrayElement(['short', 'long', 'fixed']),
    name: 'A Job Name',
    nextExecutionTime: '2020-09-02T05:02:23.000Z',
    running: faker.datatype.boolean(),
  }))
}

export function getPostSettingsJobsJobIdRun200Response() {
  return {
    id: 'job-name',
    type: faker.helpers.arrayElement(['process', 'command']),
    interval: faker.helpers.arrayElement(['short', 'long', 'fixed']),
    name: 'A Job Name',
    nextExecutionTime: '2020-09-02T05:02:23.000Z',
    running: faker.datatype.boolean(),
  }
}

export function getPostSettingsJobsJobIdCancel200Response() {
  return {
    id: 'job-name',
    type: faker.helpers.arrayElement(['process', 'command']),
    interval: faker.helpers.arrayElement(['short', 'long', 'fixed']),
    name: 'A Job Name',
    nextExecutionTime: '2020-09-02T05:02:23.000Z',
    running: faker.datatype.boolean(),
  }
}

export function getPostSettingsJobsJobIdSchedule200Response() {
  return {
    id: 'job-name',
    type: faker.helpers.arrayElement(['process', 'command']),
    interval: faker.helpers.arrayElement(['short', 'long', 'fixed']),
    name: 'A Job Name',
    nextExecutionTime: '2020-09-02T05:02:23.000Z',
    running: faker.datatype.boolean(),
  }
}

export function getGetSettingsCache200Response() {
  return {
    imageCache: {
      tmdb: {
        size: 123456,
        imageCount: 123,
      },
      avatar: {
        size: 123456,
        imageCount: 123,
      },
    },
    apiCaches: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 'cache-id',
      name: 'cache name',
      stats: {
        hits: faker.number.int(),
        misses: faker.number.int(),
        keys: faker.number.int(),
        ksize: faker.number.int(),
        vsize: faker.number.int(),
      },
    })),
  }
}

export function getGetSettingsLogs200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    label: 'server',
    level: 'info',
    message: 'Server ready on port 5055',
    timestamp: '2020-12-15T16:20:00.069Z',
  }))
}

export function getGetSettingsNotificationsEmail200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      emailFrom: 'no-reply@example.com',
      senderName: 'Jellyseerr',
      smtpHost: '127.0.0.1',
      smtpPort: 465,
      secure: faker.datatype.boolean(),
      ignoreTls: faker.datatype.boolean(),
      requireTls: faker.datatype.boolean(),
      authUser: faker.lorem.words(),
      authPass: faker.lorem.words(),
      allowSelfSigned: faker.datatype.boolean(),
    },
  }
}

export function getPostSettingsNotificationsEmail200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      emailFrom: 'no-reply@example.com',
      senderName: 'Jellyseerr',
      smtpHost: '127.0.0.1',
      smtpPort: 465,
      secure: faker.datatype.boolean(),
      ignoreTls: faker.datatype.boolean(),
      requireTls: faker.datatype.boolean(),
      authUser: faker.lorem.words(),
      authPass: faker.lorem.words(),
      allowSelfSigned: faker.datatype.boolean(),
    },
  }
}

export function getGetSettingsNotificationsDiscord200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      botUsername: faker.person.fullName(),
      botAvatarUrl: faker.internet.url(),
      webhookUrl: faker.internet.url(),
      webhookRoleId: faker.string.uuid(),
      enableMentions: faker.datatype.boolean(),
    },
  }
}

export function getPostSettingsNotificationsDiscord200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      botUsername: faker.person.fullName(),
      botAvatarUrl: faker.internet.url(),
      webhookUrl: faker.internet.url(),
      webhookRoleId: faker.string.uuid(),
      enableMentions: faker.datatype.boolean(),
    },
  }
}

export function getGetSettingsNotificationsLunasea200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      webhookUrl: faker.internet.url(),
      profileName: faker.person.fullName(),
    },
  }
}

export function getPostSettingsNotificationsLunasea200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      webhookUrl: faker.internet.url(),
      profileName: faker.person.fullName(),
    },
  }
}

export function getGetSettingsNotificationsPushbullet200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      accessToken: faker.lorem.words(),
      channelTag: faker.lorem.words(),
    },
  }
}

export function getPostSettingsNotificationsPushbullet200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      accessToken: faker.lorem.words(),
      channelTag: faker.lorem.words(),
    },
  }
}

export function getGetSettingsNotificationsPushover200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      accessToken: faker.lorem.words(),
      userToken: faker.lorem.words(),
      sound: faker.lorem.words(),
    },
  }
}

export function getPostSettingsNotificationsPushover200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      accessToken: faker.lorem.words(),
      userToken: faker.lorem.words(),
      sound: faker.lorem.words(),
    },
  }
}

export function getGetSettingsNotificationsPushoverSounds200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    name: faker.person.fullName(),
    description: faker.lorem.words(),
  }))
}

export function getGetSettingsNotificationsGotify200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      url: faker.internet.url(),
      token: faker.lorem.words(),
    },
  }
}

export function getPostSettingsNotificationsGotify200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      url: faker.internet.url(),
      token: faker.lorem.words(),
    },
  }
}

export function getGetSettingsNotificationsSlack200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      webhookUrl: faker.internet.url(),
    },
  }
}

export function getPostSettingsNotificationsSlack200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      webhookUrl: faker.internet.url(),
    },
  }
}

export function getGetSettingsNotificationsTelegram200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      botUsername: faker.person.fullName(),
      botAPI: faker.lorem.words(),
      chatId: faker.string.uuid(),
      messageThreadId: faker.string.uuid(),
      sendSilently: faker.datatype.boolean(),
    },
  }
}

export function getPostSettingsNotificationsTelegram200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      botUsername: faker.person.fullName(),
      botAPI: faker.lorem.words(),
      chatId: faker.string.uuid(),
      messageThreadId: faker.string.uuid(),
      sendSilently: faker.datatype.boolean(),
    },
  }
}

export function getGetSettingsNotificationsWebpush200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
  }
}

export function getPostSettingsNotificationsWebpush200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
  }
}

export function getGetSettingsNotificationsWebhook200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      webhookUrl: faker.internet.url(),
      authHeader: faker.lorem.words(),
      jsonPayload: faker.lorem.words(),
    },
  }
}

export function getPostSettingsNotificationsWebhook200Response() {
  return {
    enabled: faker.datatype.boolean(),
    types: 2,
    options: {
      webhookUrl: faker.internet.url(),
      authHeader: faker.lorem.words(),
      jsonPayload: faker.lorem.words(),
    },
  }
}

export function getGetSettingsDiscover200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 1,
    type: 1,
    title: faker.lorem.words(),
    isBuiltIn: faker.datatype.boolean(),
    enabled: faker.datatype.boolean(),
    data: '1234',
  }))
}

export function getPostSettingsDiscover200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 1,
    type: 1,
    title: faker.lorem.words(),
    isBuiltIn: faker.datatype.boolean(),
    enabled: faker.datatype.boolean(),
    data: '1234',
  }))
}

export function getPutSettingsDiscoverSliderId200Response() {
  return {
    id: 1,
    type: 1,
    title: faker.lorem.words(),
    isBuiltIn: faker.datatype.boolean(),
    enabled: faker.datatype.boolean(),
    data: '1234',
  }
}

export function getDeleteSettingsDiscoverSliderId200Response() {
  return {
    id: 1,
    type: 1,
    title: faker.lorem.words(),
    isBuiltIn: faker.datatype.boolean(),
    enabled: faker.datatype.boolean(),
    data: '1234',
  }
}

export function getPostSettingsDiscoverAdd200Response() {
  return {
    id: 1,
    type: 1,
    title: faker.lorem.words(),
    isBuiltIn: faker.datatype.boolean(),
    enabled: faker.datatype.boolean(),
    data: '1234',
  }
}

export function getGetSettingsAbout200Response() {
  return {
    version: '1.0.0',
    totalRequests: 100,
    totalMediaItems: 100,
    tz: 'Asia/Tokyo',
    appDataPath: '/app/config',
  }
}

export function getGetAuthMe200Response() {
  return {
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }
}

export function getPostAuthPlex200Response() {
  return {
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }
}

export function getPostAuthJellyfin200Response() {
  return {
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }
}

export function getPostAuthLocal200Response() {
  return {
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }
}

export function getPostAuthLogout200Response() {
  return {
    status: 'ok',
  }
}

export function getPostAuthResetPassword200Response() {
  return {
    status: 'ok',
  }
}

export function getPostAuthResetPasswordGuid200Response() {
  return {
    status: 'ok',
  }
}

export function getGetUser200Response() {
  return {
    pageInfo: {
      page: 1,
      pages: 10,
      results: 100,
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    })),
  }
}

export function getPostUser201Response() {
  return {
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }
}

export function getPutUser200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }))
}

export function getPostUserImportFromPlex201Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }))
}

export function getPostUserImportFromJellyfin201Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }))
}

export function getGetUserUserId200Response() {
  return {
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }
}

export function getPutUserUserId200Response() {
  return {
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }
}

export function getDeleteUserUserId200Response() {
  return {
    id: 1,
    email: 'hey@itsme.com',
    username: faker.person.fullName(),
    plexUsername: faker.person.fullName(),
    plexToken: faker.lorem.words(),
    jellyfinAuthToken: faker.lorem.words(),
    userType: 1,
    permissions: faker.number.int(),
    avatar: faker.lorem.words(),
    createdAt: '2020-09-02T05:02:23.000Z',
    updatedAt: '2020-09-02T05:02:23.000Z',
    requestCount: 5,
    displayName: faker.person.fullName(),
  }
}

export function getGetUserUserIdRequests200Response() {
  return {
    pageInfo: {
      page: 1,
      pages: 10,
      results: 100,
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 123,
      status: faker.number.int(),
      media: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      requestedBy: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      modifiedBy: faker.helpers.arrayElement([
        {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        faker.lorem.words(),
      ]),
      is4k: faker.datatype.boolean(),
      serverId: faker.number.int(),
      profileId: faker.number.int(),
      rootFolder: faker.lorem.words(),
    })),
  }
}

export function getGetUserUserIdQuota200Response() {
  return {
    movie: {
      days: 7,
      limit: 10,
      used: 6,
      remaining: 4,
      restricted: faker.datatype.boolean(),
    },
    tv: {
      days: 7,
      limit: 10,
      used: 6,
      remaining: 4,
      restricted: faker.datatype.boolean(),
    },
  }
}

export function getGetBlacklist200Response() {
  return {
    pageInfo: {
      page: 1,
      pages: 10,
      results: 100,
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      user: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      createdAt: '2024-04-21T01:55:44.000Z',
      id: 1,
      mediaType: 'movie',
      title: 'Dune',
      tmdbId: 438631,
    })),
  }
}

export function getPostWatchlist200Response() {
  return {
    id: 1,
    tmdbId: 1,
    ratingKey: faker.lorem.words(),
    type: faker.lorem.words(),
    title: faker.lorem.words(),
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        status: faker.number.int(),
        media: null,
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        requestedBy: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        modifiedBy: faker.helpers.arrayElement([
          {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          faker.lorem.words(),
        ]),
        is4k: faker.datatype.boolean(),
        serverId: faker.number.int(),
        profileId: faker.number.int(),
        rootFolder: faker.lorem.words(),
      })),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdAt: '2020-09-12T10:00:27.000Z',
    updatedAt: '2020-09-12T10:00:27.000Z',
    requestedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
  }
}

export function getGetUserUserIdWatchlist200Response() {
  return {
    page: faker.number.int(),
    totalPages: faker.number.int(),
    totalResults: faker.number.int(),
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      tmdbId: 1,
      ratingKey: faker.lorem.words(),
      type: faker.lorem.words(),
      title: faker.lorem.words(),
    })),
  }
}

export function getGetUserUserIdSettingsMain200Response() {
  return {
    username: 'Mr User',
  }
}

export function getPostUserUserIdSettingsMain200Response() {
  return {
    username: 'Mr User',
  }
}

export function getGetUserUserIdSettingsPassword200Response() {
  return {
    hasPassword: true,
  }
}

export function getGetUserUserIdSettingsNotifications200Response() {
  return {
    notificationTypes: {
      discord: faker.number.int(),
      email: faker.number.int(),
      pushbullet: faker.number.int(),
      pushover: faker.number.int(),
      slack: faker.number.int(),
      telegram: faker.number.int(),
      webhook: faker.number.int(),
      webpush: faker.number.int(),
    },
    emailEnabled: faker.datatype.boolean(),
    pgpKey: faker.lorem.words(),
    discordEnabled: faker.datatype.boolean(),
    discordEnabledTypes: faker.number.int(),
    discordId: faker.string.uuid(),
    pushbulletAccessToken: faker.lorem.words(),
    pushoverApplicationToken: faker.lorem.words(),
    pushoverUserKey: faker.lorem.words(),
    pushoverSound: faker.lorem.words(),
    telegramEnabled: faker.datatype.boolean(),
    telegramBotUsername: faker.person.fullName(),
    telegramChatId: faker.string.uuid(),
    telegramMessageThreadId: faker.string.uuid(),
    telegramSendSilently: faker.datatype.boolean(),
  }
}

export function getPostUserUserIdSettingsNotifications200Response() {
  return {
    notificationTypes: {
      discord: faker.number.int(),
      email: faker.number.int(),
      pushbullet: faker.number.int(),
      pushover: faker.number.int(),
      slack: faker.number.int(),
      telegram: faker.number.int(),
      webhook: faker.number.int(),
      webpush: faker.number.int(),
    },
    emailEnabled: faker.datatype.boolean(),
    pgpKey: faker.lorem.words(),
    discordEnabled: faker.datatype.boolean(),
    discordEnabledTypes: faker.number.int(),
    discordId: faker.string.uuid(),
    pushbulletAccessToken: faker.lorem.words(),
    pushoverApplicationToken: faker.lorem.words(),
    pushoverUserKey: faker.lorem.words(),
    pushoverSound: faker.lorem.words(),
    telegramEnabled: faker.datatype.boolean(),
    telegramBotUsername: faker.person.fullName(),
    telegramChatId: faker.string.uuid(),
    telegramMessageThreadId: faker.string.uuid(),
    telegramSendSilently: faker.datatype.boolean(),
  }
}

export function getGetUserUserIdSettingsPermissions200Response() {
  return {
    permissions: 2,
  }
}

export function getPostUserUserIdSettingsPermissions200Response() {
  return {
    permissions: 2,
  }
}

export function getGetUserUserIdWatchData200Response() {
  return {
    recentlyWatched: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        status: faker.number.int(),
        media: null,
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        requestedBy: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        modifiedBy: faker.helpers.arrayElement([
          {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          faker.lorem.words(),
        ]),
        is4k: faker.datatype.boolean(),
        serverId: faker.number.int(),
        profileId: faker.number.int(),
        rootFolder: faker.lorem.words(),
      })),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    })),
    playCount: faker.number.int(),
  }
}

export function getGetSearch200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      faker.helpers.arrayElement([
        {
          id: 1234,
          mediaType: faker.lorem.words(),
          popularity: 10,
          posterPath: faker.lorem.words(),
          backdropPath: faker.lorem.words(),
          voteCount: faker.number.int(),
          voteAverage: faker.number.int(),
          genreIds: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.number.int()),
          overview: 'Overview of the movie',
          originalLanguage: 'en',
          title: 'Movie Title',
          originalTitle: 'Original Movie Title',
          releaseDate: faker.lorem.words(),
          adult: faker.datatype.boolean(),
          video: faker.datatype.boolean(),
          mediaInfo: {
            id: faker.number.int(),
            mediaType: 'movie',
            tmdbId: faker.number.int(),
            tvdbId: faker.number.int(),
            status: faker.number.int(),
            requests: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              id: 123,
              status: faker.number.int(),
              media: null,
              createdAt: '2020-09-12T10:00:27.000Z',
              updatedAt: '2020-09-12T10:00:27.000Z',
              requestedBy: {
                id: 1,
                email: 'hey@itsme.com',
                username: faker.person.fullName(),
                plexUsername: faker.person.fullName(),
                plexToken: faker.lorem.words(),
                jellyfinAuthToken: faker.lorem.words(),
                userType: 1,
                permissions: faker.number.int(),
                avatar: faker.lorem.words(),
                createdAt: '2020-09-02T05:02:23.000Z',
                updatedAt: '2020-09-02T05:02:23.000Z',
                requestCount: 5,
                displayName: faker.person.fullName(),
              },
              modifiedBy: faker.helpers.arrayElement([
                {
                  id: 1,
                  email: 'hey@itsme.com',
                  username: faker.person.fullName(),
                  plexUsername: faker.person.fullName(),
                  plexToken: faker.lorem.words(),
                  jellyfinAuthToken: faker.lorem.words(),
                  userType: 1,
                  permissions: faker.number.int(),
                  avatar: faker.lorem.words(),
                  createdAt: '2020-09-02T05:02:23.000Z',
                  updatedAt: '2020-09-02T05:02:23.000Z',
                  requestCount: 5,
                  displayName: faker.person.fullName(),
                },
                faker.lorem.words(),
              ]),
              is4k: faker.datatype.boolean(),
              serverId: faker.number.int(),
              profileId: faker.number.int(),
              rootFolder: faker.lorem.words(),
            })),
            createdAt: '2020-09-12T10:00:27.000Z',
            updatedAt: '2020-09-12T10:00:27.000Z',
            mediaUrl: faker.internet.url(),
            downloadStatus: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              mediaType: faker.helpers.arrayElement(['movie', 'tv']),
              externalId: faker.number.int(),
              size: faker.number.int(),
              sizeLeft: faker.number.int(),
              status: faker.lorem.words(),
              timeLeft: faker.lorem.words(),
              estimatedCompletionTime: faker.date.past(),
              title: faker.lorem.words(),
              downloadId: faker.string.uuid(),
              episode: {
                seasonNumber: faker.number.int(),
                episodeNumber: faker.number.int(),
                absoluteEpisodeNumber: faker.number.int(),
                id: faker.number.int(),
              },
            })),
          },
        },
        {
          id: 1234,
          mediaType: faker.lorem.words(),
          popularity: 10,
          posterPath: faker.lorem.words(),
          backdropPath: faker.lorem.words(),
          voteCount: faker.number.int(),
          voteAverage: faker.number.int(),
          genreIds: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.number.int()),
          overview: 'Overview of the movie',
          originalLanguage: 'en',
          name: 'TV Show Name',
          originalName: 'Original TV Show Name',
          originCountry: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          firstAirDate: faker.lorem.words(),
          mediaInfo: {
            id: faker.number.int(),
            mediaType: 'movie',
            tmdbId: faker.number.int(),
            tvdbId: faker.number.int(),
            status: faker.number.int(),
            requests: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              id: 123,
              status: faker.number.int(),
              media: null,
              createdAt: '2020-09-12T10:00:27.000Z',
              updatedAt: '2020-09-12T10:00:27.000Z',
              requestedBy: {
                id: 1,
                email: 'hey@itsme.com',
                username: faker.person.fullName(),
                plexUsername: faker.person.fullName(),
                plexToken: faker.lorem.words(),
                jellyfinAuthToken: faker.lorem.words(),
                userType: 1,
                permissions: faker.number.int(),
                avatar: faker.lorem.words(),
                createdAt: '2020-09-02T05:02:23.000Z',
                updatedAt: '2020-09-02T05:02:23.000Z',
                requestCount: 5,
                displayName: faker.person.fullName(),
              },
              modifiedBy: faker.helpers.arrayElement([
                {
                  id: 1,
                  email: 'hey@itsme.com',
                  username: faker.person.fullName(),
                  plexUsername: faker.person.fullName(),
                  plexToken: faker.lorem.words(),
                  jellyfinAuthToken: faker.lorem.words(),
                  userType: 1,
                  permissions: faker.number.int(),
                  avatar: faker.lorem.words(),
                  createdAt: '2020-09-02T05:02:23.000Z',
                  updatedAt: '2020-09-02T05:02:23.000Z',
                  requestCount: 5,
                  displayName: faker.person.fullName(),
                },
                faker.lorem.words(),
              ]),
              is4k: faker.datatype.boolean(),
              serverId: faker.number.int(),
              profileId: faker.number.int(),
              rootFolder: faker.lorem.words(),
            })),
            createdAt: '2020-09-12T10:00:27.000Z',
            updatedAt: '2020-09-12T10:00:27.000Z',
            mediaUrl: faker.internet.url(),
            downloadStatus: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              mediaType: faker.helpers.arrayElement(['movie', 'tv']),
              externalId: faker.number.int(),
              size: faker.number.int(),
              sizeLeft: faker.number.int(),
              status: faker.lorem.words(),
              timeLeft: faker.lorem.words(),
              estimatedCompletionTime: faker.date.past(),
              title: faker.lorem.words(),
              downloadId: faker.string.uuid(),
              episode: {
                seasonNumber: faker.number.int(),
                episodeNumber: faker.number.int(),
                absoluteEpisodeNumber: faker.number.int(),
                id: faker.number.int(),
              },
            })),
          },
        },
        {
          id: 12345,
          profilePath: faker.lorem.words(),
          adult: faker.datatype.boolean(),
          mediaType: faker.lorem.words(),
          knownFor: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) =>
            faker.helpers.arrayElement([
              {
                id: 1234,
                mediaType: faker.lorem.words(),
                popularity: 10,
                posterPath: faker.lorem.words(),
                backdropPath: faker.lorem.words(),
                voteCount: faker.number.int(),
                voteAverage: faker.number.int(),
                genreIds: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => faker.number.int()),
                overview: 'Overview of the movie',
                originalLanguage: 'en',
                title: 'Movie Title',
                originalTitle: 'Original Movie Title',
                releaseDate: faker.lorem.words(),
                adult: faker.datatype.boolean(),
                video: faker.datatype.boolean(),
                mediaInfo: {
                  id: faker.number.int(),
                  mediaType: 'movie',
                  tmdbId: faker.number.int(),
                  tvdbId: faker.number.int(),
                  status: faker.number.int(),
                  requests: [
                    ...new Array(
                      faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                    ).keys(),
                  ].map((_) => ({
                    id: 123,
                    status: faker.number.int(),
                    media: null,
                    createdAt: '2020-09-12T10:00:27.000Z',
                    updatedAt: '2020-09-12T10:00:27.000Z',
                    requestedBy: {
                      id: 1,
                      email: 'hey@itsme.com',
                      username: faker.person.fullName(),
                      plexUsername: faker.person.fullName(),
                      plexToken: faker.lorem.words(),
                      jellyfinAuthToken: faker.lorem.words(),
                      userType: 1,
                      permissions: faker.number.int(),
                      avatar: faker.lorem.words(),
                      createdAt: '2020-09-02T05:02:23.000Z',
                      updatedAt: '2020-09-02T05:02:23.000Z',
                      requestCount: 5,
                      displayName: faker.person.fullName(),
                    },
                    modifiedBy: faker.helpers.arrayElement([
                      {
                        id: 1,
                        email: 'hey@itsme.com',
                        username: faker.person.fullName(),
                        plexUsername: faker.person.fullName(),
                        plexToken: faker.lorem.words(),
                        jellyfinAuthToken: faker.lorem.words(),
                        userType: 1,
                        permissions: faker.number.int(),
                        avatar: faker.lorem.words(),
                        createdAt: '2020-09-02T05:02:23.000Z',
                        updatedAt: '2020-09-02T05:02:23.000Z',
                        requestCount: 5,
                        displayName: faker.person.fullName(),
                      },
                      faker.lorem.words(),
                    ]),
                    is4k: faker.datatype.boolean(),
                    serverId: faker.number.int(),
                    profileId: faker.number.int(),
                    rootFolder: faker.lorem.words(),
                  })),
                  createdAt: '2020-09-12T10:00:27.000Z',
                  updatedAt: '2020-09-12T10:00:27.000Z',
                  mediaUrl: faker.internet.url(),
                  downloadStatus: [
                    ...new Array(
                      faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                    ).keys(),
                  ].map((_) => ({
                    mediaType: faker.helpers.arrayElement(['movie', 'tv']),
                    externalId: faker.number.int(),
                    size: faker.number.int(),
                    sizeLeft: faker.number.int(),
                    status: faker.lorem.words(),
                    timeLeft: faker.lorem.words(),
                    estimatedCompletionTime: faker.date.past(),
                    title: faker.lorem.words(),
                    downloadId: faker.string.uuid(),
                    episode: {
                      seasonNumber: faker.number.int(),
                      episodeNumber: faker.number.int(),
                      absoluteEpisodeNumber: faker.number.int(),
                      id: faker.number.int(),
                    },
                  })),
                },
              },
              {
                id: 1234,
                mediaType: faker.lorem.words(),
                popularity: 10,
                posterPath: faker.lorem.words(),
                backdropPath: faker.lorem.words(),
                voteCount: faker.number.int(),
                voteAverage: faker.number.int(),
                genreIds: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => faker.number.int()),
                overview: 'Overview of the movie',
                originalLanguage: 'en',
                name: 'TV Show Name',
                originalName: 'Original TV Show Name',
                originCountry: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => faker.lorem.words()),
                firstAirDate: faker.lorem.words(),
                mediaInfo: {
                  id: faker.number.int(),
                  mediaType: 'movie',
                  tmdbId: faker.number.int(),
                  tvdbId: faker.number.int(),
                  status: faker.number.int(),
                  requests: [
                    ...new Array(
                      faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                    ).keys(),
                  ].map((_) => ({
                    id: 123,
                    status: faker.number.int(),
                    media: null,
                    createdAt: '2020-09-12T10:00:27.000Z',
                    updatedAt: '2020-09-12T10:00:27.000Z',
                    requestedBy: {
                      id: 1,
                      email: 'hey@itsme.com',
                      username: faker.person.fullName(),
                      plexUsername: faker.person.fullName(),
                      plexToken: faker.lorem.words(),
                      jellyfinAuthToken: faker.lorem.words(),
                      userType: 1,
                      permissions: faker.number.int(),
                      avatar: faker.lorem.words(),
                      createdAt: '2020-09-02T05:02:23.000Z',
                      updatedAt: '2020-09-02T05:02:23.000Z',
                      requestCount: 5,
                      displayName: faker.person.fullName(),
                    },
                    modifiedBy: faker.helpers.arrayElement([
                      {
                        id: 1,
                        email: 'hey@itsme.com',
                        username: faker.person.fullName(),
                        plexUsername: faker.person.fullName(),
                        plexToken: faker.lorem.words(),
                        jellyfinAuthToken: faker.lorem.words(),
                        userType: 1,
                        permissions: faker.number.int(),
                        avatar: faker.lorem.words(),
                        createdAt: '2020-09-02T05:02:23.000Z',
                        updatedAt: '2020-09-02T05:02:23.000Z',
                        requestCount: 5,
                        displayName: faker.person.fullName(),
                      },
                      faker.lorem.words(),
                    ]),
                    is4k: faker.datatype.boolean(),
                    serverId: faker.number.int(),
                    profileId: faker.number.int(),
                    rootFolder: faker.lorem.words(),
                  })),
                  createdAt: '2020-09-12T10:00:27.000Z',
                  updatedAt: '2020-09-12T10:00:27.000Z',
                  mediaUrl: faker.internet.url(),
                  downloadStatus: [
                    ...new Array(
                      faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                    ).keys(),
                  ].map((_) => ({
                    mediaType: faker.helpers.arrayElement(['movie', 'tv']),
                    externalId: faker.number.int(),
                    size: faker.number.int(),
                    sizeLeft: faker.number.int(),
                    status: faker.lorem.words(),
                    timeLeft: faker.lorem.words(),
                    estimatedCompletionTime: faker.date.past(),
                    title: faker.lorem.words(),
                    downloadId: faker.string.uuid(),
                    episode: {
                      seasonNumber: faker.number.int(),
                      episodeNumber: faker.number.int(),
                      absoluteEpisodeNumber: faker.number.int(),
                      id: faker.number.int(),
                    },
                  })),
                },
              },
            ]),
          ),
        },
      ]),
    ),
  }
}

export function getGetSearchKeyword200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      name: 'anime',
    })),
  }
}

export function getGetSearchCompany200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      logo_path: faker.lorem.words(),
      name: faker.person.fullName(),
    })),
  }
}

export function getGetDiscoverMovies200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      title: 'Movie Title',
      originalTitle: 'Original Movie Title',
      releaseDate: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      video: faker.datatype.boolean(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverMoviesGenreGenreId200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    genre: {
      id: 1,
      name: 'Adventure',
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      title: 'Movie Title',
      originalTitle: 'Original Movie Title',
      releaseDate: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      video: faker.datatype.boolean(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverMoviesLanguageLanguage200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    language: {
      englishName: 'English',
      iso_639_1: 'en',
      name: 'English',
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      title: 'Movie Title',
      originalTitle: 'Original Movie Title',
      releaseDate: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      video: faker.datatype.boolean(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverMoviesStudioStudioId200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    studio: {
      id: 1,
      logoPath: faker.lorem.words(),
      originCountry: faker.lorem.words(),
      name: faker.person.fullName(),
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      title: 'Movie Title',
      originalTitle: 'Original Movie Title',
      releaseDate: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      video: faker.datatype.boolean(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverMoviesUpcoming200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      title: 'Movie Title',
      originalTitle: 'Original Movie Title',
      releaseDate: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      video: faker.datatype.boolean(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverTv200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      name: 'TV Show Name',
      originalName: 'Original TV Show Name',
      originCountry: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      firstAirDate: faker.lorem.words(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverTvLanguageLanguage200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    language: {
      englishName: 'English',
      iso_639_1: 'en',
      name: 'English',
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      name: 'TV Show Name',
      originalName: 'Original TV Show Name',
      originCountry: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      firstAirDate: faker.lorem.words(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverTvGenreGenreId200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    genre: {
      id: 1,
      name: 'Adventure',
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      name: 'TV Show Name',
      originalName: 'Original TV Show Name',
      originCountry: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      firstAirDate: faker.lorem.words(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverTvNetworkNetworkId200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    network: {
      id: 1,
      logoPath: faker.lorem.words(),
      originCountry: faker.lorem.words(),
      name: faker.person.fullName(),
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      name: 'TV Show Name',
      originalName: 'Original TV Show Name',
      originCountry: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      firstAirDate: faker.lorem.words(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverTvUpcoming200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      name: 'TV Show Name',
      originalName: 'Original TV Show Name',
      originCountry: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      firstAirDate: faker.lorem.words(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverTrending200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      faker.helpers.arrayElement([
        {
          id: 1234,
          mediaType: faker.lorem.words(),
          popularity: 10,
          posterPath: faker.lorem.words(),
          backdropPath: faker.lorem.words(),
          voteCount: faker.number.int(),
          voteAverage: faker.number.int(),
          genreIds: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.number.int()),
          overview: 'Overview of the movie',
          originalLanguage: 'en',
          title: 'Movie Title',
          originalTitle: 'Original Movie Title',
          releaseDate: faker.lorem.words(),
          adult: faker.datatype.boolean(),
          video: faker.datatype.boolean(),
          mediaInfo: {
            id: faker.number.int(),
            mediaType: 'movie',
            tmdbId: faker.number.int(),
            tvdbId: faker.number.int(),
            status: faker.number.int(),
            requests: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              id: 123,
              status: faker.number.int(),
              media: null,
              createdAt: '2020-09-12T10:00:27.000Z',
              updatedAt: '2020-09-12T10:00:27.000Z',
              requestedBy: {
                id: 1,
                email: 'hey@itsme.com',
                username: faker.person.fullName(),
                plexUsername: faker.person.fullName(),
                plexToken: faker.lorem.words(),
                jellyfinAuthToken: faker.lorem.words(),
                userType: 1,
                permissions: faker.number.int(),
                avatar: faker.lorem.words(),
                createdAt: '2020-09-02T05:02:23.000Z',
                updatedAt: '2020-09-02T05:02:23.000Z',
                requestCount: 5,
                displayName: faker.person.fullName(),
              },
              modifiedBy: faker.helpers.arrayElement([
                {
                  id: 1,
                  email: 'hey@itsme.com',
                  username: faker.person.fullName(),
                  plexUsername: faker.person.fullName(),
                  plexToken: faker.lorem.words(),
                  jellyfinAuthToken: faker.lorem.words(),
                  userType: 1,
                  permissions: faker.number.int(),
                  avatar: faker.lorem.words(),
                  createdAt: '2020-09-02T05:02:23.000Z',
                  updatedAt: '2020-09-02T05:02:23.000Z',
                  requestCount: 5,
                  displayName: faker.person.fullName(),
                },
                faker.lorem.words(),
              ]),
              is4k: faker.datatype.boolean(),
              serverId: faker.number.int(),
              profileId: faker.number.int(),
              rootFolder: faker.lorem.words(),
            })),
            createdAt: '2020-09-12T10:00:27.000Z',
            updatedAt: '2020-09-12T10:00:27.000Z',
            mediaUrl: faker.internet.url(),
            downloadStatus: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              mediaType: faker.helpers.arrayElement(['movie', 'tv']),
              externalId: faker.number.int(),
              size: faker.number.int(),
              sizeLeft: faker.number.int(),
              status: faker.lorem.words(),
              timeLeft: faker.lorem.words(),
              estimatedCompletionTime: faker.date.past(),
              title: faker.lorem.words(),
              downloadId: faker.string.uuid(),
              episode: {
                seasonNumber: faker.number.int(),
                episodeNumber: faker.number.int(),
                absoluteEpisodeNumber: faker.number.int(),
                id: faker.number.int(),
              },
            })),
          },
        },
        {
          id: 1234,
          mediaType: faker.lorem.words(),
          popularity: 10,
          posterPath: faker.lorem.words(),
          backdropPath: faker.lorem.words(),
          voteCount: faker.number.int(),
          voteAverage: faker.number.int(),
          genreIds: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.number.int()),
          overview: 'Overview of the movie',
          originalLanguage: 'en',
          name: 'TV Show Name',
          originalName: 'Original TV Show Name',
          originCountry: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          firstAirDate: faker.lorem.words(),
          mediaInfo: {
            id: faker.number.int(),
            mediaType: 'movie',
            tmdbId: faker.number.int(),
            tvdbId: faker.number.int(),
            status: faker.number.int(),
            requests: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              id: 123,
              status: faker.number.int(),
              media: null,
              createdAt: '2020-09-12T10:00:27.000Z',
              updatedAt: '2020-09-12T10:00:27.000Z',
              requestedBy: {
                id: 1,
                email: 'hey@itsme.com',
                username: faker.person.fullName(),
                plexUsername: faker.person.fullName(),
                plexToken: faker.lorem.words(),
                jellyfinAuthToken: faker.lorem.words(),
                userType: 1,
                permissions: faker.number.int(),
                avatar: faker.lorem.words(),
                createdAt: '2020-09-02T05:02:23.000Z',
                updatedAt: '2020-09-02T05:02:23.000Z',
                requestCount: 5,
                displayName: faker.person.fullName(),
              },
              modifiedBy: faker.helpers.arrayElement([
                {
                  id: 1,
                  email: 'hey@itsme.com',
                  username: faker.person.fullName(),
                  plexUsername: faker.person.fullName(),
                  plexToken: faker.lorem.words(),
                  jellyfinAuthToken: faker.lorem.words(),
                  userType: 1,
                  permissions: faker.number.int(),
                  avatar: faker.lorem.words(),
                  createdAt: '2020-09-02T05:02:23.000Z',
                  updatedAt: '2020-09-02T05:02:23.000Z',
                  requestCount: 5,
                  displayName: faker.person.fullName(),
                },
                faker.lorem.words(),
              ]),
              is4k: faker.datatype.boolean(),
              serverId: faker.number.int(),
              profileId: faker.number.int(),
              rootFolder: faker.lorem.words(),
            })),
            createdAt: '2020-09-12T10:00:27.000Z',
            updatedAt: '2020-09-12T10:00:27.000Z',
            mediaUrl: faker.internet.url(),
            downloadStatus: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              mediaType: faker.helpers.arrayElement(['movie', 'tv']),
              externalId: faker.number.int(),
              size: faker.number.int(),
              sizeLeft: faker.number.int(),
              status: faker.lorem.words(),
              timeLeft: faker.lorem.words(),
              estimatedCompletionTime: faker.date.past(),
              title: faker.lorem.words(),
              downloadId: faker.string.uuid(),
              episode: {
                seasonNumber: faker.number.int(),
                episodeNumber: faker.number.int(),
                absoluteEpisodeNumber: faker.number.int(),
                id: faker.number.int(),
              },
            })),
          },
        },
        {
          id: 12345,
          profilePath: faker.lorem.words(),
          adult: faker.datatype.boolean(),
          mediaType: faker.lorem.words(),
          knownFor: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) =>
            faker.helpers.arrayElement([
              {
                id: 1234,
                mediaType: faker.lorem.words(),
                popularity: 10,
                posterPath: faker.lorem.words(),
                backdropPath: faker.lorem.words(),
                voteCount: faker.number.int(),
                voteAverage: faker.number.int(),
                genreIds: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => faker.number.int()),
                overview: 'Overview of the movie',
                originalLanguage: 'en',
                title: 'Movie Title',
                originalTitle: 'Original Movie Title',
                releaseDate: faker.lorem.words(),
                adult: faker.datatype.boolean(),
                video: faker.datatype.boolean(),
                mediaInfo: {
                  id: faker.number.int(),
                  mediaType: 'movie',
                  tmdbId: faker.number.int(),
                  tvdbId: faker.number.int(),
                  status: faker.number.int(),
                  requests: [
                    ...new Array(
                      faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                    ).keys(),
                  ].map((_) => ({
                    id: 123,
                    status: faker.number.int(),
                    media: null,
                    createdAt: '2020-09-12T10:00:27.000Z',
                    updatedAt: '2020-09-12T10:00:27.000Z',
                    requestedBy: {
                      id: 1,
                      email: 'hey@itsme.com',
                      username: faker.person.fullName(),
                      plexUsername: faker.person.fullName(),
                      plexToken: faker.lorem.words(),
                      jellyfinAuthToken: faker.lorem.words(),
                      userType: 1,
                      permissions: faker.number.int(),
                      avatar: faker.lorem.words(),
                      createdAt: '2020-09-02T05:02:23.000Z',
                      updatedAt: '2020-09-02T05:02:23.000Z',
                      requestCount: 5,
                      displayName: faker.person.fullName(),
                    },
                    modifiedBy: faker.helpers.arrayElement([
                      {
                        id: 1,
                        email: 'hey@itsme.com',
                        username: faker.person.fullName(),
                        plexUsername: faker.person.fullName(),
                        plexToken: faker.lorem.words(),
                        jellyfinAuthToken: faker.lorem.words(),
                        userType: 1,
                        permissions: faker.number.int(),
                        avatar: faker.lorem.words(),
                        createdAt: '2020-09-02T05:02:23.000Z',
                        updatedAt: '2020-09-02T05:02:23.000Z',
                        requestCount: 5,
                        displayName: faker.person.fullName(),
                      },
                      faker.lorem.words(),
                    ]),
                    is4k: faker.datatype.boolean(),
                    serverId: faker.number.int(),
                    profileId: faker.number.int(),
                    rootFolder: faker.lorem.words(),
                  })),
                  createdAt: '2020-09-12T10:00:27.000Z',
                  updatedAt: '2020-09-12T10:00:27.000Z',
                  mediaUrl: faker.internet.url(),
                  downloadStatus: [
                    ...new Array(
                      faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                    ).keys(),
                  ].map((_) => ({
                    mediaType: faker.helpers.arrayElement(['movie', 'tv']),
                    externalId: faker.number.int(),
                    size: faker.number.int(),
                    sizeLeft: faker.number.int(),
                    status: faker.lorem.words(),
                    timeLeft: faker.lorem.words(),
                    estimatedCompletionTime: faker.date.past(),
                    title: faker.lorem.words(),
                    downloadId: faker.string.uuid(),
                    episode: {
                      seasonNumber: faker.number.int(),
                      episodeNumber: faker.number.int(),
                      absoluteEpisodeNumber: faker.number.int(),
                      id: faker.number.int(),
                    },
                  })),
                },
              },
              {
                id: 1234,
                mediaType: faker.lorem.words(),
                popularity: 10,
                posterPath: faker.lorem.words(),
                backdropPath: faker.lorem.words(),
                voteCount: faker.number.int(),
                voteAverage: faker.number.int(),
                genreIds: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => faker.number.int()),
                overview: 'Overview of the movie',
                originalLanguage: 'en',
                name: 'TV Show Name',
                originalName: 'Original TV Show Name',
                originCountry: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => faker.lorem.words()),
                firstAirDate: faker.lorem.words(),
                mediaInfo: {
                  id: faker.number.int(),
                  mediaType: 'movie',
                  tmdbId: faker.number.int(),
                  tvdbId: faker.number.int(),
                  status: faker.number.int(),
                  requests: [
                    ...new Array(
                      faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                    ).keys(),
                  ].map((_) => ({
                    id: 123,
                    status: faker.number.int(),
                    media: null,
                    createdAt: '2020-09-12T10:00:27.000Z',
                    updatedAt: '2020-09-12T10:00:27.000Z',
                    requestedBy: {
                      id: 1,
                      email: 'hey@itsme.com',
                      username: faker.person.fullName(),
                      plexUsername: faker.person.fullName(),
                      plexToken: faker.lorem.words(),
                      jellyfinAuthToken: faker.lorem.words(),
                      userType: 1,
                      permissions: faker.number.int(),
                      avatar: faker.lorem.words(),
                      createdAt: '2020-09-02T05:02:23.000Z',
                      updatedAt: '2020-09-02T05:02:23.000Z',
                      requestCount: 5,
                      displayName: faker.person.fullName(),
                    },
                    modifiedBy: faker.helpers.arrayElement([
                      {
                        id: 1,
                        email: 'hey@itsme.com',
                        username: faker.person.fullName(),
                        plexUsername: faker.person.fullName(),
                        plexToken: faker.lorem.words(),
                        jellyfinAuthToken: faker.lorem.words(),
                        userType: 1,
                        permissions: faker.number.int(),
                        avatar: faker.lorem.words(),
                        createdAt: '2020-09-02T05:02:23.000Z',
                        updatedAt: '2020-09-02T05:02:23.000Z',
                        requestCount: 5,
                        displayName: faker.person.fullName(),
                      },
                      faker.lorem.words(),
                    ]),
                    is4k: faker.datatype.boolean(),
                    serverId: faker.number.int(),
                    profileId: faker.number.int(),
                    rootFolder: faker.lorem.words(),
                  })),
                  createdAt: '2020-09-12T10:00:27.000Z',
                  updatedAt: '2020-09-12T10:00:27.000Z',
                  mediaUrl: faker.internet.url(),
                  downloadStatus: [
                    ...new Array(
                      faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                    ).keys(),
                  ].map((_) => ({
                    mediaType: faker.helpers.arrayElement(['movie', 'tv']),
                    externalId: faker.number.int(),
                    size: faker.number.int(),
                    sizeLeft: faker.number.int(),
                    status: faker.lorem.words(),
                    timeLeft: faker.lorem.words(),
                    estimatedCompletionTime: faker.date.past(),
                    title: faker.lorem.words(),
                    downloadId: faker.string.uuid(),
                    episode: {
                      seasonNumber: faker.number.int(),
                      episodeNumber: faker.number.int(),
                      absoluteEpisodeNumber: faker.number.int(),
                      id: faker.number.int(),
                    },
                  })),
                },
              },
            ]),
          ),
        },
      ]),
    ),
  }
}

export function getGetDiscoverKeywordKeywordIdMovies200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      title: 'Movie Title',
      originalTitle: 'Original Movie Title',
      releaseDate: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      video: faker.datatype.boolean(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetDiscoverGenresliderMovie200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 1,
    backdrops: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    name: 'Genre Name',
  }))
}

export function getGetDiscoverGenresliderTv200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 1,
    backdrops: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    name: 'Genre Name',
  }))
}

export function getGetDiscoverWatchlist200Response() {
  return {
    page: faker.number.int(),
    totalPages: faker.number.int(),
    totalResults: faker.number.int(),
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      tmdbId: 1,
      ratingKey: faker.lorem.words(),
      type: faker.lorem.words(),
      title: faker.lorem.words(),
    })),
  }
}

export function getGetRequest200Response() {
  return {
    pageInfo: {
      page: 1,
      pages: 10,
      results: 100,
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 123,
      status: faker.number.int(),
      media: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      requestedBy: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      modifiedBy: faker.helpers.arrayElement([
        {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        faker.lorem.words(),
      ]),
      is4k: faker.datatype.boolean(),
      serverId: faker.number.int(),
      profileId: faker.number.int(),
      rootFolder: faker.lorem.words(),
    })),
  }
}

export function getPostRequest201Response() {
  return {
    id: 123,
    status: faker.number.int(),
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdAt: '2020-09-12T10:00:27.000Z',
    updatedAt: '2020-09-12T10:00:27.000Z',
    requestedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    modifiedBy: faker.helpers.arrayElement([
      {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      faker.lorem.words(),
    ]),
    is4k: faker.datatype.boolean(),
    serverId: faker.number.int(),
    profileId: faker.number.int(),
    rootFolder: faker.lorem.words(),
  }
}

export function getGetRequestCount200Response() {
  return {
    total: faker.number.int(),
    movie: faker.number.int(),
    tv: faker.number.int(),
    pending: faker.number.int(),
    approved: faker.number.int(),
    declined: faker.number.int(),
    processing: faker.number.int(),
    available: faker.number.int(),
  }
}

export function getGetRequestRequestId200Response() {
  return {
    id: 123,
    status: faker.number.int(),
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdAt: '2020-09-12T10:00:27.000Z',
    updatedAt: '2020-09-12T10:00:27.000Z',
    requestedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    modifiedBy: faker.helpers.arrayElement([
      {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      faker.lorem.words(),
    ]),
    is4k: faker.datatype.boolean(),
    serverId: faker.number.int(),
    profileId: faker.number.int(),
    rootFolder: faker.lorem.words(),
  }
}

export function getPutRequestRequestId200Response() {
  return {
    id: 123,
    status: faker.number.int(),
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdAt: '2020-09-12T10:00:27.000Z',
    updatedAt: '2020-09-12T10:00:27.000Z',
    requestedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    modifiedBy: faker.helpers.arrayElement([
      {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      faker.lorem.words(),
    ]),
    is4k: faker.datatype.boolean(),
    serverId: faker.number.int(),
    profileId: faker.number.int(),
    rootFolder: faker.lorem.words(),
  }
}

export function getPostRequestRequestIdRetry200Response() {
  return {
    id: 123,
    status: faker.number.int(),
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdAt: '2020-09-12T10:00:27.000Z',
    updatedAt: '2020-09-12T10:00:27.000Z',
    requestedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    modifiedBy: faker.helpers.arrayElement([
      {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      faker.lorem.words(),
    ]),
    is4k: faker.datatype.boolean(),
    serverId: faker.number.int(),
    profileId: faker.number.int(),
    rootFolder: faker.lorem.words(),
  }
}

export function getPostRequestRequestIdStatus200Response() {
  return {
    id: 123,
    status: faker.number.int(),
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdAt: '2020-09-12T10:00:27.000Z',
    updatedAt: '2020-09-12T10:00:27.000Z',
    requestedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    modifiedBy: faker.helpers.arrayElement([
      {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      faker.lorem.words(),
    ]),
    is4k: faker.datatype.boolean(),
    serverId: faker.number.int(),
    profileId: faker.number.int(),
    rootFolder: faker.lorem.words(),
  }
}

export function getGetMovieMovieId200Response() {
  return {
    id: 123,
    imdbId: 'tt123',
    adult: faker.datatype.boolean(),
    backdropPath: faker.lorem.words(),
    posterPath: faker.lorem.words(),
    budget: 1000000,
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      name: 'Adventure',
    })),
    homepage: faker.lorem.words(),
    relatedVideos: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      url: 'https://www.youtube.com/watch?v=9qhL2_UxXM0/',
      key: '9qhL2_UxXM0',
      name: 'Trailer for some movie (1978)',
      size: 1080,
      type: 'Trailer',
      site: faker.helpers.arrayElement(['YouTube']),
    })),
    originalLanguage: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    overview: faker.lorem.words(),
    popularity: faker.number.int(),
    productionCompanies: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      logoPath: faker.lorem.words(),
      originCountry: faker.lorem.words(),
      name: faker.person.fullName(),
    })),
    productionCountries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      iso_3166_1: faker.lorem.words(),
      name: faker.person.fullName(),
    })),
    releaseDate: faker.lorem.words(),
    releases: {
      results: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        iso_3166_1: 'US',
        rating: faker.lorem.words(),
        release_dates: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          certification: 'PG-13',
          iso_639_1: faker.lorem.words(),
          note: 'Blu ray',
          release_date: '2017-07-12T00:00:00.000Z',
          type: 1,
        })),
      })),
    },
    revenue: faker.number.int(),
    runtime: faker.number.int(),
    spokenLanguages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      englishName: 'English',
      iso_639_1: 'en',
      name: 'English',
    })),
    status: faker.lorem.words(),
    tagline: faker.lorem.words(),
    title: faker.lorem.words(),
    video: faker.datatype.boolean(),
    voteAverage: faker.number.int(),
    voteCount: faker.number.int(),
    credits: {
      cast: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        castId: 1,
        character: 'Some Character Name',
        creditId: faker.string.uuid(),
        gender: faker.number.int(),
        name: 'Some Persons Name',
        order: faker.number.int(),
        profilePath: faker.lorem.words(),
      })),
      crew: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        creditId: faker.string.uuid(),
        gender: faker.number.int(),
        name: 'Some Persons Name',
        job: faker.lorem.words(),
        department: faker.lorem.words(),
        profilePath: faker.lorem.words(),
      })),
    },
    collection: {
      id: 1,
      name: 'A collection',
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
    },
    externalIds: {
      facebookId: faker.string.uuid(),
      freebaseId: faker.string.uuid(),
      freebaseMid: faker.string.uuid(),
      imdbId: faker.string.uuid(),
      instagramId: faker.string.uuid(),
      tvdbId: faker.number.int(),
      tvrageId: faker.number.int(),
      twitterId: faker.string.uuid(),
    },
    mediaInfo: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        status: faker.number.int(),
        media: null,
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        requestedBy: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        modifiedBy: faker.helpers.arrayElement([
          {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          faker.lorem.words(),
        ]),
        is4k: faker.datatype.boolean(),
        serverId: faker.number.int(),
        profileId: faker.number.int(),
        rootFolder: faker.lorem.words(),
      })),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    watchProviders: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        iso_3166_1: faker.lorem.words(),
        link: faker.lorem.words(),
        buy: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          displayPriority: faker.number.int(),
          logoPath: faker.lorem.words(),
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        flatrate: null,
      })),
    ),
  }
}

export function getGetMovieMovieIdRecommendations200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      title: 'Movie Title',
      originalTitle: 'Original Movie Title',
      releaseDate: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      video: faker.datatype.boolean(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetMovieMovieIdSimilar200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      title: 'Movie Title',
      originalTitle: 'Original Movie Title',
      releaseDate: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      video: faker.datatype.boolean(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetMovieMovieIdRatings200Response() {
  return {
    title: 'Mulan',
    year: 2020,
    url: 'http://www.rottentomatoes.com/m/mulan_2020/',
    criticsScore: 85,
    criticsRating: faker.helpers.arrayElement([
      'Rotten',
      'Fresh',
      'Certified Fresh',
    ]),
    audienceScore: 65,
    audienceRating: faker.helpers.arrayElement(['Spilled', 'Upright']),
  }
}

export function getGetMovieMovieIdRatingscombined200Response() {
  return {
    rt: {
      title: 'Mulan',
      year: 2020,
      url: 'http://www.rottentomatoes.com/m/mulan_2020/',
      criticsScore: 85,
      criticsRating: faker.helpers.arrayElement([
        'Rotten',
        'Fresh',
        'Certified Fresh',
      ]),
      audienceScore: 65,
      audienceRating: faker.helpers.arrayElement(['Spilled', 'Upright']),
    },
    imdb: {
      title: 'I am Legend',
      url: 'https://www.imdb.com/title/tt0480249',
      criticsScore: 6.5,
    },
  }
}

export function getGetTvTvId200Response() {
  return {
    id: 123,
    backdropPath: faker.lorem.words(),
    posterPath: faker.lorem.words(),
    contentRatings: {
      results: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        iso_3166_1: 'US',
        rating: 'TV-14',
      })),
    },
    createdBy: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      gender: faker.number.int(),
      profilePath: faker.lorem.words(),
    })),
    episodeRunTime: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    firstAirDate: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      name: 'Adventure',
    })),
    homepage: faker.lorem.words(),
    inProduction: faker.datatype.boolean(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    lastAirDate: faker.lorem.words(),
    lastEpisodeToAir: {
      id: faker.number.int(),
      name: faker.person.fullName(),
      airDate: faker.lorem.words(),
      episodeNumber: faker.number.int(),
      overview: faker.lorem.words(),
      productionCode: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      showId: faker.number.int(),
      stillPath: faker.lorem.words(),
      voteAverage: faker.number.int(),
      voteCount: faker.number.int(),
    },
    name: faker.person.fullName(),
    nextEpisodeToAir: {
      id: faker.number.int(),
      name: faker.person.fullName(),
      airDate: faker.lorem.words(),
      episodeNumber: faker.number.int(),
      overview: faker.lorem.words(),
      productionCode: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      showId: faker.number.int(),
      stillPath: faker.lorem.words(),
      voteAverage: faker.number.int(),
      voteCount: faker.number.int(),
    },
    networks: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      logoPath: faker.lorem.words(),
      originCountry: faker.lorem.words(),
      name: faker.person.fullName(),
    })),
    numberOfEpisodes: faker.number.int(),
    numberOfSeason: faker.number.int(),
    originCountry: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    originalLanguage: faker.lorem.words(),
    originalName: faker.person.fullName(),
    overview: faker.lorem.words(),
    popularity: faker.number.int(),
    productionCompanies: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      logoPath: faker.lorem.words(),
      originCountry: faker.lorem.words(),
      name: faker.person.fullName(),
    })),
    productionCountries: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      iso_3166_1: faker.lorem.words(),
      name: faker.person.fullName(),
    })),
    spokenLanguages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      englishName: 'English',
      iso_639_1: 'en',
      name: 'English',
    })),
    seasons: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      airDate: faker.lorem.words(),
      episodeCount: faker.number.int(),
      name: faker.person.fullName(),
      overview: faker.lorem.words(),
      posterPath: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      episodes: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        airDate: faker.lorem.words(),
        episodeNumber: faker.number.int(),
        overview: faker.lorem.words(),
        productionCode: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        showId: faker.number.int(),
        stillPath: faker.lorem.words(),
        voteAverage: faker.number.int(),
        voteCount: faker.number.int(),
      })),
    })),
    status: faker.lorem.words(),
    tagline: faker.lorem.words(),
    type: faker.lorem.words(),
    voteAverage: faker.number.int(),
    voteCount: faker.number.int(),
    credits: {
      cast: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        castId: 1,
        character: 'Some Character Name',
        creditId: faker.string.uuid(),
        gender: faker.number.int(),
        name: 'Some Persons Name',
        order: faker.number.int(),
        profilePath: faker.lorem.words(),
      })),
      crew: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        creditId: faker.string.uuid(),
        gender: faker.number.int(),
        name: 'Some Persons Name',
        job: faker.lorem.words(),
        department: faker.lorem.words(),
        profilePath: faker.lorem.words(),
      })),
    },
    externalIds: {
      facebookId: faker.string.uuid(),
      freebaseId: faker.string.uuid(),
      freebaseMid: faker.string.uuid(),
      imdbId: faker.string.uuid(),
      instagramId: faker.string.uuid(),
      tvdbId: faker.number.int(),
      tvrageId: faker.number.int(),
      twitterId: faker.string.uuid(),
    },
    keywords: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      name: 'anime',
    })),
    mediaInfo: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        status: faker.number.int(),
        media: null,
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        requestedBy: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        modifiedBy: faker.helpers.arrayElement([
          {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          faker.lorem.words(),
        ]),
        is4k: faker.datatype.boolean(),
        serverId: faker.number.int(),
        profileId: faker.number.int(),
        rootFolder: faker.lorem.words(),
      })),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    watchProviders: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        iso_3166_1: faker.lorem.words(),
        link: faker.lorem.words(),
        buy: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          displayPriority: faker.number.int(),
          logoPath: faker.lorem.words(),
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        flatrate: null,
      })),
    ),
  }
}

export function getGetTvTvIdSeasonSeasonId200Response() {
  return {
    id: faker.number.int(),
    airDate: faker.lorem.words(),
    episodeCount: faker.number.int(),
    name: faker.person.fullName(),
    overview: faker.lorem.words(),
    posterPath: faker.lorem.words(),
    seasonNumber: faker.number.int(),
    episodes: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      airDate: faker.lorem.words(),
      episodeNumber: faker.number.int(),
      overview: faker.lorem.words(),
      productionCode: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      showId: faker.number.int(),
      stillPath: faker.lorem.words(),
      voteAverage: faker.number.int(),
      voteCount: faker.number.int(),
    })),
  }
}

export function getGetTvTvIdRecommendations200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      name: 'TV Show Name',
      originalName: 'Original TV Show Name',
      originCountry: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      firstAirDate: faker.lorem.words(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetTvTvIdSimilar200Response() {
  return {
    page: 1,
    totalPages: 20,
    totalResults: 200,
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      name: 'TV Show Name',
      originalName: 'Original TV Show Name',
      originCountry: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      firstAirDate: faker.lorem.words(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetTvTvIdRatings200Response() {
  return {
    title: 'The Boys',
    year: 2019,
    url: 'http://www.rottentomatoes.com/m/mulan_2020/',
    criticsScore: 85,
    criticsRating: faker.helpers.arrayElement(['Rotten', 'Fresh']),
  }
}

export function getGetPersonPersonId200Response() {
  return {
    id: 1,
    name: faker.person.fullName(),
    deathday: faker.lorem.words(),
    knownForDepartment: faker.lorem.words(),
    alsoKnownAs: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    gender: faker.lorem.words(),
    biography: faker.lorem.words(),
    popularity: faker.lorem.words(),
    placeOfBirth: faker.lorem.words(),
    profilePath: faker.lorem.words(),
    adult: faker.datatype.boolean(),
    imdbId: faker.string.uuid(),
    homepage: faker.lorem.words(),
  }
}

export function getGetPersonPersonIdCombinedCredits200Response() {
  return {
    cast: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      originalLanguage: faker.lorem.words(),
      episodeCount: faker.number.int(),
      overview: faker.lorem.words(),
      originCountry: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      originalName: faker.person.fullName(),
      voteCount: faker.number.int(),
      name: faker.person.fullName(),
      mediaType: faker.lorem.words(),
      popularity: faker.number.int(),
      creditId: faker.string.uuid(),
      backdropPath: faker.lorem.words(),
      firstAirDate: faker.lorem.words(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      posterPath: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      video: faker.datatype.boolean(),
      title: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      releaseDate: faker.lorem.words(),
      character: faker.lorem.words(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
    crew: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      originalLanguage: faker.lorem.words(),
      episodeCount: faker.number.int(),
      overview: faker.lorem.words(),
      originCountry: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      originalName: faker.person.fullName(),
      voteCount: faker.number.int(),
      name: faker.person.fullName(),
      mediaType: faker.lorem.words(),
      popularity: faker.number.int(),
      creditId: faker.string.uuid(),
      backdropPath: faker.lorem.words(),
      firstAirDate: faker.lorem.words(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      posterPath: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      video: faker.datatype.boolean(),
      title: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      releaseDate: faker.lorem.words(),
      department: faker.lorem.words(),
      job: faker.lorem.words(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
    id: faker.number.int(),
  }
}

export function getGetMedia200Response() {
  return {
    pageInfo: {
      page: 1,
      pages: 10,
      results: 100,
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        status: faker.number.int(),
        media: null,
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        requestedBy: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        modifiedBy: faker.helpers.arrayElement([
          {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          faker.lorem.words(),
        ]),
        is4k: faker.datatype.boolean(),
        serverId: faker.number.int(),
        profileId: faker.number.int(),
        rootFolder: faker.lorem.words(),
      })),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    })),
  }
}

export function getPostMediaMediaIdStatus200Response() {
  return {
    id: faker.number.int(),
    mediaType: 'movie',
    tmdbId: faker.number.int(),
    tvdbId: faker.number.int(),
    status: faker.number.int(),
    requests: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 123,
      status: faker.number.int(),
      media: null,
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      requestedBy: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      modifiedBy: faker.helpers.arrayElement([
        {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        faker.lorem.words(),
      ]),
      is4k: faker.datatype.boolean(),
      serverId: faker.number.int(),
      profileId: faker.number.int(),
      rootFolder: faker.lorem.words(),
    })),
    createdAt: '2020-09-12T10:00:27.000Z',
    updatedAt: '2020-09-12T10:00:27.000Z',
    mediaUrl: faker.internet.url(),
    downloadStatus: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      mediaType: faker.helpers.arrayElement(['movie', 'tv']),
      externalId: faker.number.int(),
      size: faker.number.int(),
      sizeLeft: faker.number.int(),
      status: faker.lorem.words(),
      timeLeft: faker.lorem.words(),
      estimatedCompletionTime: faker.date.past(),
      title: faker.lorem.words(),
      downloadId: faker.string.uuid(),
      episode: {
        seasonNumber: faker.number.int(),
        episodeNumber: faker.number.int(),
        absoluteEpisodeNumber: faker.number.int(),
        id: faker.number.int(),
      },
    })),
  }
}

export function getGetMediaMediaIdWatchData200Response() {
  return {
    data: {
      playCount7Days: faker.number.int(),
      playCount30Days: faker.number.int(),
      playCount: faker.number.int(),
      users: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      })),
    },
    data4k: {
      playCount7Days: faker.number.int(),
      playCount30Days: faker.number.int(),
      playCount: faker.number.int(),
      users: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      })),
    },
  }
}

export function getGetCollectionCollectionId200Response() {
  return {
    id: 123,
    name: 'A Movie Collection',
    overview: 'Overview of collection',
    posterPath: faker.lorem.words(),
    backdropPath: faker.lorem.words(),
    parts: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1234,
      mediaType: faker.lorem.words(),
      popularity: 10,
      posterPath: faker.lorem.words(),
      backdropPath: faker.lorem.words(),
      voteCount: faker.number.int(),
      voteAverage: faker.number.int(),
      genreIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      overview: 'Overview of the movie',
      originalLanguage: 'en',
      title: 'Movie Title',
      originalTitle: 'Original Movie Title',
      releaseDate: faker.lorem.words(),
      adult: faker.datatype.boolean(),
      video: faker.datatype.boolean(),
      mediaInfo: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
    })),
  }
}

export function getGetServiceRadarr200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: 'Radarr Main',
    hostname: '127.0.0.1',
    port: 7878,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/movies',
    is4k: faker.datatype.boolean(),
    minimumAvailability: 'In Cinema',
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }))
}

export function getGetServiceRadarrRadarrId200Response() {
  return {
    server: {
      id: faker.number.int(),
      name: 'Radarr Main',
      hostname: '127.0.0.1',
      port: 7878,
      apiKey: 'exampleapikey',
      useSsl: faker.datatype.boolean(),
      baseUrl: faker.internet.url(),
      activeProfileId: 1,
      activeProfileName: '720p/1080p',
      activeDirectory: '/movies',
      is4k: faker.datatype.boolean(),
      minimumAvailability: 'In Cinema',
      isDefault: faker.datatype.boolean(),
      externalUrl: 'http://radarr.example.com',
      syncEnabled: faker.datatype.boolean(),
      preventSearch: faker.datatype.boolean(),
    },
    profiles: {
      id: 1,
      name: '720p/1080p',
    },
  }
}

export function getGetServiceSonarr200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: 'Sonarr Main',
    hostname: '127.0.0.1',
    port: 8989,
    apiKey: 'exampleapikey',
    useSsl: faker.datatype.boolean(),
    baseUrl: faker.internet.url(),
    activeProfileId: 1,
    activeProfileName: '720p/1080p',
    activeDirectory: '/tv/',
    activeLanguageProfileId: 1,
    activeAnimeProfileId: faker.number.int(),
    activeAnimeLanguageProfileId: faker.number.int(),
    activeAnimeProfileName: '720p/1080p',
    activeAnimeDirectory: faker.lorem.words(),
    is4k: faker.datatype.boolean(),
    enableSeasonFolders: faker.datatype.boolean(),
    isDefault: faker.datatype.boolean(),
    externalUrl: 'http://radarr.example.com',
    syncEnabled: faker.datatype.boolean(),
    preventSearch: faker.datatype.boolean(),
  }))
}

export function getGetServiceSonarrSonarrId200Response() {
  return {
    server: {
      id: faker.number.int(),
      name: 'Sonarr Main',
      hostname: '127.0.0.1',
      port: 8989,
      apiKey: 'exampleapikey',
      useSsl: faker.datatype.boolean(),
      baseUrl: faker.internet.url(),
      activeProfileId: 1,
      activeProfileName: '720p/1080p',
      activeDirectory: '/tv/',
      activeLanguageProfileId: 1,
      activeAnimeProfileId: faker.number.int(),
      activeAnimeLanguageProfileId: faker.number.int(),
      activeAnimeProfileName: '720p/1080p',
      activeAnimeDirectory: faker.lorem.words(),
      is4k: faker.datatype.boolean(),
      enableSeasonFolders: faker.datatype.boolean(),
      isDefault: faker.datatype.boolean(),
      externalUrl: 'http://radarr.example.com',
      syncEnabled: faker.datatype.boolean(),
      preventSearch: faker.datatype.boolean(),
    },
    profiles: {
      id: 1,
      name: '720p/1080p',
    },
  }
}

export function getGetServiceSonarrLookupTmdbId200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    title: 'COVID-25',
    sortTitle: 'covid 25',
    seasonCount: 1,
    status: 'upcoming',
    overview: 'The thread is picked up again by Marianne Schmidt which ...',
    network: 'CBS',
    airTime: '02:15',
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: 'banner',
      url: '/sonarr/MediaCoverProxy/6467f05d9872726ad08cbf920e5fee4bf69198682260acab8eab5d3c2c958e92/5c8f116c6aa5c.jpg',
    })),
    remotePoster:
      'https://artworks.thetvdb.com/banners/posters/5c8f116129983.jpg',
    seasons: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      seasonNumber: 1,
      monitored: true,
    })),
    year: 2015,
    path: faker.lorem.words(),
    profileId: faker.number.int(),
    languageProfileId: faker.number.int(),
    seasonFolder: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    useSceneNumbering: faker.datatype.boolean(),
    runtime: faker.number.int(),
    tvdbId: 12345,
    tvRageId: faker.number.int(),
    tvMazeId: faker.number.int(),
    firstAired: faker.lorem.words(),
    lastInfoSync: faker.lorem.words(),
    seriesType: faker.lorem.words(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    titleSlug: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    added: faker.lorem.words(),
    ratings: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      votes: faker.number.int(),
      value: faker.number.int(),
    })),
    qualityProfileId: faker.number.int(),
    id: faker.number.int(),
    rootFolderPath: faker.lorem.words(),
    addOptions: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      searchForMissingEpisodes: faker.datatype.boolean(),
    })),
  }))
}

export function getGetRegions200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    iso_3166_1: 'US',
    english_name: 'United States of America',
  }))
}

export function getGetLanguages200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    iso_639_1: 'en',
    english_name: 'English',
    name: 'English',
  }))
}

export function getGetStudioStudioId200Response() {
  return {
    id: 1,
    logoPath: faker.lorem.words(),
    originCountry: faker.lorem.words(),
    name: faker.person.fullName(),
  }
}

export function getGetNetworkNetworkId200Response() {
  return {
    id: 1,
    logoPath: faker.lorem.words(),
    originCountry: faker.lorem.words(),
    name: faker.person.fullName(),
  }
}

export function getGetGenresMovie200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 10751,
    name: 'Family',
  }))
}

export function getGetGenresTv200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: 18,
    name: 'Drama',
  }))
}

export function getGetBackdrops200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => faker.lorem.words())
}

export function getGetIssue200Response() {
  return {
    pageInfo: {
      page: 1,
      pages: 10,
      results: 100,
    },
    results: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      issueType: 1,
      media: {
        id: faker.number.int(),
        mediaType: 'movie',
        tmdbId: faker.number.int(),
        tvdbId: faker.number.int(),
        status: faker.number.int(),
        requests: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: 123,
          status: faker.number.int(),
          media: null,
          createdAt: '2020-09-12T10:00:27.000Z',
          updatedAt: '2020-09-12T10:00:27.000Z',
          requestedBy: {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          modifiedBy: faker.helpers.arrayElement([
            {
              id: 1,
              email: 'hey@itsme.com',
              username: faker.person.fullName(),
              plexUsername: faker.person.fullName(),
              plexToken: faker.lorem.words(),
              jellyfinAuthToken: faker.lorem.words(),
              userType: 1,
              permissions: faker.number.int(),
              avatar: faker.lorem.words(),
              createdAt: '2020-09-02T05:02:23.000Z',
              updatedAt: '2020-09-02T05:02:23.000Z',
              requestCount: 5,
              displayName: faker.person.fullName(),
            },
            faker.lorem.words(),
          ]),
          is4k: faker.datatype.boolean(),
          serverId: faker.number.int(),
          profileId: faker.number.int(),
          rootFolder: faker.lorem.words(),
        })),
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        mediaUrl: faker.internet.url(),
        downloadStatus: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          mediaType: faker.helpers.arrayElement(['movie', 'tv']),
          externalId: faker.number.int(),
          size: faker.number.int(),
          sizeLeft: faker.number.int(),
          status: faker.lorem.words(),
          timeLeft: faker.lorem.words(),
          estimatedCompletionTime: faker.date.past(),
          title: faker.lorem.words(),
          downloadId: faker.string.uuid(),
          episode: {
            seasonNumber: faker.number.int(),
            episodeNumber: faker.number.int(),
            absoluteEpisodeNumber: faker.number.int(),
            id: faker.number.int(),
          },
        })),
      },
      createdBy: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      modifiedBy: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      comments: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 1,
        user: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        message: 'A comment',
      })),
    })),
  }
}

export function getPostIssue201Response() {
  return {
    id: 1,
    issueType: 1,
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        status: faker.number.int(),
        media: null,
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        requestedBy: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        modifiedBy: faker.helpers.arrayElement([
          {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          faker.lorem.words(),
        ]),
        is4k: faker.datatype.boolean(),
        serverId: faker.number.int(),
        profileId: faker.number.int(),
        rootFolder: faker.lorem.words(),
      })),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    modifiedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    comments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      user: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      message: 'A comment',
    })),
  }
}

export function getGetIssueCount200Response() {
  return {
    total: faker.number.int(),
    video: faker.number.int(),
    audio: faker.number.int(),
    subtitles: faker.number.int(),
    others: faker.number.int(),
    open: faker.number.int(),
    closed: faker.number.int(),
  }
}

export function getGetIssueIssueId200Response() {
  return {
    id: 1,
    issueType: 1,
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        status: faker.number.int(),
        media: null,
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        requestedBy: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        modifiedBy: faker.helpers.arrayElement([
          {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          faker.lorem.words(),
        ]),
        is4k: faker.datatype.boolean(),
        serverId: faker.number.int(),
        profileId: faker.number.int(),
        rootFolder: faker.lorem.words(),
      })),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    modifiedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    comments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      user: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      message: 'A comment',
    })),
  }
}

export function getPostIssueIssueIdComment200Response() {
  return {
    id: 1,
    issueType: 1,
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        status: faker.number.int(),
        media: null,
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        requestedBy: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        modifiedBy: faker.helpers.arrayElement([
          {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          faker.lorem.words(),
        ]),
        is4k: faker.datatype.boolean(),
        serverId: faker.number.int(),
        profileId: faker.number.int(),
        rootFolder: faker.lorem.words(),
      })),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    modifiedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    comments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      user: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      message: 'A comment',
    })),
  }
}

export function getGetIssueCommentCommentId200Response() {
  return {
    id: 1,
    user: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    message: 'A comment',
  }
}

export function getPutIssueCommentCommentId200Response() {
  return {
    id: 1,
    user: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    message: 'A comment',
  }
}

export function getPostIssueIssueIdStatus200Response() {
  return {
    id: 1,
    issueType: 1,
    media: {
      id: faker.number.int(),
      mediaType: 'movie',
      tmdbId: faker.number.int(),
      tvdbId: faker.number.int(),
      status: faker.number.int(),
      requests: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: 123,
        status: faker.number.int(),
        media: null,
        createdAt: '2020-09-12T10:00:27.000Z',
        updatedAt: '2020-09-12T10:00:27.000Z',
        requestedBy: {
          id: 1,
          email: 'hey@itsme.com',
          username: faker.person.fullName(),
          plexUsername: faker.person.fullName(),
          plexToken: faker.lorem.words(),
          jellyfinAuthToken: faker.lorem.words(),
          userType: 1,
          permissions: faker.number.int(),
          avatar: faker.lorem.words(),
          createdAt: '2020-09-02T05:02:23.000Z',
          updatedAt: '2020-09-02T05:02:23.000Z',
          requestCount: 5,
          displayName: faker.person.fullName(),
        },
        modifiedBy: faker.helpers.arrayElement([
          {
            id: 1,
            email: 'hey@itsme.com',
            username: faker.person.fullName(),
            plexUsername: faker.person.fullName(),
            plexToken: faker.lorem.words(),
            jellyfinAuthToken: faker.lorem.words(),
            userType: 1,
            permissions: faker.number.int(),
            avatar: faker.lorem.words(),
            createdAt: '2020-09-02T05:02:23.000Z',
            updatedAt: '2020-09-02T05:02:23.000Z',
            requestCount: 5,
            displayName: faker.person.fullName(),
          },
          faker.lorem.words(),
        ]),
        is4k: faker.datatype.boolean(),
        serverId: faker.number.int(),
        profileId: faker.number.int(),
        rootFolder: faker.lorem.words(),
      })),
      createdAt: '2020-09-12T10:00:27.000Z',
      updatedAt: '2020-09-12T10:00:27.000Z',
      mediaUrl: faker.internet.url(),
      downloadStatus: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        mediaType: faker.helpers.arrayElement(['movie', 'tv']),
        externalId: faker.number.int(),
        size: faker.number.int(),
        sizeLeft: faker.number.int(),
        status: faker.lorem.words(),
        timeLeft: faker.lorem.words(),
        estimatedCompletionTime: faker.date.past(),
        title: faker.lorem.words(),
        downloadId: faker.string.uuid(),
        episode: {
          seasonNumber: faker.number.int(),
          episodeNumber: faker.number.int(),
          absoluteEpisodeNumber: faker.number.int(),
          id: faker.number.int(),
        },
      })),
    },
    createdBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    modifiedBy: {
      id: 1,
      email: 'hey@itsme.com',
      username: faker.person.fullName(),
      plexUsername: faker.person.fullName(),
      plexToken: faker.lorem.words(),
      jellyfinAuthToken: faker.lorem.words(),
      userType: 1,
      permissions: faker.number.int(),
      avatar: faker.lorem.words(),
      createdAt: '2020-09-02T05:02:23.000Z',
      updatedAt: '2020-09-02T05:02:23.000Z',
      requestCount: 5,
      displayName: faker.person.fullName(),
    },
    comments: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: 1,
      user: {
        id: 1,
        email: 'hey@itsme.com',
        username: faker.person.fullName(),
        plexUsername: faker.person.fullName(),
        plexToken: faker.lorem.words(),
        jellyfinAuthToken: faker.lorem.words(),
        userType: 1,
        permissions: faker.number.int(),
        avatar: faker.lorem.words(),
        createdAt: '2020-09-02T05:02:23.000Z',
        updatedAt: '2020-09-02T05:02:23.000Z',
        requestCount: 5,
        displayName: faker.person.fullName(),
      },
      message: 'A comment',
    })),
  }
}

export function getGetKeywordKeywordId200Response() {
  return {
    id: 1,
    name: 'anime',
  }
}

export function getGetWatchprovidersRegions200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    iso_3166_1: faker.lorem.words(),
    english_name: faker.person.fullName(),
    native_name: faker.person.fullName(),
  }))
}

export function getGetWatchprovidersMovies200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    displayPriority: faker.number.int(),
    logoPath: faker.lorem.words(),
    id: faker.number.int(),
    name: faker.person.fullName(),
  }))
}

export function getGetWatchprovidersTv200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    displayPriority: faker.number.int(),
    logoPath: faker.lorem.words(),
    id: faker.number.int(),
    name: faker.person.fullName(),
  }))
}

export function getGetOverrideRule200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.string.uuid(),
  }))
}

export function getPostOverrideRule200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.string.uuid(),
  }))
}

export function getPutOverrideRuleRuleId200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.string.uuid(),
  }))
}

export function getDeleteOverrideRuleRuleId200Response() {
  return {
    id: faker.string.uuid(),
  }
}
