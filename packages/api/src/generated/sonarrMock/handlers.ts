// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/**
 * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/zoubingwu/msw-auto-mock)
 * Feel free to commit/edit it as you need.
 */
/* eslint-disable */
/* tslint:disable */
import { HttpResponse, http } from 'msw'
import { faker } from '@faker-js/faker'

faker.seed(1)

const baseURL = ''
const MAX_ARRAY_LENGTH = 20

let i = 0
const next = () => {
  if (i === Number.MAX_SAFE_INTEGER - 1) {
    i = 0
  }
  return i++
}

export const handlers = [
  http.get(`${baseURL}/api`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/login`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/login`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/logout`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/autotagging`, async () => {
    const resultArray = [
      [await getPostApiV3Autotagging200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/autotagging`, async () => {
    const resultArray = [
      [await getGetApiV3Autotagging200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/autotagging/:id`, async () => {
    const resultArray = [
      [await getPutApiV3AutotaggingId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/autotagging/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/autotagging/:id`, async () => {
    const resultArray = [
      [await getGetApiV3AutotaggingId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/autotagging/schema`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/system/backup`, async () => {
    const resultArray = [
      [await getGetApiV3SystemBackup200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/system/backup/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/system/backup/restore/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/system/backup/restore/upload`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/blocklist`, async () => {
    const resultArray = [
      [await getGetApiV3Blocklist200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/blocklist/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/blocklist/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/calendar`, async () => {
    const resultArray = [
      [await getGetApiV3Calendar200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/calendar/:id`, async () => {
    const resultArray = [
      [await getGetApiV3CalendarId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/feed/v3/calendar/sonarr.ics`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/command`, async () => {
    const resultArray = [
      [await getPostApiV3Command200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/command`, async () => {
    const resultArray = [
      [await getGetApiV3Command200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/command/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/command/:id`, async () => {
    const resultArray = [
      [await getGetApiV3CommandId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/customfilter`, async () => {
    const resultArray = [
      [await getGetApiV3Customfilter200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/customfilter`, async () => {
    const resultArray = [
      [await getPostApiV3Customfilter200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/customfilter/:id`, async () => {
    const resultArray = [
      [await getPutApiV3CustomfilterId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/customfilter/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/customfilter/:id`, async () => {
    const resultArray = [
      [await getGetApiV3CustomfilterId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/customformat`, async () => {
    const resultArray = [
      [await getGetApiV3Customformat200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/customformat`, async () => {
    const resultArray = [
      [await getPostApiV3Customformat200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/customformat/:id`, async () => {
    const resultArray = [
      [await getPutApiV3CustomformatId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/customformat/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/customformat/:id`, async () => {
    const resultArray = [
      [await getGetApiV3CustomformatId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/customformat/bulk`, async () => {
    const resultArray = [
      [await getPutApiV3CustomformatBulk200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/customformat/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/customformat/schema`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/wanted/cutoff`, async () => {
    const resultArray = [
      [await getGetApiV3WantedCutoff200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/wanted/cutoff/:id`, async () => {
    const resultArray = [
      [await getGetApiV3WantedCutoffId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/delayprofile`, async () => {
    const resultArray = [
      [await getPostApiV3Delayprofile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/delayprofile`, async () => {
    const resultArray = [
      [await getGetApiV3Delayprofile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/delayprofile/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/delayprofile/:id`, async () => {
    const resultArray = [
      [await getPutApiV3DelayprofileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/delayprofile/:id`, async () => {
    const resultArray = [
      [await getGetApiV3DelayprofileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/delayprofile/reorder/:id`, async () => {
    const resultArray = [
      [await getPutApiV3DelayprofileReorderId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/diskspace`, async () => {
    const resultArray = [
      [await getGetApiV3Diskspace200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/downloadclient`, async () => {
    const resultArray = [
      [await getGetApiV3Downloadclient200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/downloadclient`, async () => {
    const resultArray = [
      [await getPostApiV3Downloadclient200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/downloadclient/:id`, async () => {
    const resultArray = [
      [await getPutApiV3DownloadclientId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/downloadclient/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/downloadclient/:id`, async () => {
    const resultArray = [
      [await getGetApiV3DownloadclientId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/downloadclient/bulk`, async () => {
    const resultArray = [
      [await getPutApiV3DownloadclientBulk200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/downloadclient/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/downloadclient/schema`, async () => {
    const resultArray = [
      [await getGetApiV3DownloadclientSchema200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/downloadclient/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/downloadclient/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/downloadclient/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/downloadclient`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigDownloadclient200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/config/downloadclient/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ConfigDownloadclientId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/downloadclient/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigDownloadclientId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/episode`, async () => {
    const resultArray = [
      [await getGetApiV3Episode200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/episode/:id`, async () => {
    const resultArray = [
      [await getPutApiV3EpisodeId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/episode/:id`, async () => {
    const resultArray = [
      [await getGetApiV3EpisodeId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/episode/monitor`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/episodefile`, async () => {
    const resultArray = [
      [await getGetApiV3Episodefile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/episodefile/:id`, async () => {
    const resultArray = [
      [await getPutApiV3EpisodefileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/episodefile/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/episodefile/:id`, async () => {
    const resultArray = [
      [await getGetApiV3EpisodefileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/episodefile/editor`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/episodefile/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/episodefile/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/filesystem`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/filesystem/type`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/filesystem/mediafiles`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/health`, async () => {
    const resultArray = [
      [await getGetApiV3Health200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/history`, async () => {
    const resultArray = [
      [await getGetApiV3History200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/history/since`, async () => {
    const resultArray = [
      [await getGetApiV3HistorySince200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/history/series`, async () => {
    const resultArray = [
      [await getGetApiV3HistorySeries200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/history/failed/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/host`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigHost200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/config/host/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ConfigHostId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/host/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigHostId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/importlist`, async () => {
    const resultArray = [
      [await getGetApiV3Importlist200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/importlist`, async () => {
    const resultArray = [
      [await getPostApiV3Importlist200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/importlist/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ImportlistId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/importlist/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/importlist/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ImportlistId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/importlist/bulk`, async () => {
    const resultArray = [
      [await getPutApiV3ImportlistBulk200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/importlist/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/importlist/schema`, async () => {
    const resultArray = [
      [await getGetApiV3ImportlistSchema200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/importlist/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/importlist/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/importlist/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/importlist`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigImportlist200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/config/importlist/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ConfigImportlistId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/importlist/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigImportlistId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/importlistexclusion`, async () => {
    const resultArray = [
      [await getGetApiV3Importlistexclusion200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/importlistexclusion`, async () => {
    const resultArray = [
      [await getPostApiV3Importlistexclusion200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/importlistexclusion/paged`, async () => {
    const resultArray = [
      [await getGetApiV3ImportlistexclusionPaged200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/importlistexclusion/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ImportlistexclusionId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/importlistexclusion/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/importlistexclusion/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ImportlistexclusionId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/importlistexclusion/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/indexer`, async () => {
    const resultArray = [
      [await getGetApiV3Indexer200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/indexer`, async () => {
    const resultArray = [
      [await getPostApiV3Indexer200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/indexer/:id`, async () => {
    const resultArray = [
      [await getPutApiV3IndexerId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/indexer/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/indexer/:id`, async () => {
    const resultArray = [
      [await getGetApiV3IndexerId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/indexer/bulk`, async () => {
    const resultArray = [
      [await getPutApiV3IndexerBulk200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/indexer/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/indexer/schema`, async () => {
    const resultArray = [
      [await getGetApiV3IndexerSchema200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/indexer/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/indexer/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/indexer/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/indexer`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigIndexer200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/config/indexer/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ConfigIndexerId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/indexer/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigIndexerId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/indexerflag`, async () => {
    const resultArray = [
      [await getGetApiV3Indexerflag200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/language`, async () => {
    const resultArray = [
      [await getGetApiV3Language200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/language/:id`, async () => {
    const resultArray = [
      [await getGetApiV3LanguageId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/languageprofile`, async () => {
    const resultArray = [
      [await getPostApiV3Languageprofile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/languageprofile`, async () => {
    const resultArray = [
      [await getGetApiV3Languageprofile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/languageprofile/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/languageprofile/:id`, async () => {
    const resultArray = [
      [await getPutApiV3LanguageprofileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/languageprofile/:id`, async () => {
    const resultArray = [
      [await getGetApiV3LanguageprofileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/languageprofile/schema`, async () => {
    const resultArray = [
      [await getGetApiV3LanguageprofileSchema200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/localization`, async () => {
    const resultArray = [
      [await getGetApiV3Localization200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/localization/language`, async () => {
    const resultArray = [
      [await getGetApiV3LocalizationLanguage200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/localization/:id`, async () => {
    const resultArray = [
      [await getGetApiV3LocalizationId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/log`, async () => {
    const resultArray = [[await getGetApiV3Log200Response(), { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/log/file`, async () => {
    const resultArray = [
      [await getGetApiV3LogFile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/log/file/:filename`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/manualimport`, async () => {
    const resultArray = [
      [await getGetApiV3Manualimport200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/manualimport`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/mediacover/:seriesId/:filename`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/mediamanagement`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigMediamanagement200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/config/mediamanagement/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ConfigMediamanagementId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/mediamanagement/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigMediamanagementId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/metadata`, async () => {
    const resultArray = [
      [await getGetApiV3Metadata200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/metadata`, async () => {
    const resultArray = [
      [await getPostApiV3Metadata200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/metadata/:id`, async () => {
    const resultArray = [
      [await getPutApiV3MetadataId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/metadata/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/metadata/:id`, async () => {
    const resultArray = [
      [await getGetApiV3MetadataId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/metadata/schema`, async () => {
    const resultArray = [
      [await getGetApiV3MetadataSchema200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/metadata/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/metadata/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/metadata/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/wanted/missing`, async () => {
    const resultArray = [
      [await getGetApiV3WantedMissing200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/wanted/missing/:id`, async () => {
    const resultArray = [
      [await getGetApiV3WantedMissingId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/naming`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigNaming200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/config/naming/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ConfigNamingId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/naming/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigNamingId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/naming/examples`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/notification`, async () => {
    const resultArray = [
      [await getGetApiV3Notification200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/notification`, async () => {
    const resultArray = [
      [await getPostApiV3Notification200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/notification/:id`, async () => {
    const resultArray = [
      [await getPutApiV3NotificationId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/notification/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/notification/:id`, async () => {
    const resultArray = [
      [await getGetApiV3NotificationId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/notification/schema`, async () => {
    const resultArray = [
      [await getGetApiV3NotificationSchema200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/notification/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/notification/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/notification/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/parse`, async () => {
    const resultArray = [[await getGetApiV3Parse200Response(), { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/ping`, async () => {
    const resultArray = [[await getGetPing200Response(), { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.head(`${baseURL}/ping`, async () => {
    const resultArray = [[await getHeadPing200Response(), { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/qualitydefinition/:id`, async () => {
    const resultArray = [
      [await getPutApiV3QualitydefinitionId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/qualitydefinition/:id`, async () => {
    const resultArray = [
      [await getGetApiV3QualitydefinitionId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/qualitydefinition`, async () => {
    const resultArray = [
      [await getGetApiV3Qualitydefinition200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/qualitydefinition/update`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/qualitydefinition/limits`, async () => {
    const resultArray = [
      [await getGetApiV3QualitydefinitionLimits200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/qualityprofile`, async () => {
    const resultArray = [
      [await getPostApiV3Qualityprofile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/qualityprofile`, async () => {
    const resultArray = [
      [await getGetApiV3Qualityprofile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/qualityprofile/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/qualityprofile/:id`, async () => {
    const resultArray = [
      [await getPutApiV3QualityprofileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/qualityprofile/:id`, async () => {
    const resultArray = [
      [await getGetApiV3QualityprofileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/qualityprofile/schema`, async () => {
    const resultArray = [
      [await getGetApiV3QualityprofileSchema200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/queue/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/queue/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/queue`, async () => {
    const resultArray = [[await getGetApiV3Queue200Response(), { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/queue/grab/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/queue/grab/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/queue/details`, async () => {
    const resultArray = [
      [await getGetApiV3QueueDetails200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/queue/status`, async () => {
    const resultArray = [
      [await getGetApiV3QueueStatus200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/release`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/release`, async () => {
    const resultArray = [
      [await getGetApiV3Release200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/releaseprofile`, async () => {
    const resultArray = [
      [await getPostApiV3Releaseprofile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/releaseprofile`, async () => {
    const resultArray = [
      [await getGetApiV3Releaseprofile200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/releaseprofile/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/releaseprofile/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ReleaseprofileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/releaseprofile/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ReleaseprofileId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/release/push`, async () => {
    const resultArray = [
      [await getPostApiV3ReleasePush200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/remotepathmapping`, async () => {
    const resultArray = [
      [await getPostApiV3Remotepathmapping200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/remotepathmapping`, async () => {
    const resultArray = [
      [await getGetApiV3Remotepathmapping200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/remotepathmapping/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/remotepathmapping/:id`, async () => {
    const resultArray = [
      [await getPutApiV3RemotepathmappingId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/remotepathmapping/:id`, async () => {
    const resultArray = [
      [await getGetApiV3RemotepathmappingId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/rename`, async () => {
    const resultArray = [
      [await getGetApiV3Rename200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/rootfolder`, async () => {
    const resultArray = [
      [await getPostApiV3Rootfolder200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/rootfolder`, async () => {
    const resultArray = [
      [await getGetApiV3Rootfolder200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/rootfolder/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/rootfolder/:id`, async () => {
    const resultArray = [
      [await getGetApiV3RootfolderId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/seasonpass`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/series`, async () => {
    const resultArray = [
      [await getGetApiV3Series200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/series`, async () => {
    const resultArray = [
      [await getPostApiV3Series200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/series/:id`, async () => {
    const resultArray = [
      [await getGetApiV3SeriesId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/series/:id`, async () => {
    const resultArray = [
      [await getPutApiV3SeriesId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/series/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/series/editor`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/series/editor`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/series/:id/folder`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/series/import`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/series/lookup`, async () => {
    const resultArray = [
      [await getGetApiV3SeriesLookup200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/content/:path`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/:path`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/system/status`, async () => {
    const resultArray = [
      [await getGetApiV3SystemStatus200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/system/routes`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/system/routes/duplicate`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/system/shutdown`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/system/restart`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/tag`, async () => {
    const resultArray = [[await getGetApiV3Tag200Response(), { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.post(`${baseURL}/api/v3/tag`, async () => {
    const resultArray = [[await getPostApiV3Tag200Response(), { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/tag/:id`, async () => {
    const resultArray = [[await getPutApiV3TagId200Response(), { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.delete(`${baseURL}/api/v3/tag/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/tag/:id`, async () => {
    const resultArray = [[await getGetApiV3TagId200Response(), { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/tag/detail`, async () => {
    const resultArray = [
      [await getGetApiV3TagDetail200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/tag/detail/:id`, async () => {
    const resultArray = [
      [await getGetApiV3TagDetailId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/system/task`, async () => {
    const resultArray = [
      [await getGetApiV3SystemTask200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/system/task/:id`, async () => {
    const resultArray = [
      [await getGetApiV3SystemTaskId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.put(`${baseURL}/api/v3/config/ui/:id`, async () => {
    const resultArray = [
      [await getPutApiV3ConfigUiId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/ui/:id`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigUiId200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/config/ui`, async () => {
    const resultArray = [
      [await getGetApiV3ConfigUi200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/update`, async () => {
    const resultArray = [
      [await getGetApiV3Update200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/log/file/update`, async () => {
    const resultArray = [
      [await getGetApiV3LogFileUpdate200Response(), { status: 200 }],
    ]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
  http.get(`${baseURL}/api/v3/log/file/update/:filename`, async () => {
    const resultArray = [[undefined, { status: 200 }]]

    return HttpResponse.json(...resultArray[next() % resultArray.length])
  }),
]

export function getPostApiV3Autotagging200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    removeTagsAutomatically: faker.datatype.boolean(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
    })),
  }
}

export function getGetApiV3Autotagging200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    removeTagsAutomatically: faker.datatype.boolean(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
    })),
  }))
}

export function getPutApiV3AutotaggingId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    removeTagsAutomatically: faker.datatype.boolean(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
    })),
  }
}

export function getGetApiV3AutotaggingId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    removeTagsAutomatically: faker.datatype.boolean(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
    })),
  }
}

export function getGetApiV3SystemBackup200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    path: faker.lorem.words(),
    type: faker.helpers.arrayElement(['scheduled', 'manual', 'update']),
    size: faker.number.int(),
    time: faker.date.past(),
  }))
}

export function getGetApiV3Blocklist200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      seriesId: faker.number.int(),
      episodeIds: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      sourceTitle: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      date: faker.date.past(),
      protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
      indexer: faker.lorem.words(),
      message: faker.lorem.words(),
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
    })),
  }
}

export function getGetApiV3Calendar200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    seriesId: faker.number.int(),
    tvdbId: faker.number.int(),
    episodeFileId: faker.number.int(),
    seasonNumber: faker.number.int(),
    episodeNumber: faker.number.int(),
    title: faker.lorem.words(),
    airDate: faker.lorem.words(),
    airDateUtc: faker.date.past(),
    lastSearchTime: faker.date.past(),
    runtime: faker.number.int(),
    finaleType: faker.lorem.words(),
    overview: faker.lorem.words(),
    episodeFile: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      seasonNumber: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      releaseType: faker.helpers.arrayElement([
        'unknown',
        'singleEpisode',
        'multiEpisode',
        'seasonPack',
      ]),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    hasFile: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    absoluteEpisodeNumber: faker.number.int(),
    sceneAbsoluteEpisodeNumber: faker.number.int(),
    sceneEpisodeNumber: faker.number.int(),
    sceneSeasonNumber: faker.number.int(),
    unverifiedSceneNumbering: faker.datatype.boolean(),
    endTime: faker.date.past(),
    grabDate: faker.date.past(),
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
  }))
}

export function getGetApiV3CalendarId200Response() {
  return {
    id: faker.number.int(),
    seriesId: faker.number.int(),
    tvdbId: faker.number.int(),
    episodeFileId: faker.number.int(),
    seasonNumber: faker.number.int(),
    episodeNumber: faker.number.int(),
    title: faker.lorem.words(),
    airDate: faker.lorem.words(),
    airDateUtc: faker.date.past(),
    lastSearchTime: faker.date.past(),
    runtime: faker.number.int(),
    finaleType: faker.lorem.words(),
    overview: faker.lorem.words(),
    episodeFile: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      seasonNumber: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      releaseType: faker.helpers.arrayElement([
        'unknown',
        'singleEpisode',
        'multiEpisode',
        'seasonPack',
      ]),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    hasFile: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    absoluteEpisodeNumber: faker.number.int(),
    sceneAbsoluteEpisodeNumber: faker.number.int(),
    sceneEpisodeNumber: faker.number.int(),
    sceneSeasonNumber: faker.number.int(),
    unverifiedSceneNumbering: faker.datatype.boolean(),
    endTime: faker.date.past(),
    grabDate: faker.date.past(),
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
  }
}

export function getPostApiV3Command200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    commandName: faker.person.fullName(),
    message: faker.lorem.words(),
    body: {
      sendUpdatesToClient: faker.datatype.boolean(),
      updateScheduledTask: faker.datatype.boolean(),
      completionMessage: faker.lorem.words(),
      requiresDiskAccess: faker.datatype.boolean(),
      isExclusive: faker.datatype.boolean(),
      isLongRunning: faker.datatype.boolean(),
      name: faker.person.fullName(),
      lastExecutionTime: faker.date.past(),
      lastStartTime: faker.date.past(),
      trigger: faker.helpers.arrayElement([
        'unspecified',
        'manual',
        'scheduled',
      ]),
      suppressMessages: faker.datatype.boolean(),
      clientUserAgent: faker.lorem.words(),
    },
    priority: faker.helpers.arrayElement(['normal', 'high', 'low']),
    status: faker.helpers.arrayElement([
      'queued',
      'started',
      'completed',
      'failed',
      'aborted',
      'cancelled',
      'orphaned',
    ]),
    result: faker.helpers.arrayElement([
      'unknown',
      'successful',
      'unsuccessful',
    ]),
    queued: faker.date.past(),
    started: faker.date.past(),
    ended: faker.date.past(),
    duration: faker.lorem.words(),
    exception: faker.lorem.words(),
    trigger: faker.helpers.arrayElement(['unspecified', 'manual', 'scheduled']),
    clientUserAgent: faker.lorem.words(),
    stateChangeTime: faker.date.past(),
    sendUpdatesToClient: faker.datatype.boolean(),
    updateScheduledTask: faker.datatype.boolean(),
    lastExecutionTime: faker.date.past(),
  }
}

export function getGetApiV3Command200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    commandName: faker.person.fullName(),
    message: faker.lorem.words(),
    body: {
      sendUpdatesToClient: faker.datatype.boolean(),
      updateScheduledTask: faker.datatype.boolean(),
      completionMessage: faker.lorem.words(),
      requiresDiskAccess: faker.datatype.boolean(),
      isExclusive: faker.datatype.boolean(),
      isLongRunning: faker.datatype.boolean(),
      name: faker.person.fullName(),
      lastExecutionTime: faker.date.past(),
      lastStartTime: faker.date.past(),
      trigger: faker.helpers.arrayElement([
        'unspecified',
        'manual',
        'scheduled',
      ]),
      suppressMessages: faker.datatype.boolean(),
      clientUserAgent: faker.lorem.words(),
    },
    priority: faker.helpers.arrayElement(['normal', 'high', 'low']),
    status: faker.helpers.arrayElement([
      'queued',
      'started',
      'completed',
      'failed',
      'aborted',
      'cancelled',
      'orphaned',
    ]),
    result: faker.helpers.arrayElement([
      'unknown',
      'successful',
      'unsuccessful',
    ]),
    queued: faker.date.past(),
    started: faker.date.past(),
    ended: faker.date.past(),
    duration: faker.lorem.words(),
    exception: faker.lorem.words(),
    trigger: faker.helpers.arrayElement(['unspecified', 'manual', 'scheduled']),
    clientUserAgent: faker.lorem.words(),
    stateChangeTime: faker.date.past(),
    sendUpdatesToClient: faker.datatype.boolean(),
    updateScheduledTask: faker.datatype.boolean(),
    lastExecutionTime: faker.date.past(),
  }))
}

export function getGetApiV3CommandId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    commandName: faker.person.fullName(),
    message: faker.lorem.words(),
    body: {
      sendUpdatesToClient: faker.datatype.boolean(),
      updateScheduledTask: faker.datatype.boolean(),
      completionMessage: faker.lorem.words(),
      requiresDiskAccess: faker.datatype.boolean(),
      isExclusive: faker.datatype.boolean(),
      isLongRunning: faker.datatype.boolean(),
      name: faker.person.fullName(),
      lastExecutionTime: faker.date.past(),
      lastStartTime: faker.date.past(),
      trigger: faker.helpers.arrayElement([
        'unspecified',
        'manual',
        'scheduled',
      ]),
      suppressMessages: faker.datatype.boolean(),
      clientUserAgent: faker.lorem.words(),
    },
    priority: faker.helpers.arrayElement(['normal', 'high', 'low']),
    status: faker.helpers.arrayElement([
      'queued',
      'started',
      'completed',
      'failed',
      'aborted',
      'cancelled',
      'orphaned',
    ]),
    result: faker.helpers.arrayElement([
      'unknown',
      'successful',
      'unsuccessful',
    ]),
    queued: faker.date.past(),
    started: faker.date.past(),
    ended: faker.date.past(),
    duration: faker.lorem.words(),
    exception: faker.lorem.words(),
    trigger: faker.helpers.arrayElement(['unspecified', 'manual', 'scheduled']),
    clientUserAgent: faker.lorem.words(),
    stateChangeTime: faker.date.past(),
    sendUpdatesToClient: faker.datatype.boolean(),
    updateScheduledTask: faker.datatype.boolean(),
    lastExecutionTime: faker.date.past(),
  }
}

export function getGetApiV3Customfilter200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    type: faker.lorem.words(),
    label: faker.lorem.words(),
    filters: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    ),
  }))
}

export function getPostApiV3Customfilter200Response() {
  return {
    id: faker.number.int(),
    type: faker.lorem.words(),
    label: faker.lorem.words(),
    filters: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    ),
  }
}

export function getPutApiV3CustomfilterId200Response() {
  return {
    id: faker.number.int(),
    type: faker.lorem.words(),
    label: faker.lorem.words(),
    filters: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    ),
  }
}

export function getGetApiV3CustomfilterId200Response() {
  return {
    id: faker.number.int(),
    type: faker.lorem.words(),
    label: faker.lorem.words(),
    filters: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    ),
  }
}

export function getGetApiV3Customformat200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }))
}

export function getPostApiV3Customformat200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }
}

export function getPutApiV3CustomformatId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }
}

export function getGetApiV3CustomformatId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }
}

export function getPutApiV3CustomformatBulk200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }
}

export function getGetApiV3WantedCutoff200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      seriesId: faker.number.int(),
      tvdbId: faker.number.int(),
      episodeFileId: faker.number.int(),
      seasonNumber: faker.number.int(),
      episodeNumber: faker.number.int(),
      title: faker.lorem.words(),
      airDate: faker.lorem.words(),
      airDateUtc: faker.date.past(),
      lastSearchTime: faker.date.past(),
      runtime: faker.number.int(),
      finaleType: faker.lorem.words(),
      overview: faker.lorem.words(),
      episodeFile: {
        id: faker.number.int(),
        seriesId: faker.number.int(),
        seasonNumber: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'television',
              'televisionRaw',
              'web',
              'webRip',
              'dvd',
              'bluray',
              'blurayRaw',
            ]),
            resolution: faker.number.int(),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        releaseType: faker.helpers.arrayElement([
          'unknown',
          'singleEpisode',
          'multiEpisode',
          'seasonPack',
        ]),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      hasFile: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      absoluteEpisodeNumber: faker.number.int(),
      sceneAbsoluteEpisodeNumber: faker.number.int(),
      sceneEpisodeNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      unverifiedSceneNumbering: faker.datatype.boolean(),
      endTime: faker.date.past(),
      grabDate: faker.date.past(),
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    })),
  }
}

export function getGetApiV3WantedCutoffId200Response() {
  return {
    id: faker.number.int(),
    seriesId: faker.number.int(),
    tvdbId: faker.number.int(),
    episodeFileId: faker.number.int(),
    seasonNumber: faker.number.int(),
    episodeNumber: faker.number.int(),
    title: faker.lorem.words(),
    airDate: faker.lorem.words(),
    airDateUtc: faker.date.past(),
    lastSearchTime: faker.date.past(),
    runtime: faker.number.int(),
    finaleType: faker.lorem.words(),
    overview: faker.lorem.words(),
    episodeFile: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      seasonNumber: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      releaseType: faker.helpers.arrayElement([
        'unknown',
        'singleEpisode',
        'multiEpisode',
        'seasonPack',
      ]),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    hasFile: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    absoluteEpisodeNumber: faker.number.int(),
    sceneAbsoluteEpisodeNumber: faker.number.int(),
    sceneEpisodeNumber: faker.number.int(),
    sceneSeasonNumber: faker.number.int(),
    unverifiedSceneNumbering: faker.datatype.boolean(),
    endTime: faker.date.past(),
    grabDate: faker.date.past(),
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
  }
}

export function getPostApiV3Delayprofile200Response() {
  return {
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3Delayprofile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }))
}

export function getPutApiV3DelayprofileId200Response() {
  return {
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3DelayprofileId200Response() {
  return {
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getPutApiV3DelayprofileReorderId200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }))
}

export function getGetApiV3Diskspace200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    path: faker.lorem.words(),
    label: faker.lorem.words(),
    freeSpace: faker.number.int(),
    totalSpace: faker.number.int(),
  }))
}

export function getGetApiV3Downloadclient200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }))
}

export function getPostApiV3Downloadclient200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }
}

export function getPutApiV3DownloadclientId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }
}

export function getGetApiV3DownloadclientId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }
}

export function getPutApiV3DownloadclientBulk200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }
}

export function getGetApiV3DownloadclientSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }))
}

export function getGetApiV3ConfigDownloadclient200Response() {
  return {
    id: faker.number.int(),
    downloadClientWorkingFolders: faker.lorem.words(),
    enableCompletedDownloadHandling: faker.datatype.boolean(),
    autoRedownloadFailed: faker.datatype.boolean(),
    autoRedownloadFailedFromInteractiveSearch: faker.datatype.boolean(),
  }
}

export function getPutApiV3ConfigDownloadclientId200Response() {
  return {
    id: faker.number.int(),
    downloadClientWorkingFolders: faker.lorem.words(),
    enableCompletedDownloadHandling: faker.datatype.boolean(),
    autoRedownloadFailed: faker.datatype.boolean(),
    autoRedownloadFailedFromInteractiveSearch: faker.datatype.boolean(),
  }
}

export function getGetApiV3ConfigDownloadclientId200Response() {
  return {
    id: faker.number.int(),
    downloadClientWorkingFolders: faker.lorem.words(),
    enableCompletedDownloadHandling: faker.datatype.boolean(),
    autoRedownloadFailed: faker.datatype.boolean(),
    autoRedownloadFailedFromInteractiveSearch: faker.datatype.boolean(),
  }
}

export function getGetApiV3Episode200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    seriesId: faker.number.int(),
    tvdbId: faker.number.int(),
    episodeFileId: faker.number.int(),
    seasonNumber: faker.number.int(),
    episodeNumber: faker.number.int(),
    title: faker.lorem.words(),
    airDate: faker.lorem.words(),
    airDateUtc: faker.date.past(),
    lastSearchTime: faker.date.past(),
    runtime: faker.number.int(),
    finaleType: faker.lorem.words(),
    overview: faker.lorem.words(),
    episodeFile: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      seasonNumber: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      releaseType: faker.helpers.arrayElement([
        'unknown',
        'singleEpisode',
        'multiEpisode',
        'seasonPack',
      ]),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    hasFile: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    absoluteEpisodeNumber: faker.number.int(),
    sceneAbsoluteEpisodeNumber: faker.number.int(),
    sceneEpisodeNumber: faker.number.int(),
    sceneSeasonNumber: faker.number.int(),
    unverifiedSceneNumbering: faker.datatype.boolean(),
    endTime: faker.date.past(),
    grabDate: faker.date.past(),
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
  }))
}

export function getPutApiV3EpisodeId200Response() {
  return {
    id: faker.number.int(),
    seriesId: faker.number.int(),
    tvdbId: faker.number.int(),
    episodeFileId: faker.number.int(),
    seasonNumber: faker.number.int(),
    episodeNumber: faker.number.int(),
    title: faker.lorem.words(),
    airDate: faker.lorem.words(),
    airDateUtc: faker.date.past(),
    lastSearchTime: faker.date.past(),
    runtime: faker.number.int(),
    finaleType: faker.lorem.words(),
    overview: faker.lorem.words(),
    episodeFile: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      seasonNumber: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      releaseType: faker.helpers.arrayElement([
        'unknown',
        'singleEpisode',
        'multiEpisode',
        'seasonPack',
      ]),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    hasFile: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    absoluteEpisodeNumber: faker.number.int(),
    sceneAbsoluteEpisodeNumber: faker.number.int(),
    sceneEpisodeNumber: faker.number.int(),
    sceneSeasonNumber: faker.number.int(),
    unverifiedSceneNumbering: faker.datatype.boolean(),
    endTime: faker.date.past(),
    grabDate: faker.date.past(),
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
  }
}

export function getGetApiV3EpisodeId200Response() {
  return {
    id: faker.number.int(),
    seriesId: faker.number.int(),
    tvdbId: faker.number.int(),
    episodeFileId: faker.number.int(),
    seasonNumber: faker.number.int(),
    episodeNumber: faker.number.int(),
    title: faker.lorem.words(),
    airDate: faker.lorem.words(),
    airDateUtc: faker.date.past(),
    lastSearchTime: faker.date.past(),
    runtime: faker.number.int(),
    finaleType: faker.lorem.words(),
    overview: faker.lorem.words(),
    episodeFile: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      seasonNumber: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      releaseType: faker.helpers.arrayElement([
        'unknown',
        'singleEpisode',
        'multiEpisode',
        'seasonPack',
      ]),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    hasFile: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    absoluteEpisodeNumber: faker.number.int(),
    sceneAbsoluteEpisodeNumber: faker.number.int(),
    sceneEpisodeNumber: faker.number.int(),
    sceneSeasonNumber: faker.number.int(),
    unverifiedSceneNumbering: faker.datatype.boolean(),
    endTime: faker.date.past(),
    grabDate: faker.date.past(),
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
  }
}

export function getGetApiV3Episodefile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    seriesId: faker.number.int(),
    seasonNumber: faker.number.int(),
    relativePath: faker.lorem.words(),
    path: faker.lorem.words(),
    size: faker.number.int(),
    dateAdded: faker.date.past(),
    sceneName: faker.person.fullName(),
    releaseGroup: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    indexerFlags: faker.number.int(),
    releaseType: faker.helpers.arrayElement([
      'unknown',
      'singleEpisode',
      'multiEpisode',
      'seasonPack',
    ]),
    mediaInfo: {
      id: faker.number.int(),
      audioBitrate: faker.number.int(),
      audioChannels: faker.number.int(),
      audioCodec: faker.lorem.words(),
      audioLanguages: faker.lorem.words(),
      audioStreamCount: faker.number.int(),
      videoBitDepth: faker.number.int(),
      videoBitrate: faker.number.int(),
      videoCodec: faker.lorem.words(),
      videoFps: faker.number.int(),
      videoDynamicRange: faker.lorem.words(),
      videoDynamicRangeType: faker.lorem.words(),
      resolution: faker.lorem.words(),
      runTime: faker.lorem.words(),
      scanType: faker.lorem.words(),
      subtitles: faker.lorem.words(),
    },
    qualityCutoffNotMet: faker.datatype.boolean(),
  }))
}

export function getPutApiV3EpisodefileId200Response() {
  return {
    id: faker.number.int(),
    seriesId: faker.number.int(),
    seasonNumber: faker.number.int(),
    relativePath: faker.lorem.words(),
    path: faker.lorem.words(),
    size: faker.number.int(),
    dateAdded: faker.date.past(),
    sceneName: faker.person.fullName(),
    releaseGroup: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    indexerFlags: faker.number.int(),
    releaseType: faker.helpers.arrayElement([
      'unknown',
      'singleEpisode',
      'multiEpisode',
      'seasonPack',
    ]),
    mediaInfo: {
      id: faker.number.int(),
      audioBitrate: faker.number.int(),
      audioChannels: faker.number.int(),
      audioCodec: faker.lorem.words(),
      audioLanguages: faker.lorem.words(),
      audioStreamCount: faker.number.int(),
      videoBitDepth: faker.number.int(),
      videoBitrate: faker.number.int(),
      videoCodec: faker.lorem.words(),
      videoFps: faker.number.int(),
      videoDynamicRange: faker.lorem.words(),
      videoDynamicRangeType: faker.lorem.words(),
      resolution: faker.lorem.words(),
      runTime: faker.lorem.words(),
      scanType: faker.lorem.words(),
      subtitles: faker.lorem.words(),
    },
    qualityCutoffNotMet: faker.datatype.boolean(),
  }
}

export function getGetApiV3EpisodefileId200Response() {
  return {
    id: faker.number.int(),
    seriesId: faker.number.int(),
    seasonNumber: faker.number.int(),
    relativePath: faker.lorem.words(),
    path: faker.lorem.words(),
    size: faker.number.int(),
    dateAdded: faker.date.past(),
    sceneName: faker.person.fullName(),
    releaseGroup: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    indexerFlags: faker.number.int(),
    releaseType: faker.helpers.arrayElement([
      'unknown',
      'singleEpisode',
      'multiEpisode',
      'seasonPack',
    ]),
    mediaInfo: {
      id: faker.number.int(),
      audioBitrate: faker.number.int(),
      audioChannels: faker.number.int(),
      audioCodec: faker.lorem.words(),
      audioLanguages: faker.lorem.words(),
      audioStreamCount: faker.number.int(),
      videoBitDepth: faker.number.int(),
      videoBitrate: faker.number.int(),
      videoCodec: faker.lorem.words(),
      videoFps: faker.number.int(),
      videoDynamicRange: faker.lorem.words(),
      videoDynamicRangeType: faker.lorem.words(),
      resolution: faker.lorem.words(),
      runTime: faker.lorem.words(),
      scanType: faker.lorem.words(),
      subtitles: faker.lorem.words(),
    },
    qualityCutoffNotMet: faker.datatype.boolean(),
  }
}

export function getGetApiV3Health200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    source: faker.lorem.words(),
    type: faker.helpers.arrayElement(['ok', 'notice', 'warning', 'error']),
    message: faker.lorem.words(),
    wikiUrl: {
      fullUri: faker.lorem.words(),
      scheme: faker.lorem.words(),
      host: faker.lorem.words(),
      port: faker.number.int(),
      path: faker.lorem.words(),
      query: faker.lorem.words(),
      fragment: faker.lorem.words(),
    },
  }))
}

export function getGetApiV3History200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      episodeId: faker.number.int(),
      seriesId: faker.number.int(),
      sourceTitle: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      qualityCutoffNotMet: faker.datatype.boolean(),
      date: faker.date.past(),
      downloadId: faker.string.uuid(),
      eventType: faker.helpers.arrayElement([
        'unknown',
        'grabbed',
        'seriesFolderImported',
        'downloadFolderImported',
        'downloadFailed',
        'episodeFileDeleted',
        'episodeFileRenamed',
        'downloadIgnored',
      ]),
      data: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: faker.lorem.words() }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      episode: {
        id: faker.number.int(),
        seriesId: faker.number.int(),
        tvdbId: faker.number.int(),
        episodeFileId: faker.number.int(),
        seasonNumber: faker.number.int(),
        episodeNumber: faker.number.int(),
        title: faker.lorem.words(),
        airDate: faker.lorem.words(),
        airDateUtc: faker.date.past(),
        lastSearchTime: faker.date.past(),
        runtime: faker.number.int(),
        finaleType: faker.lorem.words(),
        overview: faker.lorem.words(),
        episodeFile: {
          id: faker.number.int(),
          seriesId: faker.number.int(),
          seasonNumber: faker.number.int(),
          relativePath: faker.lorem.words(),
          path: faker.lorem.words(),
          size: faker.number.int(),
          dateAdded: faker.date.past(),
          sceneName: faker.person.fullName(),
          releaseGroup: faker.lorem.words(),
          languages: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
          })),
          quality: {
            quality: {
              id: faker.number.int(),
              name: faker.person.fullName(),
              source: faker.helpers.arrayElement([
                'unknown',
                'television',
                'televisionRaw',
                'web',
                'webRip',
                'dvd',
                'bluray',
                'blurayRaw',
              ]),
              resolution: faker.number.int(),
            },
            revision: {
              version: faker.number.int(),
              real: faker.number.int(),
              isRepack: faker.datatype.boolean(),
            },
          },
          customFormats: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            includeCustomFormatWhenRenaming: faker.datatype.boolean(),
            specifications: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              id: faker.number.int(),
              name: faker.person.fullName(),
              implementation: faker.lorem.words(),
              implementationName: faker.person.fullName(),
              infoLink: faker.lorem.words(),
              negate: faker.datatype.boolean(),
              required: faker.datatype.boolean(),
              fields: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                order: faker.number.int(),
                name: faker.person.fullName(),
                label: faker.lorem.words(),
                unit: faker.lorem.words(),
                helpText: faker.lorem.words(),
                helpTextWarning: faker.lorem.words(),
                helpLink: faker.lorem.words(),
                value: null,
                type: faker.lorem.words(),
                advanced: faker.datatype.boolean(),
                selectOptions: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => ({
                  value: faker.number.int(),
                  name: faker.person.fullName(),
                  order: faker.number.int(),
                  hint: faker.lorem.words(),
                })),
                selectOptionsProviderAction: faker.lorem.words(),
                section: faker.lorem.words(),
                hidden: faker.lorem.words(),
                privacy: faker.helpers.arrayElement([
                  'normal',
                  'password',
                  'apiKey',
                  'userName',
                ]),
                placeholder: faker.lorem.words(),
                isFloat: faker.datatype.boolean(),
              })),
              presets: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => null),
            })),
          })),
          customFormatScore: faker.number.int(),
          indexerFlags: faker.number.int(),
          releaseType: faker.helpers.arrayElement([
            'unknown',
            'singleEpisode',
            'multiEpisode',
            'seasonPack',
          ]),
          mediaInfo: {
            id: faker.number.int(),
            audioBitrate: faker.number.int(),
            audioChannels: faker.number.int(),
            audioCodec: faker.lorem.words(),
            audioLanguages: faker.lorem.words(),
            audioStreamCount: faker.number.int(),
            videoBitDepth: faker.number.int(),
            videoBitrate: faker.number.int(),
            videoCodec: faker.lorem.words(),
            videoFps: faker.number.int(),
            videoDynamicRange: faker.lorem.words(),
            videoDynamicRangeType: faker.lorem.words(),
            resolution: faker.lorem.words(),
            runTime: faker.lorem.words(),
            scanType: faker.lorem.words(),
            subtitles: faker.lorem.words(),
          },
          qualityCutoffNotMet: faker.datatype.boolean(),
        },
        hasFile: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        absoluteEpisodeNumber: faker.number.int(),
        sceneAbsoluteEpisodeNumber: faker.number.int(),
        sceneEpisodeNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        unverifiedSceneNumbering: faker.datatype.boolean(),
        endTime: faker.date.past(),
        grabDate: faker.date.past(),
        series: {
          id: faker.number.int(),
          title: faker.lorem.words(),
          alternateTitles: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            title: faker.lorem.words(),
            seasonNumber: faker.number.int(),
            sceneSeasonNumber: faker.number.int(),
            sceneOrigin: faker.lorem.words(),
            comment: faker.lorem.words(),
          })),
          sortTitle: faker.lorem.words(),
          status: faker.helpers.arrayElement([
            'continuing',
            'ended',
            'upcoming',
            'deleted',
          ]),
          ended: faker.datatype.boolean(),
          profileName: faker.person.fullName(),
          overview: faker.lorem.words(),
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          network: faker.lorem.words(),
          airTime: faker.lorem.words(),
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
          originalLanguage: {
            id: faker.number.int(),
            name: faker.person.fullName(),
          },
          remotePoster: faker.lorem.words(),
          seasons: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            seasonNumber: faker.number.int(),
            monitored: faker.datatype.boolean(),
            statistics: {
              nextAiring: faker.date.past(),
              previousAiring: faker.date.past(),
              episodeFileCount: faker.number.int(),
              episodeCount: faker.number.int(),
              totalEpisodeCount: faker.number.int(),
              sizeOnDisk: faker.number.int(),
              releaseGroups: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => faker.lorem.words()),
              percentOfEpisodes: faker.number.int(),
            },
            images: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              coverType: faker.helpers.arrayElement([
                'unknown',
                'poster',
                'banner',
                'fanart',
                'screenshot',
                'headshot',
                'clearlogo',
              ]),
              url: faker.internet.url(),
              remoteUrl: faker.internet.url(),
            })),
          })),
          year: faker.number.int(),
          path: faker.lorem.words(),
          qualityProfileId: faker.number.int(),
          seasonFolder: faker.datatype.boolean(),
          monitored: faker.datatype.boolean(),
          monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
          useSceneNumbering: faker.datatype.boolean(),
          runtime: faker.number.int(),
          tvdbId: faker.number.int(),
          tvRageId: faker.number.int(),
          tvMazeId: faker.number.int(),
          tmdbId: faker.number.int(),
          firstAired: faker.date.past(),
          lastAired: faker.date.past(),
          seriesType: faker.helpers.arrayElement([
            'standard',
            'daily',
            'anime',
          ]),
          cleanTitle: faker.lorem.words(),
          imdbId: faker.string.uuid(),
          titleSlug: faker.lorem.words(),
          rootFolderPath: faker.lorem.words(),
          folder: faker.lorem.words(),
          certification: faker.lorem.words(),
          genres: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          tags: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.number.int()),
          added: faker.date.past(),
          addOptions: {
            ignoreEpisodesWithFiles: faker.datatype.boolean(),
            ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
            monitor: faker.helpers.arrayElement([
              'unknown',
              'all',
              'future',
              'missing',
              'existing',
              'firstSeason',
              'lastSeason',
              'latestSeason',
              'pilot',
              'recent',
              'monitorSpecials',
              'unmonitorSpecials',
              'none',
              'skip',
            ]),
            searchForMissingEpisodes: faker.datatype.boolean(),
            searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
          },
          ratings: {
            votes: faker.number.int(),
            value: faker.number.int(),
          },
          statistics: {
            seasonCount: faker.number.int(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          episodesChanged: faker.datatype.boolean(),
          languageProfileId: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      },
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
    })),
  }
}

export function getGetApiV3HistorySince200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    episodeId: faker.number.int(),
    seriesId: faker.number.int(),
    sourceTitle: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    qualityCutoffNotMet: faker.datatype.boolean(),
    date: faker.date.past(),
    downloadId: faker.string.uuid(),
    eventType: faker.helpers.arrayElement([
      'unknown',
      'grabbed',
      'seriesFolderImported',
      'downloadFolderImported',
      'downloadFailed',
      'episodeFileDeleted',
      'episodeFileRenamed',
      'downloadIgnored',
    ]),
    data: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: faker.lorem.words() }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    episode: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      tvdbId: faker.number.int(),
      episodeFileId: faker.number.int(),
      seasonNumber: faker.number.int(),
      episodeNumber: faker.number.int(),
      title: faker.lorem.words(),
      airDate: faker.lorem.words(),
      airDateUtc: faker.date.past(),
      lastSearchTime: faker.date.past(),
      runtime: faker.number.int(),
      finaleType: faker.lorem.words(),
      overview: faker.lorem.words(),
      episodeFile: {
        id: faker.number.int(),
        seriesId: faker.number.int(),
        seasonNumber: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'television',
              'televisionRaw',
              'web',
              'webRip',
              'dvd',
              'bluray',
              'blurayRaw',
            ]),
            resolution: faker.number.int(),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        releaseType: faker.helpers.arrayElement([
          'unknown',
          'singleEpisode',
          'multiEpisode',
          'seasonPack',
        ]),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      hasFile: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      absoluteEpisodeNumber: faker.number.int(),
      sceneAbsoluteEpisodeNumber: faker.number.int(),
      sceneEpisodeNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      unverifiedSceneNumbering: faker.datatype.boolean(),
      endTime: faker.date.past(),
      grabDate: faker.date.past(),
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    },
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
  }))
}

export function getGetApiV3HistorySeries200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    episodeId: faker.number.int(),
    seriesId: faker.number.int(),
    sourceTitle: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    qualityCutoffNotMet: faker.datatype.boolean(),
    date: faker.date.past(),
    downloadId: faker.string.uuid(),
    eventType: faker.helpers.arrayElement([
      'unknown',
      'grabbed',
      'seriesFolderImported',
      'downloadFolderImported',
      'downloadFailed',
      'episodeFileDeleted',
      'episodeFileRenamed',
      'downloadIgnored',
    ]),
    data: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: faker.lorem.words() }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    episode: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      tvdbId: faker.number.int(),
      episodeFileId: faker.number.int(),
      seasonNumber: faker.number.int(),
      episodeNumber: faker.number.int(),
      title: faker.lorem.words(),
      airDate: faker.lorem.words(),
      airDateUtc: faker.date.past(),
      lastSearchTime: faker.date.past(),
      runtime: faker.number.int(),
      finaleType: faker.lorem.words(),
      overview: faker.lorem.words(),
      episodeFile: {
        id: faker.number.int(),
        seriesId: faker.number.int(),
        seasonNumber: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'television',
              'televisionRaw',
              'web',
              'webRip',
              'dvd',
              'bluray',
              'blurayRaw',
            ]),
            resolution: faker.number.int(),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        releaseType: faker.helpers.arrayElement([
          'unknown',
          'singleEpisode',
          'multiEpisode',
          'seasonPack',
        ]),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      hasFile: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      absoluteEpisodeNumber: faker.number.int(),
      sceneAbsoluteEpisodeNumber: faker.number.int(),
      sceneEpisodeNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      unverifiedSceneNumbering: faker.datatype.boolean(),
      endTime: faker.date.past(),
      grabDate: faker.date.past(),
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    },
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
  }))
}

export function getGetApiV3ConfigHost200Response() {
  return {
    id: faker.number.int(),
    bindAddress: faker.lorem.words(),
    port: faker.number.int(),
    sslPort: faker.number.int(),
    enableSsl: faker.datatype.boolean(),
    launchBrowser: faker.datatype.boolean(),
    authenticationMethod: faker.helpers.arrayElement([
      'none',
      'basic',
      'forms',
      'external',
    ]),
    authenticationRequired: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
    ]),
    analyticsEnabled: faker.datatype.boolean(),
    username: faker.person.fullName(),
    password: faker.lorem.words(),
    passwordConfirmation: faker.lorem.words(),
    logLevel: faker.lorem.words(),
    logSizeLimit: faker.number.int(),
    consoleLogLevel: faker.lorem.words(),
    branch: faker.lorem.words(),
    apiKey: faker.lorem.words(),
    sslCertPath: faker.lorem.words(),
    sslCertPassword: faker.lorem.words(),
    urlBase: faker.internet.url(),
    instanceName: faker.person.fullName(),
    applicationUrl: faker.internet.url(),
    updateAutomatically: faker.datatype.boolean(),
    updateMechanism: faker.helpers.arrayElement([
      'builtIn',
      'script',
      'external',
      'apt',
      'docker',
    ]),
    updateScriptPath: faker.lorem.words(),
    proxyEnabled: faker.datatype.boolean(),
    proxyType: faker.helpers.arrayElement(['http', 'socks4', 'socks5']),
    proxyHostname: faker.person.fullName(),
    proxyPort: faker.number.int(),
    proxyUsername: faker.person.fullName(),
    proxyPassword: faker.lorem.words(),
    proxyBypassFilter: faker.lorem.words(),
    proxyBypassLocalAddresses: faker.datatype.boolean(),
    certificateValidation: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
      'disabled',
    ]),
    backupFolder: faker.lorem.words(),
    backupInterval: faker.number.int(),
    backupRetention: faker.number.int(),
    trustCgnatIpAddresses: faker.datatype.boolean(),
  }
}

export function getPutApiV3ConfigHostId200Response() {
  return {
    id: faker.number.int(),
    bindAddress: faker.lorem.words(),
    port: faker.number.int(),
    sslPort: faker.number.int(),
    enableSsl: faker.datatype.boolean(),
    launchBrowser: faker.datatype.boolean(),
    authenticationMethod: faker.helpers.arrayElement([
      'none',
      'basic',
      'forms',
      'external',
    ]),
    authenticationRequired: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
    ]),
    analyticsEnabled: faker.datatype.boolean(),
    username: faker.person.fullName(),
    password: faker.lorem.words(),
    passwordConfirmation: faker.lorem.words(),
    logLevel: faker.lorem.words(),
    logSizeLimit: faker.number.int(),
    consoleLogLevel: faker.lorem.words(),
    branch: faker.lorem.words(),
    apiKey: faker.lorem.words(),
    sslCertPath: faker.lorem.words(),
    sslCertPassword: faker.lorem.words(),
    urlBase: faker.internet.url(),
    instanceName: faker.person.fullName(),
    applicationUrl: faker.internet.url(),
    updateAutomatically: faker.datatype.boolean(),
    updateMechanism: faker.helpers.arrayElement([
      'builtIn',
      'script',
      'external',
      'apt',
      'docker',
    ]),
    updateScriptPath: faker.lorem.words(),
    proxyEnabled: faker.datatype.boolean(),
    proxyType: faker.helpers.arrayElement(['http', 'socks4', 'socks5']),
    proxyHostname: faker.person.fullName(),
    proxyPort: faker.number.int(),
    proxyUsername: faker.person.fullName(),
    proxyPassword: faker.lorem.words(),
    proxyBypassFilter: faker.lorem.words(),
    proxyBypassLocalAddresses: faker.datatype.boolean(),
    certificateValidation: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
      'disabled',
    ]),
    backupFolder: faker.lorem.words(),
    backupInterval: faker.number.int(),
    backupRetention: faker.number.int(),
    trustCgnatIpAddresses: faker.datatype.boolean(),
  }
}

export function getGetApiV3ConfigHostId200Response() {
  return {
    id: faker.number.int(),
    bindAddress: faker.lorem.words(),
    port: faker.number.int(),
    sslPort: faker.number.int(),
    enableSsl: faker.datatype.boolean(),
    launchBrowser: faker.datatype.boolean(),
    authenticationMethod: faker.helpers.arrayElement([
      'none',
      'basic',
      'forms',
      'external',
    ]),
    authenticationRequired: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
    ]),
    analyticsEnabled: faker.datatype.boolean(),
    username: faker.person.fullName(),
    password: faker.lorem.words(),
    passwordConfirmation: faker.lorem.words(),
    logLevel: faker.lorem.words(),
    logSizeLimit: faker.number.int(),
    consoleLogLevel: faker.lorem.words(),
    branch: faker.lorem.words(),
    apiKey: faker.lorem.words(),
    sslCertPath: faker.lorem.words(),
    sslCertPassword: faker.lorem.words(),
    urlBase: faker.internet.url(),
    instanceName: faker.person.fullName(),
    applicationUrl: faker.internet.url(),
    updateAutomatically: faker.datatype.boolean(),
    updateMechanism: faker.helpers.arrayElement([
      'builtIn',
      'script',
      'external',
      'apt',
      'docker',
    ]),
    updateScriptPath: faker.lorem.words(),
    proxyEnabled: faker.datatype.boolean(),
    proxyType: faker.helpers.arrayElement(['http', 'socks4', 'socks5']),
    proxyHostname: faker.person.fullName(),
    proxyPort: faker.number.int(),
    proxyUsername: faker.person.fullName(),
    proxyPassword: faker.lorem.words(),
    proxyBypassFilter: faker.lorem.words(),
    proxyBypassLocalAddresses: faker.datatype.boolean(),
    certificateValidation: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
      'disabled',
    ]),
    backupFolder: faker.lorem.words(),
    backupInterval: faker.number.int(),
    backupRetention: faker.number.int(),
    trustCgnatIpAddresses: faker.datatype.boolean(),
  }
}

export function getGetApiV3Importlist200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableAutomaticAdd: faker.datatype.boolean(),
    searchForMissingEpisodes: faker.datatype.boolean(),
    shouldMonitor: faker.helpers.arrayElement([
      'unknown',
      'all',
      'future',
      'missing',
      'existing',
      'firstSeason',
      'lastSeason',
      'latestSeason',
      'pilot',
      'recent',
      'monitorSpecials',
      'unmonitorSpecials',
      'none',
      'skip',
    ]),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    seasonFolder: faker.datatype.boolean(),
    listType: faker.helpers.arrayElement([
      'program',
      'plex',
      'trakt',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }))
}

export function getPostApiV3Importlist200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableAutomaticAdd: faker.datatype.boolean(),
    searchForMissingEpisodes: faker.datatype.boolean(),
    shouldMonitor: faker.helpers.arrayElement([
      'unknown',
      'all',
      'future',
      'missing',
      'existing',
      'firstSeason',
      'lastSeason',
      'latestSeason',
      'pilot',
      'recent',
      'monitorSpecials',
      'unmonitorSpecials',
      'none',
      'skip',
    ]),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    seasonFolder: faker.datatype.boolean(),
    listType: faker.helpers.arrayElement([
      'program',
      'plex',
      'trakt',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }
}

export function getPutApiV3ImportlistId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableAutomaticAdd: faker.datatype.boolean(),
    searchForMissingEpisodes: faker.datatype.boolean(),
    shouldMonitor: faker.helpers.arrayElement([
      'unknown',
      'all',
      'future',
      'missing',
      'existing',
      'firstSeason',
      'lastSeason',
      'latestSeason',
      'pilot',
      'recent',
      'monitorSpecials',
      'unmonitorSpecials',
      'none',
      'skip',
    ]),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    seasonFolder: faker.datatype.boolean(),
    listType: faker.helpers.arrayElement([
      'program',
      'plex',
      'trakt',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }
}

export function getGetApiV3ImportlistId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableAutomaticAdd: faker.datatype.boolean(),
    searchForMissingEpisodes: faker.datatype.boolean(),
    shouldMonitor: faker.helpers.arrayElement([
      'unknown',
      'all',
      'future',
      'missing',
      'existing',
      'firstSeason',
      'lastSeason',
      'latestSeason',
      'pilot',
      'recent',
      'monitorSpecials',
      'unmonitorSpecials',
      'none',
      'skip',
    ]),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    seasonFolder: faker.datatype.boolean(),
    listType: faker.helpers.arrayElement([
      'program',
      'plex',
      'trakt',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }
}

export function getPutApiV3ImportlistBulk200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableAutomaticAdd: faker.datatype.boolean(),
    searchForMissingEpisodes: faker.datatype.boolean(),
    shouldMonitor: faker.helpers.arrayElement([
      'unknown',
      'all',
      'future',
      'missing',
      'existing',
      'firstSeason',
      'lastSeason',
      'latestSeason',
      'pilot',
      'recent',
      'monitorSpecials',
      'unmonitorSpecials',
      'none',
      'skip',
    ]),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    seasonFolder: faker.datatype.boolean(),
    listType: faker.helpers.arrayElement([
      'program',
      'plex',
      'trakt',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }
}

export function getGetApiV3ImportlistSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableAutomaticAdd: faker.datatype.boolean(),
    searchForMissingEpisodes: faker.datatype.boolean(),
    shouldMonitor: faker.helpers.arrayElement([
      'unknown',
      'all',
      'future',
      'missing',
      'existing',
      'firstSeason',
      'lastSeason',
      'latestSeason',
      'pilot',
      'recent',
      'monitorSpecials',
      'unmonitorSpecials',
      'none',
      'skip',
    ]),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    seasonFolder: faker.datatype.boolean(),
    listType: faker.helpers.arrayElement([
      'program',
      'plex',
      'trakt',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }))
}

export function getGetApiV3ConfigImportlist200Response() {
  return {
    id: faker.number.int(),
    listSyncLevel: faker.helpers.arrayElement([
      'disabled',
      'logOnly',
      'keepAndUnmonitor',
      'keepAndTag',
    ]),
    listSyncTag: faker.number.int(),
  }
}

export function getPutApiV3ConfigImportlistId200Response() {
  return {
    id: faker.number.int(),
    listSyncLevel: faker.helpers.arrayElement([
      'disabled',
      'logOnly',
      'keepAndUnmonitor',
      'keepAndTag',
    ]),
    listSyncTag: faker.number.int(),
  }
}

export function getGetApiV3ConfigImportlistId200Response() {
  return {
    id: faker.number.int(),
    listSyncLevel: faker.helpers.arrayElement([
      'disabled',
      'logOnly',
      'keepAndUnmonitor',
      'keepAndTag',
    ]),
    listSyncTag: faker.number.int(),
  }
}

export function getGetApiV3Importlistexclusion200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    tvdbId: faker.number.int(),
    title: faker.lorem.words(),
  }))
}

export function getPostApiV3Importlistexclusion200Response() {
  return {
    id: faker.number.int(),
    tvdbId: faker.number.int(),
    title: faker.lorem.words(),
  }
}

export function getGetApiV3ImportlistexclusionPaged200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      tvdbId: faker.number.int(),
      title: faker.lorem.words(),
    })),
  }
}

export function getPutApiV3ImportlistexclusionId200Response() {
  return {
    id: faker.number.int(),
    tvdbId: faker.number.int(),
    title: faker.lorem.words(),
  }
}

export function getGetApiV3ImportlistexclusionId200Response() {
  return {
    id: faker.number.int(),
    tvdbId: faker.number.int(),
    title: faker.lorem.words(),
  }
}

export function getGetApiV3Indexer200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    seasonSearchMaximumSingleEpisodeAge: faker.number.int(),
    downloadClientId: faker.number.int(),
  }))
}

export function getPostApiV3Indexer200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    seasonSearchMaximumSingleEpisodeAge: faker.number.int(),
    downloadClientId: faker.number.int(),
  }
}

export function getPutApiV3IndexerId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    seasonSearchMaximumSingleEpisodeAge: faker.number.int(),
    downloadClientId: faker.number.int(),
  }
}

export function getGetApiV3IndexerId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    seasonSearchMaximumSingleEpisodeAge: faker.number.int(),
    downloadClientId: faker.number.int(),
  }
}

export function getPutApiV3IndexerBulk200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    seasonSearchMaximumSingleEpisodeAge: faker.number.int(),
    downloadClientId: faker.number.int(),
  }
}

export function getGetApiV3IndexerSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    seasonSearchMaximumSingleEpisodeAge: faker.number.int(),
    downloadClientId: faker.number.int(),
  }))
}

export function getGetApiV3ConfigIndexer200Response() {
  return {
    id: faker.number.int(),
    minimumAge: faker.number.int(),
    retention: faker.number.int(),
    maximumSize: faker.number.int(),
    rssSyncInterval: faker.number.int(),
  }
}

export function getPutApiV3ConfigIndexerId200Response() {
  return {
    id: faker.number.int(),
    minimumAge: faker.number.int(),
    retention: faker.number.int(),
    maximumSize: faker.number.int(),
    rssSyncInterval: faker.number.int(),
  }
}

export function getGetApiV3ConfigIndexerId200Response() {
  return {
    id: faker.number.int(),
    minimumAge: faker.number.int(),
    retention: faker.number.int(),
    maximumSize: faker.number.int(),
    rssSyncInterval: faker.number.int(),
  }
}

export function getGetApiV3Indexerflag200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    nameLower: faker.lorem.words(),
  }))
}

export function getGetApiV3Language200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    nameLower: faker.lorem.words(),
  }))
}

export function getGetApiV3LanguageId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    nameLower: faker.lorem.words(),
  }
}

export function getPostApiV3Languageprofile200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      language: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      allowed: faker.datatype.boolean(),
    })),
  }
}

export function getGetApiV3Languageprofile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      language: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      allowed: faker.datatype.boolean(),
    })),
  }))
}

export function getPutApiV3LanguageprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      language: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      allowed: faker.datatype.boolean(),
    })),
  }
}

export function getGetApiV3LanguageprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      language: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      allowed: faker.datatype.boolean(),
    })),
  }
}

export function getGetApiV3LanguageprofileSchema200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      language: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      allowed: faker.datatype.boolean(),
    })),
  }
}

export function getGetApiV3Localization200Response() {
  return {
    id: faker.number.int(),
    strings: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: faker.lorem.words() }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  }
}

export function getGetApiV3LocalizationLanguage200Response() {
  return {
    identifier: faker.lorem.words(),
  }
}

export function getGetApiV3LocalizationId200Response() {
  return {
    id: faker.number.int(),
    strings: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: faker.lorem.words() }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
  }
}

export function getGetApiV3Log200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      time: faker.date.past(),
      exception: faker.lorem.words(),
      exceptionType: faker.lorem.words(),
      level: faker.lorem.words(),
      logger: faker.lorem.words(),
      message: faker.lorem.words(),
      method: faker.lorem.words(),
    })),
  }
}

export function getGetApiV3LogFile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    filename: faker.person.fullName(),
    lastWriteTime: faker.date.past(),
    contentsUrl: faker.internet.url(),
    downloadUrl: faker.internet.url(),
  }))
}

export function getGetApiV3Manualimport200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    path: faker.lorem.words(),
    relativePath: faker.lorem.words(),
    folderName: faker.person.fullName(),
    name: faker.person.fullName(),
    size: faker.number.int(),
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    seasonNumber: faker.number.int(),
    episodes: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      seriesId: faker.number.int(),
      tvdbId: faker.number.int(),
      episodeFileId: faker.number.int(),
      seasonNumber: faker.number.int(),
      episodeNumber: faker.number.int(),
      title: faker.lorem.words(),
      airDate: faker.lorem.words(),
      airDateUtc: faker.date.past(),
      lastSearchTime: faker.date.past(),
      runtime: faker.number.int(),
      finaleType: faker.lorem.words(),
      overview: faker.lorem.words(),
      episodeFile: {
        id: faker.number.int(),
        seriesId: faker.number.int(),
        seasonNumber: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'television',
              'televisionRaw',
              'web',
              'webRip',
              'dvd',
              'bluray',
              'blurayRaw',
            ]),
            resolution: faker.number.int(),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        releaseType: faker.helpers.arrayElement([
          'unknown',
          'singleEpisode',
          'multiEpisode',
          'seasonPack',
        ]),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      hasFile: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      absoluteEpisodeNumber: faker.number.int(),
      sceneAbsoluteEpisodeNumber: faker.number.int(),
      sceneEpisodeNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      unverifiedSceneNumbering: faker.datatype.boolean(),
      endTime: faker.date.past(),
      grabDate: faker.date.past(),
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    })),
    episodeFileId: faker.number.int(),
    releaseGroup: faker.lorem.words(),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    qualityWeight: faker.number.int(),
    downloadId: faker.string.uuid(),
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    indexerFlags: faker.number.int(),
    releaseType: faker.helpers.arrayElement([
      'unknown',
      'singleEpisode',
      'multiEpisode',
      'seasonPack',
    ]),
    rejections: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      reason: faker.lorem.words(),
      type: faker.helpers.arrayElement(['permanent', 'temporary']),
    })),
  }))
}

export function getGetApiV3ConfigMediamanagement200Response() {
  return {
    id: faker.number.int(),
    autoUnmonitorPreviouslyDownloadedEpisodes: faker.datatype.boolean(),
    recycleBin: faker.lorem.words(),
    recycleBinCleanupDays: faker.number.int(),
    downloadPropersAndRepacks: faker.helpers.arrayElement([
      'preferAndUpgrade',
      'doNotUpgrade',
      'doNotPrefer',
    ]),
    createEmptySeriesFolders: faker.datatype.boolean(),
    deleteEmptyFolders: faker.datatype.boolean(),
    fileDate: faker.helpers.arrayElement([
      'none',
      'localAirDate',
      'utcAirDate',
    ]),
    rescanAfterRefresh: faker.helpers.arrayElement([
      'always',
      'afterManual',
      'never',
    ]),
    setPermissionsLinux: faker.datatype.boolean(),
    chmodFolder: faker.lorem.words(),
    chownGroup: faker.lorem.words(),
    episodeTitleRequired: faker.helpers.arrayElement([
      'always',
      'bulkSeasonReleases',
      'never',
    ]),
    skipFreeSpaceCheckWhenImporting: faker.datatype.boolean(),
    minimumFreeSpaceWhenImporting: faker.number.int(),
    copyUsingHardlinks: faker.datatype.boolean(),
    useScriptImport: faker.datatype.boolean(),
    scriptImportPath: faker.lorem.words(),
    importExtraFiles: faker.datatype.boolean(),
    extraFileExtensions: faker.lorem.words(),
    enableMediaInfo: faker.datatype.boolean(),
  }
}

export function getPutApiV3ConfigMediamanagementId200Response() {
  return {
    id: faker.number.int(),
    autoUnmonitorPreviouslyDownloadedEpisodes: faker.datatype.boolean(),
    recycleBin: faker.lorem.words(),
    recycleBinCleanupDays: faker.number.int(),
    downloadPropersAndRepacks: faker.helpers.arrayElement([
      'preferAndUpgrade',
      'doNotUpgrade',
      'doNotPrefer',
    ]),
    createEmptySeriesFolders: faker.datatype.boolean(),
    deleteEmptyFolders: faker.datatype.boolean(),
    fileDate: faker.helpers.arrayElement([
      'none',
      'localAirDate',
      'utcAirDate',
    ]),
    rescanAfterRefresh: faker.helpers.arrayElement([
      'always',
      'afterManual',
      'never',
    ]),
    setPermissionsLinux: faker.datatype.boolean(),
    chmodFolder: faker.lorem.words(),
    chownGroup: faker.lorem.words(),
    episodeTitleRequired: faker.helpers.arrayElement([
      'always',
      'bulkSeasonReleases',
      'never',
    ]),
    skipFreeSpaceCheckWhenImporting: faker.datatype.boolean(),
    minimumFreeSpaceWhenImporting: faker.number.int(),
    copyUsingHardlinks: faker.datatype.boolean(),
    useScriptImport: faker.datatype.boolean(),
    scriptImportPath: faker.lorem.words(),
    importExtraFiles: faker.datatype.boolean(),
    extraFileExtensions: faker.lorem.words(),
    enableMediaInfo: faker.datatype.boolean(),
  }
}

export function getGetApiV3ConfigMediamanagementId200Response() {
  return {
    id: faker.number.int(),
    autoUnmonitorPreviouslyDownloadedEpisodes: faker.datatype.boolean(),
    recycleBin: faker.lorem.words(),
    recycleBinCleanupDays: faker.number.int(),
    downloadPropersAndRepacks: faker.helpers.arrayElement([
      'preferAndUpgrade',
      'doNotUpgrade',
      'doNotPrefer',
    ]),
    createEmptySeriesFolders: faker.datatype.boolean(),
    deleteEmptyFolders: faker.datatype.boolean(),
    fileDate: faker.helpers.arrayElement([
      'none',
      'localAirDate',
      'utcAirDate',
    ]),
    rescanAfterRefresh: faker.helpers.arrayElement([
      'always',
      'afterManual',
      'never',
    ]),
    setPermissionsLinux: faker.datatype.boolean(),
    chmodFolder: faker.lorem.words(),
    chownGroup: faker.lorem.words(),
    episodeTitleRequired: faker.helpers.arrayElement([
      'always',
      'bulkSeasonReleases',
      'never',
    ]),
    skipFreeSpaceCheckWhenImporting: faker.datatype.boolean(),
    minimumFreeSpaceWhenImporting: faker.number.int(),
    copyUsingHardlinks: faker.datatype.boolean(),
    useScriptImport: faker.datatype.boolean(),
    scriptImportPath: faker.lorem.words(),
    importExtraFiles: faker.datatype.boolean(),
    extraFileExtensions: faker.lorem.words(),
    enableMediaInfo: faker.datatype.boolean(),
  }
}

export function getGetApiV3Metadata200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }))
}

export function getPostApiV3Metadata200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }
}

export function getPutApiV3MetadataId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }
}

export function getGetApiV3MetadataId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }
}

export function getGetApiV3MetadataSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }))
}

export function getGetApiV3WantedMissing200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      seriesId: faker.number.int(),
      tvdbId: faker.number.int(),
      episodeFileId: faker.number.int(),
      seasonNumber: faker.number.int(),
      episodeNumber: faker.number.int(),
      title: faker.lorem.words(),
      airDate: faker.lorem.words(),
      airDateUtc: faker.date.past(),
      lastSearchTime: faker.date.past(),
      runtime: faker.number.int(),
      finaleType: faker.lorem.words(),
      overview: faker.lorem.words(),
      episodeFile: {
        id: faker.number.int(),
        seriesId: faker.number.int(),
        seasonNumber: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'television',
              'televisionRaw',
              'web',
              'webRip',
              'dvd',
              'bluray',
              'blurayRaw',
            ]),
            resolution: faker.number.int(),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        releaseType: faker.helpers.arrayElement([
          'unknown',
          'singleEpisode',
          'multiEpisode',
          'seasonPack',
        ]),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      hasFile: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      absoluteEpisodeNumber: faker.number.int(),
      sceneAbsoluteEpisodeNumber: faker.number.int(),
      sceneEpisodeNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      unverifiedSceneNumbering: faker.datatype.boolean(),
      endTime: faker.date.past(),
      grabDate: faker.date.past(),
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    })),
  }
}

export function getGetApiV3WantedMissingId200Response() {
  return {
    id: faker.number.int(),
    seriesId: faker.number.int(),
    tvdbId: faker.number.int(),
    episodeFileId: faker.number.int(),
    seasonNumber: faker.number.int(),
    episodeNumber: faker.number.int(),
    title: faker.lorem.words(),
    airDate: faker.lorem.words(),
    airDateUtc: faker.date.past(),
    lastSearchTime: faker.date.past(),
    runtime: faker.number.int(),
    finaleType: faker.lorem.words(),
    overview: faker.lorem.words(),
    episodeFile: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      seasonNumber: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      releaseType: faker.helpers.arrayElement([
        'unknown',
        'singleEpisode',
        'multiEpisode',
        'seasonPack',
      ]),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    hasFile: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    absoluteEpisodeNumber: faker.number.int(),
    sceneAbsoluteEpisodeNumber: faker.number.int(),
    sceneEpisodeNumber: faker.number.int(),
    sceneSeasonNumber: faker.number.int(),
    unverifiedSceneNumbering: faker.datatype.boolean(),
    endTime: faker.date.past(),
    grabDate: faker.date.past(),
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
  }
}

export function getGetApiV3ConfigNaming200Response() {
  return {
    id: faker.number.int(),
    renameEpisodes: faker.datatype.boolean(),
    replaceIllegalCharacters: faker.datatype.boolean(),
    colonReplacementFormat: faker.number.int(),
    customColonReplacementFormat: faker.lorem.words(),
    multiEpisodeStyle: faker.number.int(),
    standardEpisodeFormat: faker.lorem.words(),
    dailyEpisodeFormat: faker.lorem.words(),
    animeEpisodeFormat: faker.lorem.words(),
    seriesFolderFormat: faker.lorem.words(),
    seasonFolderFormat: faker.lorem.words(),
    specialsFolderFormat: faker.lorem.words(),
  }
}

export function getPutApiV3ConfigNamingId200Response() {
  return {
    id: faker.number.int(),
    renameEpisodes: faker.datatype.boolean(),
    replaceIllegalCharacters: faker.datatype.boolean(),
    colonReplacementFormat: faker.number.int(),
    customColonReplacementFormat: faker.lorem.words(),
    multiEpisodeStyle: faker.number.int(),
    standardEpisodeFormat: faker.lorem.words(),
    dailyEpisodeFormat: faker.lorem.words(),
    animeEpisodeFormat: faker.lorem.words(),
    seriesFolderFormat: faker.lorem.words(),
    seasonFolderFormat: faker.lorem.words(),
    specialsFolderFormat: faker.lorem.words(),
  }
}

export function getGetApiV3ConfigNamingId200Response() {
  return {
    id: faker.number.int(),
    renameEpisodes: faker.datatype.boolean(),
    replaceIllegalCharacters: faker.datatype.boolean(),
    colonReplacementFormat: faker.number.int(),
    customColonReplacementFormat: faker.lorem.words(),
    multiEpisodeStyle: faker.number.int(),
    standardEpisodeFormat: faker.lorem.words(),
    dailyEpisodeFormat: faker.lorem.words(),
    animeEpisodeFormat: faker.lorem.words(),
    seriesFolderFormat: faker.lorem.words(),
    seasonFolderFormat: faker.lorem.words(),
    specialsFolderFormat: faker.lorem.words(),
  }
}

export function getGetApiV3Notification200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onImportComplete: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onSeriesAdd: faker.datatype.boolean(),
    onSeriesDelete: faker.datatype.boolean(),
    onEpisodeFileDelete: faker.datatype.boolean(),
    onEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnImportComplete: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnSeriesAdd: faker.datatype.boolean(),
    supportsOnSeriesDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }))
}

export function getPostApiV3Notification200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onImportComplete: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onSeriesAdd: faker.datatype.boolean(),
    onSeriesDelete: faker.datatype.boolean(),
    onEpisodeFileDelete: faker.datatype.boolean(),
    onEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnImportComplete: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnSeriesAdd: faker.datatype.boolean(),
    supportsOnSeriesDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }
}

export function getPutApiV3NotificationId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onImportComplete: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onSeriesAdd: faker.datatype.boolean(),
    onSeriesDelete: faker.datatype.boolean(),
    onEpisodeFileDelete: faker.datatype.boolean(),
    onEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnImportComplete: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnSeriesAdd: faker.datatype.boolean(),
    supportsOnSeriesDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }
}

export function getGetApiV3NotificationId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onImportComplete: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onSeriesAdd: faker.datatype.boolean(),
    onSeriesDelete: faker.datatype.boolean(),
    onEpisodeFileDelete: faker.datatype.boolean(),
    onEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnImportComplete: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnSeriesAdd: faker.datatype.boolean(),
    supportsOnSeriesDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }
}

export function getGetApiV3NotificationSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onImportComplete: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onSeriesAdd: faker.datatype.boolean(),
    onSeriesDelete: faker.datatype.boolean(),
    onEpisodeFileDelete: faker.datatype.boolean(),
    onEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnImportComplete: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnSeriesAdd: faker.datatype.boolean(),
    supportsOnSeriesDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDelete: faker.datatype.boolean(),
    supportsOnEpisodeFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }))
}

export function getGetApiV3Parse200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    parsedEpisodeInfo: {
      releaseTitle: faker.lorem.words(),
      seriesTitle: faker.lorem.words(),
      seriesTitleInfo: {
        title: faker.lorem.words(),
        titleWithoutYear: faker.lorem.words(),
        year: faker.number.int(),
        allTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      },
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      seasonNumber: faker.number.int(),
      episodeNumbers: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      absoluteEpisodeNumbers: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      specialAbsoluteEpisodeNumbers: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      airDate: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      fullSeason: faker.datatype.boolean(),
      isPartialSeason: faker.datatype.boolean(),
      isMultiSeason: faker.datatype.boolean(),
      isSeasonExtra: faker.datatype.boolean(),
      isSplitEpisode: faker.datatype.boolean(),
      isMiniSeries: faker.datatype.boolean(),
      special: faker.datatype.boolean(),
      releaseGroup: faker.lorem.words(),
      releaseHash: faker.lorem.words(),
      seasonPart: faker.number.int(),
      releaseTokens: faker.lorem.words(),
      dailyPart: faker.number.int(),
      isDaily: faker.datatype.boolean(),
      isAbsoluteNumbering: faker.datatype.boolean(),
      isPossibleSpecialEpisode: faker.datatype.boolean(),
      isPossibleSceneSeasonSpecial: faker.datatype.boolean(),
      releaseType: faker.helpers.arrayElement([
        'unknown',
        'singleEpisode',
        'multiEpisode',
        'seasonPack',
      ]),
    },
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    episodes: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      seriesId: faker.number.int(),
      tvdbId: faker.number.int(),
      episodeFileId: faker.number.int(),
      seasonNumber: faker.number.int(),
      episodeNumber: faker.number.int(),
      title: faker.lorem.words(),
      airDate: faker.lorem.words(),
      airDateUtc: faker.date.past(),
      lastSearchTime: faker.date.past(),
      runtime: faker.number.int(),
      finaleType: faker.lorem.words(),
      overview: faker.lorem.words(),
      episodeFile: {
        id: faker.number.int(),
        seriesId: faker.number.int(),
        seasonNumber: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'television',
              'televisionRaw',
              'web',
              'webRip',
              'dvd',
              'bluray',
              'blurayRaw',
            ]),
            resolution: faker.number.int(),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        releaseType: faker.helpers.arrayElement([
          'unknown',
          'singleEpisode',
          'multiEpisode',
          'seasonPack',
        ]),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      hasFile: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      absoluteEpisodeNumber: faker.number.int(),
      sceneAbsoluteEpisodeNumber: faker.number.int(),
      sceneEpisodeNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      unverifiedSceneNumbering: faker.datatype.boolean(),
      endTime: faker.date.past(),
      grabDate: faker.date.past(),
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    })),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
  }
}

export function getGetPing200Response() {
  return {
    status: faker.lorem.words(),
  }
}

export function getHeadPing200Response() {
  return {
    status: faker.lorem.words(),
  }
}

export function getPutApiV3QualitydefinitionId200Response() {
  return {
    id: faker.number.int(),
    quality: {
      id: faker.number.int(),
      name: faker.person.fullName(),
      source: faker.helpers.arrayElement([
        'unknown',
        'television',
        'televisionRaw',
        'web',
        'webRip',
        'dvd',
        'bluray',
        'blurayRaw',
      ]),
      resolution: faker.number.int(),
    },
    title: faker.lorem.words(),
    weight: faker.number.int(),
    minSize: faker.number.int(),
    maxSize: faker.number.int(),
    preferredSize: faker.number.int(),
  }
}

export function getGetApiV3QualitydefinitionId200Response() {
  return {
    id: faker.number.int(),
    quality: {
      id: faker.number.int(),
      name: faker.person.fullName(),
      source: faker.helpers.arrayElement([
        'unknown',
        'television',
        'televisionRaw',
        'web',
        'webRip',
        'dvd',
        'bluray',
        'blurayRaw',
      ]),
      resolution: faker.number.int(),
    },
    title: faker.lorem.words(),
    weight: faker.number.int(),
    minSize: faker.number.int(),
    maxSize: faker.number.int(),
    preferredSize: faker.number.int(),
  }
}

export function getGetApiV3Qualitydefinition200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    quality: {
      id: faker.number.int(),
      name: faker.person.fullName(),
      source: faker.helpers.arrayElement([
        'unknown',
        'television',
        'televisionRaw',
        'web',
        'webRip',
        'dvd',
        'bluray',
        'blurayRaw',
      ]),
      resolution: faker.number.int(),
    },
    title: faker.lorem.words(),
    weight: faker.number.int(),
    minSize: faker.number.int(),
    maxSize: faker.number.int(),
    preferredSize: faker.number.int(),
  }))
}

export function getGetApiV3QualitydefinitionLimits200Response() {
  return {
    min: faker.number.int(),
    max: faker.number.int(),
  }
}

export function getPostApiV3Qualityprofile200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
  }
}

export function getGetApiV3Qualityprofile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
  }))
}

export function getPutApiV3QualityprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
  }
}

export function getGetApiV3QualityprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
  }
}

export function getGetApiV3QualityprofileSchema200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
  }
}

export function getGetApiV3Queue200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      seriesId: faker.number.int(),
      episodeId: faker.number.int(),
      seasonNumber: faker.number.int(),
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
      episode: {
        id: faker.number.int(),
        seriesId: faker.number.int(),
        tvdbId: faker.number.int(),
        episodeFileId: faker.number.int(),
        seasonNumber: faker.number.int(),
        episodeNumber: faker.number.int(),
        title: faker.lorem.words(),
        airDate: faker.lorem.words(),
        airDateUtc: faker.date.past(),
        lastSearchTime: faker.date.past(),
        runtime: faker.number.int(),
        finaleType: faker.lorem.words(),
        overview: faker.lorem.words(),
        episodeFile: {
          id: faker.number.int(),
          seriesId: faker.number.int(),
          seasonNumber: faker.number.int(),
          relativePath: faker.lorem.words(),
          path: faker.lorem.words(),
          size: faker.number.int(),
          dateAdded: faker.date.past(),
          sceneName: faker.person.fullName(),
          releaseGroup: faker.lorem.words(),
          languages: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
          })),
          quality: {
            quality: {
              id: faker.number.int(),
              name: faker.person.fullName(),
              source: faker.helpers.arrayElement([
                'unknown',
                'television',
                'televisionRaw',
                'web',
                'webRip',
                'dvd',
                'bluray',
                'blurayRaw',
              ]),
              resolution: faker.number.int(),
            },
            revision: {
              version: faker.number.int(),
              real: faker.number.int(),
              isRepack: faker.datatype.boolean(),
            },
          },
          customFormats: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            includeCustomFormatWhenRenaming: faker.datatype.boolean(),
            specifications: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              id: faker.number.int(),
              name: faker.person.fullName(),
              implementation: faker.lorem.words(),
              implementationName: faker.person.fullName(),
              infoLink: faker.lorem.words(),
              negate: faker.datatype.boolean(),
              required: faker.datatype.boolean(),
              fields: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                order: faker.number.int(),
                name: faker.person.fullName(),
                label: faker.lorem.words(),
                unit: faker.lorem.words(),
                helpText: faker.lorem.words(),
                helpTextWarning: faker.lorem.words(),
                helpLink: faker.lorem.words(),
                value: null,
                type: faker.lorem.words(),
                advanced: faker.datatype.boolean(),
                selectOptions: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => ({
                  value: faker.number.int(),
                  name: faker.person.fullName(),
                  order: faker.number.int(),
                  hint: faker.lorem.words(),
                })),
                selectOptionsProviderAction: faker.lorem.words(),
                section: faker.lorem.words(),
                hidden: faker.lorem.words(),
                privacy: faker.helpers.arrayElement([
                  'normal',
                  'password',
                  'apiKey',
                  'userName',
                ]),
                placeholder: faker.lorem.words(),
                isFloat: faker.datatype.boolean(),
              })),
              presets: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => null),
            })),
          })),
          customFormatScore: faker.number.int(),
          indexerFlags: faker.number.int(),
          releaseType: faker.helpers.arrayElement([
            'unknown',
            'singleEpisode',
            'multiEpisode',
            'seasonPack',
          ]),
          mediaInfo: {
            id: faker.number.int(),
            audioBitrate: faker.number.int(),
            audioChannels: faker.number.int(),
            audioCodec: faker.lorem.words(),
            audioLanguages: faker.lorem.words(),
            audioStreamCount: faker.number.int(),
            videoBitDepth: faker.number.int(),
            videoBitrate: faker.number.int(),
            videoCodec: faker.lorem.words(),
            videoFps: faker.number.int(),
            videoDynamicRange: faker.lorem.words(),
            videoDynamicRangeType: faker.lorem.words(),
            resolution: faker.lorem.words(),
            runTime: faker.lorem.words(),
            scanType: faker.lorem.words(),
            subtitles: faker.lorem.words(),
          },
          qualityCutoffNotMet: faker.datatype.boolean(),
        },
        hasFile: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        absoluteEpisodeNumber: faker.number.int(),
        sceneAbsoluteEpisodeNumber: faker.number.int(),
        sceneEpisodeNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        unverifiedSceneNumbering: faker.datatype.boolean(),
        endTime: faker.date.past(),
        grabDate: faker.date.past(),
        series: {
          id: faker.number.int(),
          title: faker.lorem.words(),
          alternateTitles: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            title: faker.lorem.words(),
            seasonNumber: faker.number.int(),
            sceneSeasonNumber: faker.number.int(),
            sceneOrigin: faker.lorem.words(),
            comment: faker.lorem.words(),
          })),
          sortTitle: faker.lorem.words(),
          status: faker.helpers.arrayElement([
            'continuing',
            'ended',
            'upcoming',
            'deleted',
          ]),
          ended: faker.datatype.boolean(),
          profileName: faker.person.fullName(),
          overview: faker.lorem.words(),
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          network: faker.lorem.words(),
          airTime: faker.lorem.words(),
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
          originalLanguage: {
            id: faker.number.int(),
            name: faker.person.fullName(),
          },
          remotePoster: faker.lorem.words(),
          seasons: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            seasonNumber: faker.number.int(),
            monitored: faker.datatype.boolean(),
            statistics: {
              nextAiring: faker.date.past(),
              previousAiring: faker.date.past(),
              episodeFileCount: faker.number.int(),
              episodeCount: faker.number.int(),
              totalEpisodeCount: faker.number.int(),
              sizeOnDisk: faker.number.int(),
              releaseGroups: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => faker.lorem.words()),
              percentOfEpisodes: faker.number.int(),
            },
            images: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              coverType: faker.helpers.arrayElement([
                'unknown',
                'poster',
                'banner',
                'fanart',
                'screenshot',
                'headshot',
                'clearlogo',
              ]),
              url: faker.internet.url(),
              remoteUrl: faker.internet.url(),
            })),
          })),
          year: faker.number.int(),
          path: faker.lorem.words(),
          qualityProfileId: faker.number.int(),
          seasonFolder: faker.datatype.boolean(),
          monitored: faker.datatype.boolean(),
          monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
          useSceneNumbering: faker.datatype.boolean(),
          runtime: faker.number.int(),
          tvdbId: faker.number.int(),
          tvRageId: faker.number.int(),
          tvMazeId: faker.number.int(),
          tmdbId: faker.number.int(),
          firstAired: faker.date.past(),
          lastAired: faker.date.past(),
          seriesType: faker.helpers.arrayElement([
            'standard',
            'daily',
            'anime',
          ]),
          cleanTitle: faker.lorem.words(),
          imdbId: faker.string.uuid(),
          titleSlug: faker.lorem.words(),
          rootFolderPath: faker.lorem.words(),
          folder: faker.lorem.words(),
          certification: faker.lorem.words(),
          genres: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          tags: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.number.int()),
          added: faker.date.past(),
          addOptions: {
            ignoreEpisodesWithFiles: faker.datatype.boolean(),
            ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
            monitor: faker.helpers.arrayElement([
              'unknown',
              'all',
              'future',
              'missing',
              'existing',
              'firstSeason',
              'lastSeason',
              'latestSeason',
              'pilot',
              'recent',
              'monitorSpecials',
              'unmonitorSpecials',
              'none',
              'skip',
            ]),
            searchForMissingEpisodes: faker.datatype.boolean(),
            searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
          },
          ratings: {
            votes: faker.number.int(),
            value: faker.number.int(),
          },
          statistics: {
            seasonCount: faker.number.int(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          episodesChanged: faker.datatype.boolean(),
          languageProfileId: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      },
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'television',
            'televisionRaw',
            'web',
            'webRip',
            'dvd',
            'bluray',
            'blurayRaw',
          ]),
          resolution: faker.number.int(),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      size: faker.number.int(),
      title: faker.lorem.words(),
      estimatedCompletionTime: faker.date.past(),
      added: faker.date.past(),
      status: faker.helpers.arrayElement([
        'unknown',
        'queued',
        'paused',
        'downloading',
        'completed',
        'failed',
        'warning',
        'delay',
        'downloadClientUnavailable',
        'fallback',
      ]),
      trackedDownloadStatus: faker.helpers.arrayElement([
        'ok',
        'warning',
        'error',
      ]),
      trackedDownloadState: faker.helpers.arrayElement([
        'downloading',
        'importBlocked',
        'importPending',
        'importing',
        'imported',
        'failedPending',
        'failed',
        'ignored',
      ]),
      statusMessages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        messages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      })),
      errorMessage: faker.lorem.words(),
      downloadId: faker.string.uuid(),
      protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
      downloadClient: faker.lorem.words(),
      downloadClientHasPostImportCategory: faker.datatype.boolean(),
      indexer: faker.lorem.words(),
      outputPath: faker.lorem.words(),
      episodeHasFile: faker.datatype.boolean(),
      sizeleft: faker.number.int(),
      timeleft: faker.lorem.words(),
    })),
  }
}

export function getGetApiV3QueueDetails200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    seriesId: faker.number.int(),
    episodeId: faker.number.int(),
    seasonNumber: faker.number.int(),
    series: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        seasonNumber: faker.number.int(),
        sceneSeasonNumber: faker.number.int(),
        sceneOrigin: faker.lorem.words(),
        comment: faker.lorem.words(),
      })),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'continuing',
        'ended',
        'upcoming',
        'deleted',
      ]),
      ended: faker.datatype.boolean(),
      profileName: faker.person.fullName(),
      overview: faker.lorem.words(),
      nextAiring: faker.date.past(),
      previousAiring: faker.date.past(),
      network: faker.lorem.words(),
      airTime: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      remotePoster: faker.lorem.words(),
      seasons: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        seasonNumber: faker.number.int(),
        monitored: faker.datatype.boolean(),
        statistics: {
          nextAiring: faker.date.past(),
          previousAiring: faker.date.past(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
      })),
      year: faker.number.int(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      seasonFolder: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
      useSceneNumbering: faker.datatype.boolean(),
      runtime: faker.number.int(),
      tvdbId: faker.number.int(),
      tvRageId: faker.number.int(),
      tvMazeId: faker.number.int(),
      tmdbId: faker.number.int(),
      firstAired: faker.date.past(),
      lastAired: faker.date.past(),
      seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'unknown',
          'all',
          'future',
          'missing',
          'existing',
          'firstSeason',
          'lastSeason',
          'latestSeason',
          'pilot',
          'recent',
          'monitorSpecials',
          'unmonitorSpecials',
          'none',
          'skip',
        ]),
        searchForMissingEpisodes: faker.datatype.boolean(),
        searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
      },
      ratings: {
        votes: faker.number.int(),
        value: faker.number.int(),
      },
      statistics: {
        seasonCount: faker.number.int(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      episodesChanged: faker.datatype.boolean(),
      languageProfileId: faker.number.int(),
    },
    episode: {
      id: faker.number.int(),
      seriesId: faker.number.int(),
      tvdbId: faker.number.int(),
      episodeFileId: faker.number.int(),
      seasonNumber: faker.number.int(),
      episodeNumber: faker.number.int(),
      title: faker.lorem.words(),
      airDate: faker.lorem.words(),
      airDateUtc: faker.date.past(),
      lastSearchTime: faker.date.past(),
      runtime: faker.number.int(),
      finaleType: faker.lorem.words(),
      overview: faker.lorem.words(),
      episodeFile: {
        id: faker.number.int(),
        seriesId: faker.number.int(),
        seasonNumber: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'television',
              'televisionRaw',
              'web',
              'webRip',
              'dvd',
              'bluray',
              'blurayRaw',
            ]),
            resolution: faker.number.int(),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        releaseType: faker.helpers.arrayElement([
          'unknown',
          'singleEpisode',
          'multiEpisode',
          'seasonPack',
        ]),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      hasFile: faker.datatype.boolean(),
      monitored: faker.datatype.boolean(),
      absoluteEpisodeNumber: faker.number.int(),
      sceneAbsoluteEpisodeNumber: faker.number.int(),
      sceneEpisodeNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      unverifiedSceneNumbering: faker.datatype.boolean(),
      endTime: faker.date.past(),
      grabDate: faker.date.past(),
      series: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          title: faker.lorem.words(),
          seasonNumber: faker.number.int(),
          sceneSeasonNumber: faker.number.int(),
          sceneOrigin: faker.lorem.words(),
          comment: faker.lorem.words(),
        })),
        sortTitle: faker.lorem.words(),
        status: faker.helpers.arrayElement([
          'continuing',
          'ended',
          'upcoming',
          'deleted',
        ]),
        ended: faker.datatype.boolean(),
        profileName: faker.person.fullName(),
        overview: faker.lorem.words(),
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        network: faker.lorem.words(),
        airTime: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        remotePoster: faker.lorem.words(),
        seasons: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          seasonNumber: faker.number.int(),
          monitored: faker.datatype.boolean(),
          statistics: {
            nextAiring: faker.date.past(),
            previousAiring: faker.date.past(),
            episodeFileCount: faker.number.int(),
            episodeCount: faker.number.int(),
            totalEpisodeCount: faker.number.int(),
            sizeOnDisk: faker.number.int(),
            releaseGroups: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => faker.lorem.words()),
            percentOfEpisodes: faker.number.int(),
          },
          images: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            coverType: faker.helpers.arrayElement([
              'unknown',
              'poster',
              'banner',
              'fanart',
              'screenshot',
              'headshot',
              'clearlogo',
            ]),
            url: faker.internet.url(),
            remoteUrl: faker.internet.url(),
          })),
        })),
        year: faker.number.int(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        seasonFolder: faker.datatype.boolean(),
        monitored: faker.datatype.boolean(),
        monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
        useSceneNumbering: faker.datatype.boolean(),
        runtime: faker.number.int(),
        tvdbId: faker.number.int(),
        tvRageId: faker.number.int(),
        tvMazeId: faker.number.int(),
        tmdbId: faker.number.int(),
        firstAired: faker.date.past(),
        lastAired: faker.date.past(),
        seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'unknown',
            'all',
            'future',
            'missing',
            'existing',
            'firstSeason',
            'lastSeason',
            'latestSeason',
            'pilot',
            'recent',
            'monitorSpecials',
            'unmonitorSpecials',
            'none',
            'skip',
          ]),
          searchForMissingEpisodes: faker.datatype.boolean(),
          searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
        },
        ratings: {
          votes: faker.number.int(),
          value: faker.number.int(),
        },
        statistics: {
          seasonCount: faker.number.int(),
          episodeFileCount: faker.number.int(),
          episodeCount: faker.number.int(),
          totalEpisodeCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
          percentOfEpisodes: faker.number.int(),
        },
        episodesChanged: faker.datatype.boolean(),
        languageProfileId: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    size: faker.number.int(),
    title: faker.lorem.words(),
    estimatedCompletionTime: faker.date.past(),
    added: faker.date.past(),
    status: faker.helpers.arrayElement([
      'unknown',
      'queued',
      'paused',
      'downloading',
      'completed',
      'failed',
      'warning',
      'delay',
      'downloadClientUnavailable',
      'fallback',
    ]),
    trackedDownloadStatus: faker.helpers.arrayElement([
      'ok',
      'warning',
      'error',
    ]),
    trackedDownloadState: faker.helpers.arrayElement([
      'downloading',
      'importBlocked',
      'importPending',
      'importing',
      'imported',
      'failedPending',
      'failed',
      'ignored',
    ]),
    statusMessages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      title: faker.lorem.words(),
      messages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    })),
    errorMessage: faker.lorem.words(),
    downloadId: faker.string.uuid(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    downloadClient: faker.lorem.words(),
    downloadClientHasPostImportCategory: faker.datatype.boolean(),
    indexer: faker.lorem.words(),
    outputPath: faker.lorem.words(),
    episodeHasFile: faker.datatype.boolean(),
    sizeleft: faker.number.int(),
    timeleft: faker.lorem.words(),
  }))
}

export function getGetApiV3QueueStatus200Response() {
  return {
    id: faker.number.int(),
    totalCount: faker.number.int(),
    count: faker.number.int(),
    unknownCount: faker.number.int(),
    errors: faker.datatype.boolean(),
    warnings: faker.datatype.boolean(),
    unknownErrors: faker.datatype.boolean(),
    unknownWarnings: faker.datatype.boolean(),
  }
}

export function getGetApiV3Release200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    guid: faker.string.uuid(),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    qualityWeight: faker.number.int(),
    age: faker.number.int(),
    ageHours: faker.number.int(),
    ageMinutes: faker.number.int(),
    size: faker.number.int(),
    indexerId: faker.number.int(),
    indexer: faker.lorem.words(),
    releaseGroup: faker.lorem.words(),
    subGroup: faker.lorem.words(),
    releaseHash: faker.lorem.words(),
    title: faker.lorem.words(),
    fullSeason: faker.datatype.boolean(),
    sceneSource: faker.datatype.boolean(),
    seasonNumber: faker.number.int(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    languageWeight: faker.number.int(),
    airDate: faker.lorem.words(),
    seriesTitle: faker.lorem.words(),
    episodeNumbers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    absoluteEpisodeNumbers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    mappedSeasonNumber: faker.number.int(),
    mappedEpisodeNumbers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    mappedAbsoluteEpisodeNumbers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    mappedSeriesId: faker.number.int(),
    mappedEpisodeInfo: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      seasonNumber: faker.number.int(),
      episodeNumber: faker.number.int(),
      absoluteEpisodeNumber: faker.number.int(),
      title: faker.lorem.words(),
    })),
    approved: faker.datatype.boolean(),
    temporarilyRejected: faker.datatype.boolean(),
    rejected: faker.datatype.boolean(),
    tvdbId: faker.number.int(),
    tvRageId: faker.number.int(),
    imdbId: faker.string.uuid(),
    rejections: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    publishDate: faker.date.past(),
    commentUrl: faker.internet.url(),
    downloadUrl: faker.internet.url(),
    infoUrl: faker.internet.url(),
    episodeRequested: faker.datatype.boolean(),
    downloadAllowed: faker.datatype.boolean(),
    releaseWeight: faker.number.int(),
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    sceneMapping: {
      title: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      sceneOrigin: faker.lorem.words(),
      comment: faker.lorem.words(),
    },
    magnetUrl: faker.internet.url(),
    infoHash: faker.lorem.words(),
    seeders: faker.number.int(),
    leechers: faker.number.int(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    indexerFlags: faker.number.int(),
    isDaily: faker.datatype.boolean(),
    isAbsoluteNumbering: faker.datatype.boolean(),
    isPossibleSpecialEpisode: faker.datatype.boolean(),
    special: faker.datatype.boolean(),
    seriesId: faker.number.int(),
    episodeId: faker.number.int(),
    episodeIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    downloadClientId: faker.number.int(),
    downloadClient: faker.lorem.words(),
    shouldOverride: faker.datatype.boolean(),
  }))
}

export function getPostApiV3Releaseprofile200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    enabled: faker.datatype.boolean(),
    required: null,
    ignored: null,
    indexerId: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3Releaseprofile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    enabled: faker.datatype.boolean(),
    required: null,
    ignored: null,
    indexerId: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }))
}

export function getPutApiV3ReleaseprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    enabled: faker.datatype.boolean(),
    required: null,
    ignored: null,
    indexerId: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3ReleaseprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    enabled: faker.datatype.boolean(),
    required: null,
    ignored: null,
    indexerId: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getPostApiV3ReleasePush200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    guid: faker.string.uuid(),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'television',
          'televisionRaw',
          'web',
          'webRip',
          'dvd',
          'bluray',
          'blurayRaw',
        ]),
        resolution: faker.number.int(),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    qualityWeight: faker.number.int(),
    age: faker.number.int(),
    ageHours: faker.number.int(),
    ageMinutes: faker.number.int(),
    size: faker.number.int(),
    indexerId: faker.number.int(),
    indexer: faker.lorem.words(),
    releaseGroup: faker.lorem.words(),
    subGroup: faker.lorem.words(),
    releaseHash: faker.lorem.words(),
    title: faker.lorem.words(),
    fullSeason: faker.datatype.boolean(),
    sceneSource: faker.datatype.boolean(),
    seasonNumber: faker.number.int(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    languageWeight: faker.number.int(),
    airDate: faker.lorem.words(),
    seriesTitle: faker.lorem.words(),
    episodeNumbers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    absoluteEpisodeNumbers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    mappedSeasonNumber: faker.number.int(),
    mappedEpisodeNumbers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    mappedAbsoluteEpisodeNumbers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    mappedSeriesId: faker.number.int(),
    mappedEpisodeInfo: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      seasonNumber: faker.number.int(),
      episodeNumber: faker.number.int(),
      absoluteEpisodeNumber: faker.number.int(),
      title: faker.lorem.words(),
    })),
    approved: faker.datatype.boolean(),
    temporarilyRejected: faker.datatype.boolean(),
    rejected: faker.datatype.boolean(),
    tvdbId: faker.number.int(),
    tvRageId: faker.number.int(),
    imdbId: faker.string.uuid(),
    rejections: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    publishDate: faker.date.past(),
    commentUrl: faker.internet.url(),
    downloadUrl: faker.internet.url(),
    infoUrl: faker.internet.url(),
    episodeRequested: faker.datatype.boolean(),
    downloadAllowed: faker.datatype.boolean(),
    releaseWeight: faker.number.int(),
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    sceneMapping: {
      title: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      sceneOrigin: faker.lorem.words(),
      comment: faker.lorem.words(),
    },
    magnetUrl: faker.internet.url(),
    infoHash: faker.lorem.words(),
    seeders: faker.number.int(),
    leechers: faker.number.int(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    indexerFlags: faker.number.int(),
    isDaily: faker.datatype.boolean(),
    isAbsoluteNumbering: faker.datatype.boolean(),
    isPossibleSpecialEpisode: faker.datatype.boolean(),
    special: faker.datatype.boolean(),
    seriesId: faker.number.int(),
    episodeId: faker.number.int(),
    episodeIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    downloadClientId: faker.number.int(),
    downloadClient: faker.lorem.words(),
    shouldOverride: faker.datatype.boolean(),
  }))
}

export function getPostApiV3Remotepathmapping200Response() {
  return {
    id: faker.number.int(),
    host: faker.lorem.words(),
    remotePath: faker.lorem.words(),
    localPath: faker.lorem.words(),
  }
}

export function getGetApiV3Remotepathmapping200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    host: faker.lorem.words(),
    remotePath: faker.lorem.words(),
    localPath: faker.lorem.words(),
  }))
}

export function getPutApiV3RemotepathmappingId200Response() {
  return {
    id: faker.number.int(),
    host: faker.lorem.words(),
    remotePath: faker.lorem.words(),
    localPath: faker.lorem.words(),
  }
}

export function getGetApiV3RemotepathmappingId200Response() {
  return {
    id: faker.number.int(),
    host: faker.lorem.words(),
    remotePath: faker.lorem.words(),
    localPath: faker.lorem.words(),
  }
}

export function getGetApiV3Rename200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    seriesId: faker.number.int(),
    seasonNumber: faker.number.int(),
    episodeNumbers: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    episodeFileId: faker.number.int(),
    existingPath: faker.lorem.words(),
    newPath: faker.lorem.words(),
  }))
}

export function getPostApiV3Rootfolder200Response() {
  return {
    id: faker.number.int(),
    path: faker.lorem.words(),
    accessible: faker.datatype.boolean(),
    freeSpace: faker.number.int(),
    unmappedFolders: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      path: faker.lorem.words(),
      relativePath: faker.lorem.words(),
    })),
  }
}

export function getGetApiV3Rootfolder200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    path: faker.lorem.words(),
    accessible: faker.datatype.boolean(),
    freeSpace: faker.number.int(),
    unmappedFolders: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      path: faker.lorem.words(),
      relativePath: faker.lorem.words(),
    })),
  }))
}

export function getGetApiV3RootfolderId200Response() {
  return {
    id: faker.number.int(),
    path: faker.lorem.words(),
    accessible: faker.datatype.boolean(),
    freeSpace: faker.number.int(),
    unmappedFolders: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      path: faker.lorem.words(),
      relativePath: faker.lorem.words(),
    })),
  }
}

export function getGetApiV3Series200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    title: faker.lorem.words(),
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      title: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      sceneOrigin: faker.lorem.words(),
      comment: faker.lorem.words(),
    })),
    sortTitle: faker.lorem.words(),
    status: faker.helpers.arrayElement([
      'continuing',
      'ended',
      'upcoming',
      'deleted',
    ]),
    ended: faker.datatype.boolean(),
    profileName: faker.person.fullName(),
    overview: faker.lorem.words(),
    nextAiring: faker.date.past(),
    previousAiring: faker.date.past(),
    network: faker.lorem.words(),
    airTime: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    remotePoster: faker.lorem.words(),
    seasons: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      seasonNumber: faker.number.int(),
      monitored: faker.datatype.boolean(),
      statistics: {
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    })),
    year: faker.number.int(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seasonFolder: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    useSceneNumbering: faker.datatype.boolean(),
    runtime: faker.number.int(),
    tvdbId: faker.number.int(),
    tvRageId: faker.number.int(),
    tvMazeId: faker.number.int(),
    tmdbId: faker.number.int(),
    firstAired: faker.date.past(),
    lastAired: faker.date.past(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'unknown',
        'all',
        'future',
        'missing',
        'existing',
        'firstSeason',
        'lastSeason',
        'latestSeason',
        'pilot',
        'recent',
        'monitorSpecials',
        'unmonitorSpecials',
        'none',
        'skip',
      ]),
      searchForMissingEpisodes: faker.datatype.boolean(),
      searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
    },
    ratings: {
      votes: faker.number.int(),
      value: faker.number.int(),
    },
    statistics: {
      seasonCount: faker.number.int(),
      episodeFileCount: faker.number.int(),
      episodeCount: faker.number.int(),
      totalEpisodeCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      percentOfEpisodes: faker.number.int(),
    },
    episodesChanged: faker.datatype.boolean(),
    languageProfileId: faker.number.int(),
  }))
}

export function getPostApiV3Series200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      title: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      sceneOrigin: faker.lorem.words(),
      comment: faker.lorem.words(),
    })),
    sortTitle: faker.lorem.words(),
    status: faker.helpers.arrayElement([
      'continuing',
      'ended',
      'upcoming',
      'deleted',
    ]),
    ended: faker.datatype.boolean(),
    profileName: faker.person.fullName(),
    overview: faker.lorem.words(),
    nextAiring: faker.date.past(),
    previousAiring: faker.date.past(),
    network: faker.lorem.words(),
    airTime: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    remotePoster: faker.lorem.words(),
    seasons: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      seasonNumber: faker.number.int(),
      monitored: faker.datatype.boolean(),
      statistics: {
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    })),
    year: faker.number.int(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seasonFolder: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    useSceneNumbering: faker.datatype.boolean(),
    runtime: faker.number.int(),
    tvdbId: faker.number.int(),
    tvRageId: faker.number.int(),
    tvMazeId: faker.number.int(),
    tmdbId: faker.number.int(),
    firstAired: faker.date.past(),
    lastAired: faker.date.past(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'unknown',
        'all',
        'future',
        'missing',
        'existing',
        'firstSeason',
        'lastSeason',
        'latestSeason',
        'pilot',
        'recent',
        'monitorSpecials',
        'unmonitorSpecials',
        'none',
        'skip',
      ]),
      searchForMissingEpisodes: faker.datatype.boolean(),
      searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
    },
    ratings: {
      votes: faker.number.int(),
      value: faker.number.int(),
    },
    statistics: {
      seasonCount: faker.number.int(),
      episodeFileCount: faker.number.int(),
      episodeCount: faker.number.int(),
      totalEpisodeCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      percentOfEpisodes: faker.number.int(),
    },
    episodesChanged: faker.datatype.boolean(),
    languageProfileId: faker.number.int(),
  }
}

export function getGetApiV3SeriesId200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      title: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      sceneOrigin: faker.lorem.words(),
      comment: faker.lorem.words(),
    })),
    sortTitle: faker.lorem.words(),
    status: faker.helpers.arrayElement([
      'continuing',
      'ended',
      'upcoming',
      'deleted',
    ]),
    ended: faker.datatype.boolean(),
    profileName: faker.person.fullName(),
    overview: faker.lorem.words(),
    nextAiring: faker.date.past(),
    previousAiring: faker.date.past(),
    network: faker.lorem.words(),
    airTime: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    remotePoster: faker.lorem.words(),
    seasons: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      seasonNumber: faker.number.int(),
      monitored: faker.datatype.boolean(),
      statistics: {
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    })),
    year: faker.number.int(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seasonFolder: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    useSceneNumbering: faker.datatype.boolean(),
    runtime: faker.number.int(),
    tvdbId: faker.number.int(),
    tvRageId: faker.number.int(),
    tvMazeId: faker.number.int(),
    tmdbId: faker.number.int(),
    firstAired: faker.date.past(),
    lastAired: faker.date.past(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'unknown',
        'all',
        'future',
        'missing',
        'existing',
        'firstSeason',
        'lastSeason',
        'latestSeason',
        'pilot',
        'recent',
        'monitorSpecials',
        'unmonitorSpecials',
        'none',
        'skip',
      ]),
      searchForMissingEpisodes: faker.datatype.boolean(),
      searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
    },
    ratings: {
      votes: faker.number.int(),
      value: faker.number.int(),
    },
    statistics: {
      seasonCount: faker.number.int(),
      episodeFileCount: faker.number.int(),
      episodeCount: faker.number.int(),
      totalEpisodeCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      percentOfEpisodes: faker.number.int(),
    },
    episodesChanged: faker.datatype.boolean(),
    languageProfileId: faker.number.int(),
  }
}

export function getPutApiV3SeriesId200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      title: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      sceneOrigin: faker.lorem.words(),
      comment: faker.lorem.words(),
    })),
    sortTitle: faker.lorem.words(),
    status: faker.helpers.arrayElement([
      'continuing',
      'ended',
      'upcoming',
      'deleted',
    ]),
    ended: faker.datatype.boolean(),
    profileName: faker.person.fullName(),
    overview: faker.lorem.words(),
    nextAiring: faker.date.past(),
    previousAiring: faker.date.past(),
    network: faker.lorem.words(),
    airTime: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    remotePoster: faker.lorem.words(),
    seasons: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      seasonNumber: faker.number.int(),
      monitored: faker.datatype.boolean(),
      statistics: {
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    })),
    year: faker.number.int(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seasonFolder: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    useSceneNumbering: faker.datatype.boolean(),
    runtime: faker.number.int(),
    tvdbId: faker.number.int(),
    tvRageId: faker.number.int(),
    tvMazeId: faker.number.int(),
    tmdbId: faker.number.int(),
    firstAired: faker.date.past(),
    lastAired: faker.date.past(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'unknown',
        'all',
        'future',
        'missing',
        'existing',
        'firstSeason',
        'lastSeason',
        'latestSeason',
        'pilot',
        'recent',
        'monitorSpecials',
        'unmonitorSpecials',
        'none',
        'skip',
      ]),
      searchForMissingEpisodes: faker.datatype.boolean(),
      searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
    },
    ratings: {
      votes: faker.number.int(),
      value: faker.number.int(),
    },
    statistics: {
      seasonCount: faker.number.int(),
      episodeFileCount: faker.number.int(),
      episodeCount: faker.number.int(),
      totalEpisodeCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      percentOfEpisodes: faker.number.int(),
    },
    episodesChanged: faker.datatype.boolean(),
    languageProfileId: faker.number.int(),
  }
}

export function getGetApiV3SeriesLookup200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    title: faker.lorem.words(),
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      title: faker.lorem.words(),
      seasonNumber: faker.number.int(),
      sceneSeasonNumber: faker.number.int(),
      sceneOrigin: faker.lorem.words(),
      comment: faker.lorem.words(),
    })),
    sortTitle: faker.lorem.words(),
    status: faker.helpers.arrayElement([
      'continuing',
      'ended',
      'upcoming',
      'deleted',
    ]),
    ended: faker.datatype.boolean(),
    profileName: faker.person.fullName(),
    overview: faker.lorem.words(),
    nextAiring: faker.date.past(),
    previousAiring: faker.date.past(),
    network: faker.lorem.words(),
    airTime: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    remotePoster: faker.lorem.words(),
    seasons: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      seasonNumber: faker.number.int(),
      monitored: faker.datatype.boolean(),
      statistics: {
        nextAiring: faker.date.past(),
        previousAiring: faker.date.past(),
        episodeFileCount: faker.number.int(),
        episodeCount: faker.number.int(),
        totalEpisodeCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        percentOfEpisodes: faker.number.int(),
      },
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
    })),
    year: faker.number.int(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    seasonFolder: faker.datatype.boolean(),
    monitored: faker.datatype.boolean(),
    monitorNewItems: faker.helpers.arrayElement(['all', 'none']),
    useSceneNumbering: faker.datatype.boolean(),
    runtime: faker.number.int(),
    tvdbId: faker.number.int(),
    tvRageId: faker.number.int(),
    tvMazeId: faker.number.int(),
    tmdbId: faker.number.int(),
    firstAired: faker.date.past(),
    lastAired: faker.date.past(),
    seriesType: faker.helpers.arrayElement(['standard', 'daily', 'anime']),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'unknown',
        'all',
        'future',
        'missing',
        'existing',
        'firstSeason',
        'lastSeason',
        'latestSeason',
        'pilot',
        'recent',
        'monitorSpecials',
        'unmonitorSpecials',
        'none',
        'skip',
      ]),
      searchForMissingEpisodes: faker.datatype.boolean(),
      searchForCutoffUnmetEpisodes: faker.datatype.boolean(),
    },
    ratings: {
      votes: faker.number.int(),
      value: faker.number.int(),
    },
    statistics: {
      seasonCount: faker.number.int(),
      episodeFileCount: faker.number.int(),
      episodeCount: faker.number.int(),
      totalEpisodeCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      percentOfEpisodes: faker.number.int(),
    },
    episodesChanged: faker.datatype.boolean(),
    languageProfileId: faker.number.int(),
  }))
}

export function getGetApiV3SystemStatus200Response() {
  return {
    appName: faker.person.fullName(),
    instanceName: faker.person.fullName(),
    version: faker.lorem.words(),
    buildTime: faker.date.past(),
    isDebug: faker.datatype.boolean(),
    isProduction: faker.datatype.boolean(),
    isAdmin: faker.datatype.boolean(),
    isUserInteractive: faker.datatype.boolean(),
    startupPath: faker.lorem.words(),
    appData: faker.lorem.words(),
    osName: faker.person.fullName(),
    osVersion: faker.lorem.words(),
    isNetCore: faker.datatype.boolean(),
    isLinux: faker.datatype.boolean(),
    isOsx: faker.datatype.boolean(),
    isWindows: faker.datatype.boolean(),
    isDocker: faker.datatype.boolean(),
    mode: faker.helpers.arrayElement(['console', 'service', 'tray']),
    branch: faker.lorem.words(),
    authentication: faker.helpers.arrayElement([
      'none',
      'basic',
      'forms',
      'external',
    ]),
    sqliteVersion: faker.lorem.words(),
    migrationVersion: faker.number.int(),
    urlBase: faker.internet.url(),
    runtimeVersion: faker.lorem.words(),
    runtimeName: faker.person.fullName(),
    startTime: faker.date.past(),
    packageVersion: faker.lorem.words(),
    packageAuthor: faker.lorem.words(),
    packageUpdateMechanism: faker.helpers.arrayElement([
      'builtIn',
      'script',
      'external',
      'apt',
      'docker',
    ]),
    packageUpdateMechanismMessage: faker.lorem.words(),
    databaseVersion: faker.lorem.words(),
    databaseType: faker.helpers.arrayElement(['sqLite', 'postgreSQL']),
  }
}

export function getGetApiV3Tag200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    label: faker.lorem.words(),
  }))
}

export function getPostApiV3Tag200Response() {
  return {
    id: faker.number.int(),
    label: faker.lorem.words(),
  }
}

export function getPutApiV3TagId200Response() {
  return {
    id: faker.number.int(),
    label: faker.lorem.words(),
  }
}

export function getGetApiV3TagId200Response() {
  return {
    id: faker.number.int(),
    label: faker.lorem.words(),
  }
}

export function getGetApiV3TagDetail200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    label: faker.lorem.words(),
    delayProfileIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    importListIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    notificationIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    restrictionIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    indexerIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    downloadClientIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    autoTagIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    seriesIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }))
}

export function getGetApiV3TagDetailId200Response() {
  return {
    id: faker.number.int(),
    label: faker.lorem.words(),
    delayProfileIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    importListIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    notificationIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    restrictionIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    indexerIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    downloadClientIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    autoTagIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    seriesIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3SystemTask200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    taskName: faker.person.fullName(),
    interval: faker.number.int(),
    lastExecution: faker.date.past(),
    lastStartTime: faker.date.past(),
    nextExecution: faker.date.past(),
    lastDuration: faker.lorem.words(),
  }))
}

export function getGetApiV3SystemTaskId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    taskName: faker.person.fullName(),
    interval: faker.number.int(),
    lastExecution: faker.date.past(),
    lastStartTime: faker.date.past(),
    nextExecution: faker.date.past(),
    lastDuration: faker.lorem.words(),
  }
}

export function getPutApiV3ConfigUiId200Response() {
  return {
    id: faker.number.int(),
    firstDayOfWeek: faker.number.int(),
    calendarWeekColumnHeader: faker.lorem.words(),
    shortDateFormat: faker.lorem.words(),
    longDateFormat: faker.lorem.words(),
    timeFormat: faker.lorem.words(),
    showRelativeDates: faker.datatype.boolean(),
    enableColorImpairedMode: faker.datatype.boolean(),
    theme: faker.lorem.words(),
    uiLanguage: faker.number.int(),
  }
}

export function getGetApiV3ConfigUiId200Response() {
  return {
    id: faker.number.int(),
    firstDayOfWeek: faker.number.int(),
    calendarWeekColumnHeader: faker.lorem.words(),
    shortDateFormat: faker.lorem.words(),
    longDateFormat: faker.lorem.words(),
    timeFormat: faker.lorem.words(),
    showRelativeDates: faker.datatype.boolean(),
    enableColorImpairedMode: faker.datatype.boolean(),
    theme: faker.lorem.words(),
    uiLanguage: faker.number.int(),
  }
}

export function getGetApiV3ConfigUi200Response() {
  return {
    id: faker.number.int(),
    firstDayOfWeek: faker.number.int(),
    calendarWeekColumnHeader: faker.lorem.words(),
    shortDateFormat: faker.lorem.words(),
    longDateFormat: faker.lorem.words(),
    timeFormat: faker.lorem.words(),
    showRelativeDates: faker.datatype.boolean(),
    enableColorImpairedMode: faker.datatype.boolean(),
    theme: faker.lorem.words(),
    uiLanguage: faker.number.int(),
  }
}

export function getGetApiV3Update200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    version: faker.lorem.words(),
    branch: faker.lorem.words(),
    releaseDate: faker.date.past(),
    fileName: faker.person.fullName(),
    url: faker.internet.url(),
    installed: faker.datatype.boolean(),
    installedOn: faker.date.past(),
    installable: faker.datatype.boolean(),
    latest: faker.datatype.boolean(),
    changes: {
      new: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      fixed: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
    hash: faker.lorem.words(),
  }))
}

export function getGetApiV3LogFileUpdate200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    filename: faker.person.fullName(),
    lastWriteTime: faker.date.past(),
    contentsUrl: faker.internet.url(),
    downloadUrl: faker.internet.url(),
  }))
}
