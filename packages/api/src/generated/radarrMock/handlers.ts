/**
 * This file is AUTO GENERATED by [msw-auto-mock](https://github.com/zoubingwu/msw-auto-mock)
 * Feel free to commit/edit it as you need.
 */
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
import { HttpResponse, http } from 'msw'
import { faker } from '@faker-js/faker'

faker.seed(1)

const baseURL = 'http://localhost:3003'
const MAX_ARRAY_LENGTH = 20

// Map to store counters for each API endpoint
const apiCounters = new Map<string, number>()

const next = (apiKey: string) => {
  let currentCount = apiCounters.get(apiKey) ?? 0
  if (currentCount === Number.MAX_SAFE_INTEGER - 1) {
    currentCount = 0
  }
  apiCounters.set(apiKey, currentCount + 1)
  return currentCount
}

export const handlers = [
  http.get(`${baseURL}/api/v3/alttitle`, async () => {
    const resultArray = [
      [getGetApiV3Alttitle200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/alttitle`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/alttitle/:id`, async () => {
    const resultArray = [
      [getGetApiV3AlttitleId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/alttitle/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api`, async () => {
    const resultArray = [[getGetApi200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/login`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /login`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/login`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /login`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/logout`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /logout`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/autotagging`, async () => {
    const resultArray = [
      [getPostApiV3Autotagging200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/autotagging`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/autotagging`, async () => {
    const resultArray = [
      [getGetApiV3Autotagging200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/autotagging`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/autotagging/:id`, async () => {
    const resultArray = [
      [getPutApiV3AutotaggingId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/autotagging/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/autotagging/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/autotagging/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/autotagging/:id`, async () => {
    const resultArray = [
      [getGetApiV3AutotaggingId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/autotagging/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/autotagging/schema`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/autotagging/schema`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/system/backup`, async () => {
    const resultArray = [
      [getGetApiV3SystemBackup200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/system/backup`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/system/backup/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/system/backup/:id`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/system/backup/restore/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/system/backup/restore/:id`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/system/backup/restore/upload`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/system/backup/restore/upload`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/blocklist`, async () => {
    const resultArray = [
      [getGetApiV3Blocklist200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/blocklist`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/blocklist/movie`, async () => {
    const resultArray = [
      [getGetApiV3BlocklistMovie200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/blocklist/movie`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/blocklist/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/blocklist/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/blocklist/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/blocklist/bulk`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/calendar`, async () => {
    const resultArray = [
      [getGetApiV3Calendar200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/calendar`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/feed/v3/calendar/radarr.ics`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /feed/v3/calendar/radarr.ics`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/collection`, async () => {
    const resultArray = [
      [getGetApiV3Collection200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/collection`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/collection`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/collection`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/collection/:id`, async () => {
    const resultArray = [
      [getPutApiV3CollectionId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/collection/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/collection/:id`, async () => {
    const resultArray = [
      [getGetApiV3CollectionId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/collection/:id`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/command`, async () => {
    const resultArray = [
      [getPostApiV3Command200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/command`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/command`, async () => {
    const resultArray = [
      [getGetApiV3Command200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/command`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/command/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/command/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/command/:id`, async () => {
    const resultArray = [
      [getGetApiV3CommandId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/command/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/credit`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/credit`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/credit/:id`, async () => {
    const resultArray = [
      [getGetApiV3CreditId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/credit/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/customfilter`, async () => {
    const resultArray = [
      [getGetApiV3Customfilter200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/customfilter`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/customfilter`, async () => {
    const resultArray = [
      [getPostApiV3Customfilter200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/customfilter`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/customfilter/:id`, async () => {
    const resultArray = [
      [getPutApiV3CustomfilterId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/customfilter/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/customfilter/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/customfilter/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/customfilter/:id`, async () => {
    const resultArray = [
      [getGetApiV3CustomfilterId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/customfilter/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/customformat`, async () => {
    const resultArray = [
      [getGetApiV3Customformat200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/customformat`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/customformat`, async () => {
    const resultArray = [
      [getPostApiV3Customformat200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/customformat`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/customformat/:id`, async () => {
    const resultArray = [
      [getPutApiV3CustomformatId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/customformat/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/customformat/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/customformat/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/customformat/:id`, async () => {
    const resultArray = [
      [getGetApiV3CustomformatId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/customformat/:id`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/customformat/bulk`, async () => {
    const resultArray = [
      [getPutApiV3CustomformatBulk200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/customformat/bulk`) % resultArray.length
      ],
    )
  }),
  http.delete(`${baseURL}/api/v3/customformat/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/customformat/bulk`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/customformat/schema`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/customformat/schema`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/wanted/cutoff`, async () => {
    const resultArray = [
      [getGetApiV3WantedCutoff200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/wanted/cutoff`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/delayprofile`, async () => {
    const resultArray = [
      [getPostApiV3Delayprofile200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/delayprofile`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/delayprofile`, async () => {
    const resultArray = [
      [getGetApiV3Delayprofile200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/delayprofile`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/delayprofile/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/delayprofile/:id`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/delayprofile/:id`, async () => {
    const resultArray = [
      [getPutApiV3DelayprofileId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/delayprofile/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/delayprofile/:id`, async () => {
    const resultArray = [
      [getGetApiV3DelayprofileId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/delayprofile/:id`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/delayprofile/reorder/:id`, async () => {
    const resultArray = [
      [getPutApiV3DelayprofileReorderId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/delayprofile/reorder/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/diskspace`, async () => {
    const resultArray = [
      [getGetApiV3Diskspace200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/diskspace`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/downloadclient`, async () => {
    const resultArray = [
      [getGetApiV3Downloadclient200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/downloadclient`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/downloadclient`, async () => {
    const resultArray = [
      [getPostApiV3Downloadclient200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/downloadclient`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/downloadclient/:id`, async () => {
    const resultArray = [
      [getPutApiV3DownloadclientId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/downloadclient/:id`) % resultArray.length
      ],
    )
  }),
  http.delete(`${baseURL}/api/v3/downloadclient/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/downloadclient/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/downloadclient/:id`, async () => {
    const resultArray = [
      [getGetApiV3DownloadclientId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/downloadclient/:id`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/downloadclient/bulk`, async () => {
    const resultArray = [
      [getPutApiV3DownloadclientBulk200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/downloadclient/bulk`) % resultArray.length
      ],
    )
  }),
  http.delete(`${baseURL}/api/v3/downloadclient/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/downloadclient/bulk`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/downloadclient/schema`, async () => {
    const resultArray = [
      [getGetApiV3DownloadclientSchema200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/downloadclient/schema`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/downloadclient/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/downloadclient/test`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/downloadclient/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/downloadclient/testall`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/downloadclient/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/downloadclient/action/:name`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/downloadclient`, async () => {
    const resultArray = [
      [getGetApiV3ConfigDownloadclient200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/downloadclient`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/config/downloadclient/:id`, async () => {
    const resultArray = [
      [getPutApiV3ConfigDownloadclientId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/config/downloadclient/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/downloadclient/:id`, async () => {
    const resultArray = [
      [getGetApiV3ConfigDownloadclientId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/downloadclient/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/extrafile`, async () => {
    const resultArray = [
      [getGetApiV3Extrafile200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/extrafile`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/filesystem`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/filesystem`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/filesystem/type`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/filesystem/type`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/filesystem/mediafiles`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/filesystem/mediafiles`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/health`, async () => {
    const resultArray = [[getGetApiV3Health200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/health`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/history`, async () => {
    const resultArray = [
      [getGetApiV3History200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/history`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/history/since`, async () => {
    const resultArray = [
      [getGetApiV3HistorySince200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/history/since`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/history/movie`, async () => {
    const resultArray = [
      [getGetApiV3HistoryMovie200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/history/movie`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/history/failed/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/history/failed/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/host`, async () => {
    const resultArray = [
      [getGetApiV3ConfigHost200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/config/host`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/config/host/:id`, async () => {
    const resultArray = [
      [getPutApiV3ConfigHostId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/config/host/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/config/host/:id`, async () => {
    const resultArray = [
      [getGetApiV3ConfigHostId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/config/host/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/importlist`, async () => {
    const resultArray = [
      [getGetApiV3Importlist200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/importlist`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/importlist`, async () => {
    const resultArray = [
      [getPostApiV3Importlist200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/importlist`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/importlist/:id`, async () => {
    const resultArray = [
      [getPutApiV3ImportlistId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/importlist/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/importlist/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/importlist/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/importlist/:id`, async () => {
    const resultArray = [
      [getGetApiV3ImportlistId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/importlist/:id`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/importlist/bulk`, async () => {
    const resultArray = [
      [getPutApiV3ImportlistBulk200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/importlist/bulk`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/importlist/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/importlist/bulk`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/importlist/schema`, async () => {
    const resultArray = [
      [getGetApiV3ImportlistSchema200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/importlist/schema`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/importlist/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/importlist/test`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/importlist/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/importlist/testall`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/importlist/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/importlist/action/:name`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/importlist`, async () => {
    const resultArray = [
      [getGetApiV3ConfigImportlist200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/importlist`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/config/importlist/:id`, async () => {
    const resultArray = [
      [getPutApiV3ConfigImportlistId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/config/importlist/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/importlist/:id`, async () => {
    const resultArray = [
      [getGetApiV3ConfigImportlistId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/importlist/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/exclusions`, async () => {
    const resultArray = [
      [getGetApiV3Exclusions200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/exclusions`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/exclusions`, async () => {
    const resultArray = [
      [getPostApiV3Exclusions200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/exclusions`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/exclusions/paged`, async () => {
    const resultArray = [
      [getGetApiV3ExclusionsPaged200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/exclusions/paged`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/exclusions/:id`, async () => {
    const resultArray = [
      [getPutApiV3ExclusionsId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/exclusions/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/exclusions/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/exclusions/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/exclusions/:id`, async () => {
    const resultArray = [
      [getGetApiV3ExclusionsId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/exclusions/:id`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/exclusions/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/exclusions/bulk`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/exclusions/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/exclusions/bulk`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/importlist/movie`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/importlist/movie`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/importlist/movie`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/importlist/movie`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/indexer`, async () => {
    const resultArray = [
      [getGetApiV3Indexer200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/indexer`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/indexer`, async () => {
    const resultArray = [
      [getPostApiV3Indexer200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/indexer`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/indexer/:id`, async () => {
    const resultArray = [
      [getPutApiV3IndexerId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/indexer/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/indexer/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/indexer/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/indexer/:id`, async () => {
    const resultArray = [
      [getGetApiV3IndexerId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/indexer/:id`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/indexer/bulk`, async () => {
    const resultArray = [
      [getPutApiV3IndexerBulk200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/indexer/bulk`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/indexer/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/indexer/bulk`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/indexer/schema`, async () => {
    const resultArray = [
      [getGetApiV3IndexerSchema200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/indexer/schema`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/indexer/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/indexer/test`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/indexer/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/indexer/testall`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/indexer/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/indexer/action/:name`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/indexer`, async () => {
    const resultArray = [
      [getGetApiV3ConfigIndexer200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/config/indexer`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/config/indexer/:id`, async () => {
    const resultArray = [
      [getPutApiV3ConfigIndexerId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/config/indexer/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/indexer/:id`, async () => {
    const resultArray = [
      [getGetApiV3ConfigIndexerId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/indexer/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/indexerflag`, async () => {
    const resultArray = [
      [getGetApiV3Indexerflag200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/indexerflag`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/language`, async () => {
    const resultArray = [
      [getGetApiV3Language200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/language`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/language/:id`, async () => {
    const resultArray = [
      [getGetApiV3LanguageId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/language/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/localization`, async () => {
    const resultArray = [
      [getGetApiV3Localization200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/localization`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/localization/language`, async () => {
    const resultArray = [
      [getGetApiV3LocalizationLanguage200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/localization/language`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/log`, async () => {
    const resultArray = [[getGetApiV3Log200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/log`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/log/file`, async () => {
    const resultArray = [
      [getGetApiV3LogFile200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/log/file`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/log/file/:filename`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/log/file/:filename`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/manualimport`, async () => {
    const resultArray = [
      [getGetApiV3Manualimport200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/manualimport`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/manualimport`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/manualimport`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/mediacover/:movieId/:filename`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/mediacover/:movieId/:filename`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/mediamanagement`, async () => {
    const resultArray = [
      [getGetApiV3ConfigMediamanagement200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/mediamanagement`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/config/mediamanagement/:id`, async () => {
    const resultArray = [
      [getPutApiV3ConfigMediamanagementId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/config/mediamanagement/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/mediamanagement/:id`, async () => {
    const resultArray = [
      [getGetApiV3ConfigMediamanagementId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/mediamanagement/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/metadata`, async () => {
    const resultArray = [
      [getGetApiV3Metadata200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/metadata`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/metadata`, async () => {
    const resultArray = [
      [getPostApiV3Metadata200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/metadata`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/metadata/:id`, async () => {
    const resultArray = [
      [getPutApiV3MetadataId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/metadata/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/metadata/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/metadata/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/metadata/:id`, async () => {
    const resultArray = [
      [getGetApiV3MetadataId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/metadata/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/metadata/schema`, async () => {
    const resultArray = [
      [getGetApiV3MetadataSchema200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/metadata/schema`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/metadata/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/metadata/test`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/metadata/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/metadata/testall`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/metadata/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/metadata/action/:name`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/metadata`, async () => {
    const resultArray = [
      [getGetApiV3ConfigMetadata200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/config/metadata`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/config/metadata/:id`, async () => {
    const resultArray = [
      [getPutApiV3ConfigMetadataId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/config/metadata/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/metadata/:id`, async () => {
    const resultArray = [
      [getGetApiV3ConfigMetadataId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/metadata/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/wanted/missing`, async () => {
    const resultArray = [
      [getGetApiV3WantedMissing200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/wanted/missing`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/movie`, async () => {
    const resultArray = [[getGetApiV3Movie200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/movie`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/movie`, async () => {
    const resultArray = [[getPostApiV3Movie200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/movie`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/movie/:id`, async () => {
    const resultArray = [
      [getPutApiV3MovieId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/movie/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/movie/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/movie/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/movie/:id`, async () => {
    const resultArray = [
      [getGetApiV3MovieId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/movie/:id`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/movie/editor`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/movie/editor`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/movie/editor`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/movie/editor`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/moviefile`, async () => {
    const resultArray = [
      [getGetApiV3Moviefile200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/moviefile`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/moviefile/:id`, async () => {
    const resultArray = [
      [getPutApiV3MoviefileId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/moviefile/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/moviefile/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/moviefile/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/moviefile/:id`, async () => {
    const resultArray = [
      [getGetApiV3MoviefileId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/moviefile/:id`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/moviefile/editor`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/moviefile/editor`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/moviefile/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/moviefile/bulk`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/moviefile/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/moviefile/bulk`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/movie/:id/folder`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/movie/:id/folder`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/movie/import`, async () => {
    const resultArray = [
      [getPostApiV3MovieImport200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/movie/import`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/movie/lookup/tmdb`, async () => {
    const resultArray = [
      [getGetApiV3MovieLookupTmdb200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/movie/lookup/tmdb`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/movie/lookup/imdb`, async () => {
    const resultArray = [
      [getGetApiV3MovieLookupImdb200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/movie/lookup/imdb`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/movie/lookup`, async () => {
    const resultArray = [
      [getGetApiV3MovieLookup200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/movie/lookup`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/config/naming`, async () => {
    const resultArray = [
      [getGetApiV3ConfigNaming200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/config/naming`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/config/naming/:id`, async () => {
    const resultArray = [
      [getPutApiV3ConfigNamingId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/config/naming/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/naming/:id`, async () => {
    const resultArray = [
      [getGetApiV3ConfigNamingId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/naming/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/config/naming/examples`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/config/naming/examples`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/notification`, async () => {
    const resultArray = [
      [getGetApiV3Notification200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/notification`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/notification`, async () => {
    const resultArray = [
      [getPostApiV3Notification200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/notification`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/notification/:id`, async () => {
    const resultArray = [
      [getPutApiV3NotificationId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/notification/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/notification/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/notification/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/notification/:id`, async () => {
    const resultArray = [
      [getGetApiV3NotificationId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/notification/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/notification/schema`, async () => {
    const resultArray = [
      [getGetApiV3NotificationSchema200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/notification/schema`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/notification/test`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/notification/test`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/notification/testall`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/notification/testall`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/notification/action/:name`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/notification/action/:name`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/parse`, async () => {
    const resultArray = [[getGetApiV3Parse200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/parse`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/ping`, async () => {
    const resultArray = [[getGetPing200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /ping`) % resultArray.length],
    )
  }),
  http.head(`${baseURL}/ping`, async () => {
    const resultArray = [[getHeadPing200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`head /ping`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/qualitydefinition/:id`, async () => {
    const resultArray = [
      [getPutApiV3QualitydefinitionId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/qualitydefinition/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/qualitydefinition/:id`, async () => {
    const resultArray = [
      [getGetApiV3QualitydefinitionId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/qualitydefinition/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/qualitydefinition`, async () => {
    const resultArray = [
      [getGetApiV3Qualitydefinition200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/qualitydefinition`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/qualitydefinition/update`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/qualitydefinition/update`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/qualityprofile`, async () => {
    const resultArray = [
      [getPostApiV3Qualityprofile200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/qualityprofile`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/qualityprofile`, async () => {
    const resultArray = [
      [getGetApiV3Qualityprofile200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/qualityprofile`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/qualityprofile/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/qualityprofile/:id`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/qualityprofile/:id`, async () => {
    const resultArray = [
      [getPutApiV3QualityprofileId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/qualityprofile/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/qualityprofile/:id`, async () => {
    const resultArray = [
      [getGetApiV3QualityprofileId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/qualityprofile/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/qualityprofile/schema`, async () => {
    const resultArray = [
      [getGetApiV3QualityprofileSchema200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/qualityprofile/schema`) % resultArray.length
      ],
    )
  }),
  http.delete(`${baseURL}/api/v3/queue/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/queue/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/queue/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/queue/bulk`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/queue`, async () => {
    const resultArray = [[getGetApiV3Queue200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/queue`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/queue/grab/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/queue/grab/:id`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/queue/grab/bulk`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/queue/grab/bulk`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/queue/details`, async () => {
    const resultArray = [
      [getGetApiV3QueueDetails200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/queue/details`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/queue/status`, async () => {
    const resultArray = [
      [getGetApiV3QueueStatus200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/queue/status`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/release`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/release`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/release`, async () => {
    const resultArray = [
      [getGetApiV3Release200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/release`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/releaseprofile`, async () => {
    const resultArray = [
      [getPostApiV3Releaseprofile200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/releaseprofile`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/releaseprofile`, async () => {
    const resultArray = [
      [getGetApiV3Releaseprofile200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/releaseprofile`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/releaseprofile/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/releaseprofile/:id`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/releaseprofile/:id`, async () => {
    const resultArray = [
      [getPutApiV3ReleaseprofileId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/releaseprofile/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/releaseprofile/:id`, async () => {
    const resultArray = [
      [getGetApiV3ReleaseprofileId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/releaseprofile/:id`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/release/push`, async () => {
    const resultArray = [
      [getPostApiV3ReleasePush200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/release/push`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/remotepathmapping`, async () => {
    const resultArray = [
      [getPostApiV3Remotepathmapping200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`post /api/v3/remotepathmapping`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/remotepathmapping`, async () => {
    const resultArray = [
      [getGetApiV3Remotepathmapping200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/remotepathmapping`) % resultArray.length
      ],
    )
  }),
  http.delete(`${baseURL}/api/v3/remotepathmapping/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/remotepathmapping/:id`) % resultArray.length
      ],
    )
  }),
  http.put(`${baseURL}/api/v3/remotepathmapping/:id`, async () => {
    const resultArray = [
      [getPutApiV3RemotepathmappingId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`put /api/v3/remotepathmapping/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/remotepathmapping/:id`, async () => {
    const resultArray = [
      [getGetApiV3RemotepathmappingId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/remotepathmapping/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/rename`, async () => {
    const resultArray = [[getGetApiV3Rename200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/rename`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/rootfolder`, async () => {
    const resultArray = [
      [getPostApiV3Rootfolder200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/rootfolder`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/rootfolder`, async () => {
    const resultArray = [
      [getGetApiV3Rootfolder200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/rootfolder`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/rootfolder/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`delete /api/v3/rootfolder/:id`) % resultArray.length
      ],
    )
  }),
  http.get(`${baseURL}/api/v3/rootfolder/:id`, async () => {
    const resultArray = [
      [getGetApiV3RootfolderId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/rootfolder/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/content/:path`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /content/:path`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(...resultArray[next(`get /`) % resultArray.length])
  }),
  http.get(`${baseURL}/:path`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /:path`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/system/status`, async () => {
    const resultArray = [
      [getGetApiV3SystemStatus200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/system/status`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/system/routes`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/system/routes`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/system/routes/duplicate`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/system/routes/duplicate`) % resultArray.length
      ],
    )
  }),
  http.post(`${baseURL}/api/v3/system/shutdown`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/system/shutdown`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/system/restart`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/system/restart`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/tag`, async () => {
    const resultArray = [[getGetApiV3Tag200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/tag`) % resultArray.length],
    )
  }),
  http.post(`${baseURL}/api/v3/tag`, async () => {
    const resultArray = [[getPostApiV3Tag200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`post /api/v3/tag`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/tag/:id`, async () => {
    const resultArray = [[getPutApiV3TagId200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/tag/:id`) % resultArray.length],
    )
  }),
  http.delete(`${baseURL}/api/v3/tag/:id`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`delete /api/v3/tag/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/tag/:id`, async () => {
    const resultArray = [[getGetApiV3TagId200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/tag/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/tag/detail`, async () => {
    const resultArray = [
      [getGetApiV3TagDetail200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/tag/detail`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/tag/detail/:id`, async () => {
    const resultArray = [
      [getGetApiV3TagDetailId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/tag/detail/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/system/task`, async () => {
    const resultArray = [
      [getGetApiV3SystemTask200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/system/task`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/system/task/:id`, async () => {
    const resultArray = [
      [getGetApiV3SystemTaskId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/system/task/:id`) % resultArray.length],
    )
  }),
  http.put(`${baseURL}/api/v3/config/ui/:id`, async () => {
    const resultArray = [
      [getPutApiV3ConfigUiId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`put /api/v3/config/ui/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/config/ui/:id`, async () => {
    const resultArray = [
      [getGetApiV3ConfigUiId200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/config/ui/:id`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/config/ui`, async () => {
    const resultArray = [
      [getGetApiV3ConfigUi200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/config/ui`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/update`, async () => {
    const resultArray = [[getGetApiV3Update200Response(), { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/update`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/log/file/update`, async () => {
    const resultArray = [
      [getGetApiV3LogFileUpdate200Response(), { status: 200 }],
    ] as [any, { status: number }][]

    return HttpResponse.json(
      ...resultArray[next(`get /api/v3/log/file/update`) % resultArray.length],
    )
  }),
  http.get(`${baseURL}/api/v3/log/file/update/:filename`, async () => {
    const resultArray = [[undefined, { status: 200 }]] as [
      any,
      { status: number },
    ][]

    return HttpResponse.json(
      ...resultArray[
        next(`get /api/v3/log/file/update/:filename`) % resultArray.length
      ],
    )
  }),
]

export function getGetApiV3Alttitle200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    sourceType: faker.helpers.arrayElement([
      'tmdb',
      'mappings',
      'user',
      'indexer',
    ]),
    movieMetadataId: faker.number.int(),
    title: faker.lorem.words(),
    cleanTitle: faker.lorem.words(),
  }))
}

export function getGetApiV3AlttitleId200Response() {
  return {
    id: faker.number.int(),
    sourceType: faker.helpers.arrayElement([
      'tmdb',
      'mappings',
      'user',
      'indexer',
    ]),
    movieMetadataId: faker.number.int(),
    title: faker.lorem.words(),
    cleanTitle: faker.lorem.words(),
  }
}

export function getGetApi200Response() {
  return {
    current: faker.lorem.words(),
    deprecated: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
  }
}

export function getPostApiV3Autotagging200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    removeTagsAutomatically: faker.datatype.boolean(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
    })),
  }
}

export function getGetApiV3Autotagging200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    removeTagsAutomatically: faker.datatype.boolean(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
    })),
  }))
}

export function getPutApiV3AutotaggingId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    removeTagsAutomatically: faker.datatype.boolean(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
    })),
  }
}

export function getGetApiV3AutotaggingId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    removeTagsAutomatically: faker.datatype.boolean(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
    })),
  }
}

export function getGetApiV3SystemBackup200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    path: faker.lorem.words(),
    type: faker.helpers.arrayElement(['scheduled', 'manual', 'update']),
    size: faker.number.int(),
    time: faker.date.past(),
  }))
}

export function getGetApiV3Blocklist200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      movieId: faker.number.int(),
      sourceTitle: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      date: faker.date.past(),
      protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
      indexer: faker.lorem.words(),
      message: faker.lorem.words(),
      movie: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        originalTitle: faker.lorem.words(),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          sourceType: faker.helpers.arrayElement([
            'tmdb',
            'mappings',
            'user',
            'indexer',
          ]),
          movieMetadataId: faker.number.int(),
          title: faker.lorem.words(),
          cleanTitle: faker.lorem.words(),
        })),
        secondaryYear: faker.number.int(),
        secondaryYearSourceId: faker.number.int(),
        sortTitle: faker.lorem.words(),
        sizeOnDisk: faker.number.int(),
        status: faker.helpers.arrayElement([
          'tba',
          'announced',
          'inCinemas',
          'released',
          'deleted',
        ]),
        overview: faker.lorem.words(),
        inCinemas: faker.date.past(),
        physicalRelease: faker.date.past(),
        digitalRelease: faker.date.past(),
        releaseDate: faker.date.past(),
        physicalReleaseNote: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        website: faker.lorem.words(),
        remotePoster: faker.lorem.words(),
        year: faker.number.int(),
        youTubeTrailerId: faker.string.uuid(),
        studio: faker.lorem.words(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        hasFile: faker.datatype.boolean(),
        movieFileId: faker.number.int(),
        monitored: faker.datatype.boolean(),
        minimumAvailability: faker.helpers.arrayElement([
          'tba',
          'announced',
          'inCinemas',
          'released',
          'deleted',
        ]),
        isAvailable: faker.datatype.boolean(),
        folderName: faker.person.fullName(),
        runtime: faker.number.int(),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        tmdbId: faker.number.int(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'movieOnly',
            'movieAndCollection',
            'none',
          ]),
          searchForMovie: faker.datatype.boolean(),
          addMethod: faker.helpers.arrayElement([
            'manual',
            'list',
            'collection',
          ]),
        },
        ratings: {
          imdb: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          tmdb: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          metacritic: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          rottenTomatoes: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          trakt: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
        },
        movieFile: {
          id: faker.number.int(),
          movieId: faker.number.int(),
          relativePath: faker.lorem.words(),
          path: faker.lorem.words(),
          size: faker.number.int(),
          dateAdded: faker.date.past(),
          sceneName: faker.person.fullName(),
          releaseGroup: faker.lorem.words(),
          edition: faker.lorem.words(),
          languages: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
          })),
          quality: {
            quality: {
              id: faker.number.int(),
              name: faker.person.fullName(),
              source: faker.helpers.arrayElement([
                'unknown',
                'cam',
                'telesync',
                'telecine',
                'workprint',
                'dvd',
                'tv',
                'webdl',
                'webrip',
                'bluray',
              ]),
              resolution: faker.number.int(),
              modifier: faker.helpers.arrayElement([
                'none',
                'regional',
                'screener',
                'rawhd',
                'brdisk',
                'remux',
              ]),
            },
            revision: {
              version: faker.number.int(),
              real: faker.number.int(),
              isRepack: faker.datatype.boolean(),
            },
          },
          customFormats: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            includeCustomFormatWhenRenaming: faker.datatype.boolean(),
            specifications: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              id: faker.number.int(),
              name: faker.person.fullName(),
              implementation: faker.lorem.words(),
              implementationName: faker.person.fullName(),
              infoLink: faker.lorem.words(),
              negate: faker.datatype.boolean(),
              required: faker.datatype.boolean(),
              fields: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                order: faker.number.int(),
                name: faker.person.fullName(),
                label: faker.lorem.words(),
                unit: faker.lorem.words(),
                helpText: faker.lorem.words(),
                helpTextWarning: faker.lorem.words(),
                helpLink: faker.lorem.words(),
                value: null,
                type: faker.lorem.words(),
                advanced: faker.datatype.boolean(),
                selectOptions: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => ({
                  value: faker.number.int(),
                  name: faker.person.fullName(),
                  order: faker.number.int(),
                  hint: faker.lorem.words(),
                  dividerAfter: faker.datatype.boolean(),
                })),
                selectOptionsProviderAction: faker.lorem.words(),
                section: faker.lorem.words(),
                hidden: faker.lorem.words(),
                privacy: faker.helpers.arrayElement([
                  'normal',
                  'password',
                  'apiKey',
                  'userName',
                ]),
                placeholder: faker.lorem.words(),
                isFloat: faker.datatype.boolean(),
              })),
              presets: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => null),
            })),
          })),
          customFormatScore: faker.number.int(),
          indexerFlags: faker.number.int(),
          mediaInfo: {
            id: faker.number.int(),
            audioBitrate: faker.number.int(),
            audioChannels: faker.number.int(),
            audioCodec: faker.lorem.words(),
            audioLanguages: faker.lorem.words(),
            audioStreamCount: faker.number.int(),
            videoBitDepth: faker.number.int(),
            videoBitrate: faker.number.int(),
            videoCodec: faker.lorem.words(),
            videoFps: faker.number.int(),
            videoDynamicRange: faker.lorem.words(),
            videoDynamicRangeType: faker.lorem.words(),
            resolution: faker.lorem.words(),
            runTime: faker.lorem.words(),
            scanType: faker.lorem.words(),
            subtitles: faker.lorem.words(),
          },
          originalFilePath: faker.lorem.words(),
          qualityCutoffNotMet: faker.datatype.boolean(),
        },
        collection: {
          title: faker.lorem.words(),
          tmdbId: faker.number.int(),
        },
        popularity: faker.number.int(),
        lastSearchTime: faker.date.past(),
        statistics: {
          movieFileCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
        },
      },
    })),
  }
}

export function getGetApiV3BlocklistMovie200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    movieId: faker.number.int(),
    sourceTitle: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    date: faker.date.past(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    indexer: faker.lorem.words(),
    message: faker.lorem.words(),
    movie: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        sourceType: faker.helpers.arrayElement([
          'tmdb',
          'mappings',
          'user',
          'indexer',
        ]),
        movieMetadataId: faker.number.int(),
        title: faker.lorem.words(),
        cleanTitle: faker.lorem.words(),
      })),
      secondaryYear: faker.number.int(),
      secondaryYearSourceId: faker.number.int(),
      sortTitle: faker.lorem.words(),
      sizeOnDisk: faker.number.int(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      inCinemas: faker.date.past(),
      physicalRelease: faker.date.past(),
      digitalRelease: faker.date.past(),
      releaseDate: faker.date.past(),
      physicalReleaseNote: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      website: faker.lorem.words(),
      remotePoster: faker.lorem.words(),
      year: faker.number.int(),
      youTubeTrailerId: faker.string.uuid(),
      studio: faker.lorem.words(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      hasFile: faker.datatype.boolean(),
      movieFileId: faker.number.int(),
      monitored: faker.datatype.boolean(),
      minimumAvailability: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      isAvailable: faker.datatype.boolean(),
      folderName: faker.person.fullName(),
      runtime: faker.number.int(),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      tmdbId: faker.number.int(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'movieOnly',
          'movieAndCollection',
          'none',
        ]),
        searchForMovie: faker.datatype.boolean(),
        addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
      },
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      movieFile: {
        id: faker.number.int(),
        movieId: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        edition: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'cam',
              'telesync',
              'telecine',
              'workprint',
              'dvd',
              'tv',
              'webdl',
              'webrip',
              'bluray',
            ]),
            resolution: faker.number.int(),
            modifier: faker.helpers.arrayElement([
              'none',
              'regional',
              'screener',
              'rawhd',
              'brdisk',
              'remux',
            ]),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
                dividerAfter: faker.datatype.boolean(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        originalFilePath: faker.lorem.words(),
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      collection: {
        title: faker.lorem.words(),
        tmdbId: faker.number.int(),
      },
      popularity: faker.number.int(),
      lastSearchTime: faker.date.past(),
      statistics: {
        movieFileCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      },
    },
  }))
}

export function getGetApiV3Calendar200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    title: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      sourceType: faker.helpers.arrayElement([
        'tmdb',
        'mappings',
        'user',
        'indexer',
      ]),
      movieMetadataId: faker.number.int(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
    })),
    secondaryYear: faker.number.int(),
    secondaryYearSourceId: faker.number.int(),
    sortTitle: faker.lorem.words(),
    sizeOnDisk: faker.number.int(),
    status: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    overview: faker.lorem.words(),
    inCinemas: faker.date.past(),
    physicalRelease: faker.date.past(),
    digitalRelease: faker.date.past(),
    releaseDate: faker.date.past(),
    physicalReleaseNote: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    website: faker.lorem.words(),
    remotePoster: faker.lorem.words(),
    year: faker.number.int(),
    youTubeTrailerId: faker.string.uuid(),
    studio: faker.lorem.words(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    hasFile: faker.datatype.boolean(),
    movieFileId: faker.number.int(),
    monitored: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    isAvailable: faker.datatype.boolean(),
    folderName: faker.person.fullName(),
    runtime: faker.number.int(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    tmdbId: faker.number.int(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'movieOnly',
        'movieAndCollection',
        'none',
      ]),
      searchForMovie: faker.datatype.boolean(),
      addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
    },
    ratings: {
      imdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      tmdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      metacritic: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      rottenTomatoes: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      trakt: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
    },
    movieFile: {
      id: faker.number.int(),
      movieId: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      edition: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      originalFilePath: faker.lorem.words(),
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    collection: {
      title: faker.lorem.words(),
      tmdbId: faker.number.int(),
    },
    popularity: faker.number.int(),
    lastSearchTime: faker.date.past(),
    statistics: {
      movieFileCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
  }))
}

export function getGetApiV3Collection200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    title: faker.lorem.words(),
    sortTitle: faker.lorem.words(),
    tmdbId: faker.number.int(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    overview: faker.lorem.words(),
    monitored: faker.datatype.boolean(),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    searchOnAdd: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    movies: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      tmdbId: faker.number.int(),
      imdbId: faker.string.uuid(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      runtime: faker.number.int(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      year: faker.number.int(),
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      folder: faker.lorem.words(),
      isExisting: faker.datatype.boolean(),
      isExcluded: faker.datatype.boolean(),
    })),
    missingMovies: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }))
}

export function getPutApiV3CollectionId200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    sortTitle: faker.lorem.words(),
    tmdbId: faker.number.int(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    overview: faker.lorem.words(),
    monitored: faker.datatype.boolean(),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    searchOnAdd: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    movies: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      tmdbId: faker.number.int(),
      imdbId: faker.string.uuid(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      runtime: faker.number.int(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      year: faker.number.int(),
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      folder: faker.lorem.words(),
      isExisting: faker.datatype.boolean(),
      isExcluded: faker.datatype.boolean(),
    })),
    missingMovies: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3CollectionId200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    sortTitle: faker.lorem.words(),
    tmdbId: faker.number.int(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    overview: faker.lorem.words(),
    monitored: faker.datatype.boolean(),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    searchOnAdd: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    movies: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      tmdbId: faker.number.int(),
      imdbId: faker.string.uuid(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
      sortTitle: faker.lorem.words(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      runtime: faker.number.int(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      year: faker.number.int(),
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      folder: faker.lorem.words(),
      isExisting: faker.datatype.boolean(),
      isExcluded: faker.datatype.boolean(),
    })),
    missingMovies: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getPostApiV3Command200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    commandName: faker.person.fullName(),
    message: faker.lorem.words(),
    body: {
      sendUpdatesToClient: faker.datatype.boolean(),
      updateScheduledTask: faker.datatype.boolean(),
      completionMessage: faker.lorem.words(),
      requiresDiskAccess: faker.datatype.boolean(),
      isExclusive: faker.datatype.boolean(),
      isTypeExclusive: faker.datatype.boolean(),
      isLongRunning: faker.datatype.boolean(),
      name: faker.person.fullName(),
      lastExecutionTime: faker.date.past(),
      lastStartTime: faker.date.past(),
      trigger: faker.helpers.arrayElement([
        'unspecified',
        'manual',
        'scheduled',
      ]),
      suppressMessages: faker.datatype.boolean(),
      clientUserAgent: faker.lorem.words(),
    },
    priority: faker.helpers.arrayElement(['normal', 'high', 'low']),
    status: faker.helpers.arrayElement([
      'queued',
      'started',
      'completed',
      'failed',
      'aborted',
      'cancelled',
      'orphaned',
    ]),
    result: faker.helpers.arrayElement([
      'unknown',
      'successful',
      'unsuccessful',
    ]),
    queued: faker.date.past(),
    started: faker.date.past(),
    ended: faker.date.past(),
    duration: faker.lorem.words(),
    exception: faker.lorem.words(),
    trigger: faker.helpers.arrayElement(['unspecified', 'manual', 'scheduled']),
    clientUserAgent: faker.lorem.words(),
    stateChangeTime: faker.date.past(),
    sendUpdatesToClient: faker.datatype.boolean(),
    updateScheduledTask: faker.datatype.boolean(),
    lastExecutionTime: faker.date.past(),
  }
}

export function getGetApiV3Command200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    commandName: faker.person.fullName(),
    message: faker.lorem.words(),
    body: {
      sendUpdatesToClient: faker.datatype.boolean(),
      updateScheduledTask: faker.datatype.boolean(),
      completionMessage: faker.lorem.words(),
      requiresDiskAccess: faker.datatype.boolean(),
      isExclusive: faker.datatype.boolean(),
      isTypeExclusive: faker.datatype.boolean(),
      isLongRunning: faker.datatype.boolean(),
      name: faker.person.fullName(),
      lastExecutionTime: faker.date.past(),
      lastStartTime: faker.date.past(),
      trigger: faker.helpers.arrayElement([
        'unspecified',
        'manual',
        'scheduled',
      ]),
      suppressMessages: faker.datatype.boolean(),
      clientUserAgent: faker.lorem.words(),
    },
    priority: faker.helpers.arrayElement(['normal', 'high', 'low']),
    status: faker.helpers.arrayElement([
      'queued',
      'started',
      'completed',
      'failed',
      'aborted',
      'cancelled',
      'orphaned',
    ]),
    result: faker.helpers.arrayElement([
      'unknown',
      'successful',
      'unsuccessful',
    ]),
    queued: faker.date.past(),
    started: faker.date.past(),
    ended: faker.date.past(),
    duration: faker.lorem.words(),
    exception: faker.lorem.words(),
    trigger: faker.helpers.arrayElement(['unspecified', 'manual', 'scheduled']),
    clientUserAgent: faker.lorem.words(),
    stateChangeTime: faker.date.past(),
    sendUpdatesToClient: faker.datatype.boolean(),
    updateScheduledTask: faker.datatype.boolean(),
    lastExecutionTime: faker.date.past(),
  }))
}

export function getGetApiV3CommandId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    commandName: faker.person.fullName(),
    message: faker.lorem.words(),
    body: {
      sendUpdatesToClient: faker.datatype.boolean(),
      updateScheduledTask: faker.datatype.boolean(),
      completionMessage: faker.lorem.words(),
      requiresDiskAccess: faker.datatype.boolean(),
      isExclusive: faker.datatype.boolean(),
      isTypeExclusive: faker.datatype.boolean(),
      isLongRunning: faker.datatype.boolean(),
      name: faker.person.fullName(),
      lastExecutionTime: faker.date.past(),
      lastStartTime: faker.date.past(),
      trigger: faker.helpers.arrayElement([
        'unspecified',
        'manual',
        'scheduled',
      ]),
      suppressMessages: faker.datatype.boolean(),
      clientUserAgent: faker.lorem.words(),
    },
    priority: faker.helpers.arrayElement(['normal', 'high', 'low']),
    status: faker.helpers.arrayElement([
      'queued',
      'started',
      'completed',
      'failed',
      'aborted',
      'cancelled',
      'orphaned',
    ]),
    result: faker.helpers.arrayElement([
      'unknown',
      'successful',
      'unsuccessful',
    ]),
    queued: faker.date.past(),
    started: faker.date.past(),
    ended: faker.date.past(),
    duration: faker.lorem.words(),
    exception: faker.lorem.words(),
    trigger: faker.helpers.arrayElement(['unspecified', 'manual', 'scheduled']),
    clientUserAgent: faker.lorem.words(),
    stateChangeTime: faker.date.past(),
    sendUpdatesToClient: faker.datatype.boolean(),
    updateScheduledTask: faker.datatype.boolean(),
    lastExecutionTime: faker.date.past(),
  }
}

export function getGetApiV3CreditId200Response() {
  return {
    id: faker.number.int(),
    personName: faker.person.fullName(),
    creditTmdbId: faker.string.uuid(),
    personTmdbId: faker.number.int(),
    movieMetadataId: faker.number.int(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    department: faker.lorem.words(),
    job: faker.lorem.words(),
    character: faker.lorem.words(),
    order: faker.number.int(),
    type: faker.helpers.arrayElement(['cast', 'crew']),
  }
}

export function getGetApiV3Customfilter200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    type: faker.lorem.words(),
    label: faker.lorem.words(),
    filters: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    ),
  }))
}

export function getPostApiV3Customfilter200Response() {
  return {
    id: faker.number.int(),
    type: faker.lorem.words(),
    label: faker.lorem.words(),
    filters: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    ),
  }
}

export function getPutApiV3CustomfilterId200Response() {
  return {
    id: faker.number.int(),
    type: faker.lorem.words(),
    label: faker.lorem.words(),
    filters: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    ),
  }
}

export function getGetApiV3CustomfilterId200Response() {
  return {
    id: faker.number.int(),
    type: faker.lorem.words(),
    label: faker.lorem.words(),
    filters: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) =>
      [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: null }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
    ),
  }
}

export function getGetApiV3Customformat200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }))
}

export function getPostApiV3Customformat200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }
}

export function getPutApiV3CustomformatId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }
}

export function getGetApiV3CustomformatId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }
}

export function getPutApiV3CustomformatBulk200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    includeCustomFormatWhenRenaming: faker.datatype.boolean(),
    specifications: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      implementation: faker.lorem.words(),
      implementationName: faker.person.fullName(),
      infoLink: faker.lorem.words(),
      negate: faker.datatype.boolean(),
      required: faker.datatype.boolean(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
    })),
  }
}

export function getGetApiV3WantedCutoff200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      title: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        sourceType: faker.helpers.arrayElement([
          'tmdb',
          'mappings',
          'user',
          'indexer',
        ]),
        movieMetadataId: faker.number.int(),
        title: faker.lorem.words(),
        cleanTitle: faker.lorem.words(),
      })),
      secondaryYear: faker.number.int(),
      secondaryYearSourceId: faker.number.int(),
      sortTitle: faker.lorem.words(),
      sizeOnDisk: faker.number.int(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      inCinemas: faker.date.past(),
      physicalRelease: faker.date.past(),
      digitalRelease: faker.date.past(),
      releaseDate: faker.date.past(),
      physicalReleaseNote: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      website: faker.lorem.words(),
      remotePoster: faker.lorem.words(),
      year: faker.number.int(),
      youTubeTrailerId: faker.string.uuid(),
      studio: faker.lorem.words(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      hasFile: faker.datatype.boolean(),
      movieFileId: faker.number.int(),
      monitored: faker.datatype.boolean(),
      minimumAvailability: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      isAvailable: faker.datatype.boolean(),
      folderName: faker.person.fullName(),
      runtime: faker.number.int(),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      tmdbId: faker.number.int(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'movieOnly',
          'movieAndCollection',
          'none',
        ]),
        searchForMovie: faker.datatype.boolean(),
        addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
      },
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      movieFile: {
        id: faker.number.int(),
        movieId: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        edition: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'cam',
              'telesync',
              'telecine',
              'workprint',
              'dvd',
              'tv',
              'webdl',
              'webrip',
              'bluray',
            ]),
            resolution: faker.number.int(),
            modifier: faker.helpers.arrayElement([
              'none',
              'regional',
              'screener',
              'rawhd',
              'brdisk',
              'remux',
            ]),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
                dividerAfter: faker.datatype.boolean(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        originalFilePath: faker.lorem.words(),
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      collection: {
        title: faker.lorem.words(),
        tmdbId: faker.number.int(),
      },
      popularity: faker.number.int(),
      lastSearchTime: faker.date.past(),
      statistics: {
        movieFileCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      },
    })),
  }
}

export function getPostApiV3Delayprofile200Response() {
  return {
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3Delayprofile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }))
}

export function getPutApiV3DelayprofileId200Response() {
  return {
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3DelayprofileId200Response() {
  return {
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getPutApiV3DelayprofileReorderId200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    enableUsenet: faker.datatype.boolean(),
    enableTorrent: faker.datatype.boolean(),
    preferredProtocol: faker.helpers.arrayElement([
      'unknown',
      'usenet',
      'torrent',
    ]),
    usenetDelay: faker.number.int(),
    torrentDelay: faker.number.int(),
    bypassIfHighestQuality: faker.datatype.boolean(),
    bypassIfAboveCustomFormatScore: faker.datatype.boolean(),
    minimumCustomFormatScore: faker.number.int(),
    order: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }))
}

export function getGetApiV3Diskspace200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    path: faker.lorem.words(),
    label: faker.lorem.words(),
    freeSpace: faker.number.int(),
    totalSpace: faker.number.int(),
  }))
}

export function getGetApiV3Downloadclient200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }))
}

export function getPostApiV3Downloadclient200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }
}

export function getPutApiV3DownloadclientId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }
}

export function getGetApiV3DownloadclientId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }
}

export function getPutApiV3DownloadclientBulk200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }
}

export function getGetApiV3DownloadclientSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    removeCompletedDownloads: faker.datatype.boolean(),
    removeFailedDownloads: faker.datatype.boolean(),
  }))
}

export function getGetApiV3ConfigDownloadclient200Response() {
  return {
    id: faker.number.int(),
    downloadClientWorkingFolders: faker.lorem.words(),
    enableCompletedDownloadHandling: faker.datatype.boolean(),
    checkForFinishedDownloadInterval: faker.number.int(),
    autoRedownloadFailed: faker.datatype.boolean(),
    autoRedownloadFailedFromInteractiveSearch: faker.datatype.boolean(),
  }
}

export function getPutApiV3ConfigDownloadclientId200Response() {
  return {
    id: faker.number.int(),
    downloadClientWorkingFolders: faker.lorem.words(),
    enableCompletedDownloadHandling: faker.datatype.boolean(),
    checkForFinishedDownloadInterval: faker.number.int(),
    autoRedownloadFailed: faker.datatype.boolean(),
    autoRedownloadFailedFromInteractiveSearch: faker.datatype.boolean(),
  }
}

export function getGetApiV3ConfigDownloadclientId200Response() {
  return {
    id: faker.number.int(),
    downloadClientWorkingFolders: faker.lorem.words(),
    enableCompletedDownloadHandling: faker.datatype.boolean(),
    checkForFinishedDownloadInterval: faker.number.int(),
    autoRedownloadFailed: faker.datatype.boolean(),
    autoRedownloadFailedFromInteractiveSearch: faker.datatype.boolean(),
  }
}

export function getGetApiV3Extrafile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    movieId: faker.number.int(),
    movieFileId: faker.number.int(),
    relativePath: faker.lorem.words(),
    extension: faker.lorem.words(),
    languageTags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    title: faker.lorem.words(),
    type: faker.helpers.arrayElement(['subtitle', 'metadata', 'other']),
  }))
}

export function getGetApiV3Health200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    source: faker.lorem.words(),
    type: faker.helpers.arrayElement(['ok', 'notice', 'warning', 'error']),
    message: faker.lorem.words(),
    wikiUrl: faker.internet.url(),
  }))
}

export function getGetApiV3History200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      movieId: faker.number.int(),
      sourceTitle: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      qualityCutoffNotMet: faker.datatype.boolean(),
      date: faker.date.past(),
      downloadId: faker.string.uuid(),
      eventType: faker.helpers.arrayElement([
        'unknown',
        'grabbed',
        'downloadFolderImported',
        'downloadFailed',
        'movieFileDeleted',
        'movieFolderImported',
        'movieFileRenamed',
        'downloadIgnored',
      ]),
      data: [...new Array(5).keys()]
        .map((_) => ({ [faker.lorem.word()]: faker.lorem.words() }))
        .reduce((acc, next) => Object.assign(acc, next), {}),
      movie: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        originalTitle: faker.lorem.words(),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          sourceType: faker.helpers.arrayElement([
            'tmdb',
            'mappings',
            'user',
            'indexer',
          ]),
          movieMetadataId: faker.number.int(),
          title: faker.lorem.words(),
          cleanTitle: faker.lorem.words(),
        })),
        secondaryYear: faker.number.int(),
        secondaryYearSourceId: faker.number.int(),
        sortTitle: faker.lorem.words(),
        sizeOnDisk: faker.number.int(),
        status: faker.helpers.arrayElement([
          'tba',
          'announced',
          'inCinemas',
          'released',
          'deleted',
        ]),
        overview: faker.lorem.words(),
        inCinemas: faker.date.past(),
        physicalRelease: faker.date.past(),
        digitalRelease: faker.date.past(),
        releaseDate: faker.date.past(),
        physicalReleaseNote: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        website: faker.lorem.words(),
        remotePoster: faker.lorem.words(),
        year: faker.number.int(),
        youTubeTrailerId: faker.string.uuid(),
        studio: faker.lorem.words(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        hasFile: faker.datatype.boolean(),
        movieFileId: faker.number.int(),
        monitored: faker.datatype.boolean(),
        minimumAvailability: faker.helpers.arrayElement([
          'tba',
          'announced',
          'inCinemas',
          'released',
          'deleted',
        ]),
        isAvailable: faker.datatype.boolean(),
        folderName: faker.person.fullName(),
        runtime: faker.number.int(),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        tmdbId: faker.number.int(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'movieOnly',
            'movieAndCollection',
            'none',
          ]),
          searchForMovie: faker.datatype.boolean(),
          addMethod: faker.helpers.arrayElement([
            'manual',
            'list',
            'collection',
          ]),
        },
        ratings: {
          imdb: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          tmdb: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          metacritic: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          rottenTomatoes: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          trakt: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
        },
        movieFile: {
          id: faker.number.int(),
          movieId: faker.number.int(),
          relativePath: faker.lorem.words(),
          path: faker.lorem.words(),
          size: faker.number.int(),
          dateAdded: faker.date.past(),
          sceneName: faker.person.fullName(),
          releaseGroup: faker.lorem.words(),
          edition: faker.lorem.words(),
          languages: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
          })),
          quality: {
            quality: {
              id: faker.number.int(),
              name: faker.person.fullName(),
              source: faker.helpers.arrayElement([
                'unknown',
                'cam',
                'telesync',
                'telecine',
                'workprint',
                'dvd',
                'tv',
                'webdl',
                'webrip',
                'bluray',
              ]),
              resolution: faker.number.int(),
              modifier: faker.helpers.arrayElement([
                'none',
                'regional',
                'screener',
                'rawhd',
                'brdisk',
                'remux',
              ]),
            },
            revision: {
              version: faker.number.int(),
              real: faker.number.int(),
              isRepack: faker.datatype.boolean(),
            },
          },
          customFormats: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            includeCustomFormatWhenRenaming: faker.datatype.boolean(),
            specifications: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              id: faker.number.int(),
              name: faker.person.fullName(),
              implementation: faker.lorem.words(),
              implementationName: faker.person.fullName(),
              infoLink: faker.lorem.words(),
              negate: faker.datatype.boolean(),
              required: faker.datatype.boolean(),
              fields: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                order: faker.number.int(),
                name: faker.person.fullName(),
                label: faker.lorem.words(),
                unit: faker.lorem.words(),
                helpText: faker.lorem.words(),
                helpTextWarning: faker.lorem.words(),
                helpLink: faker.lorem.words(),
                value: null,
                type: faker.lorem.words(),
                advanced: faker.datatype.boolean(),
                selectOptions: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => ({
                  value: faker.number.int(),
                  name: faker.person.fullName(),
                  order: faker.number.int(),
                  hint: faker.lorem.words(),
                  dividerAfter: faker.datatype.boolean(),
                })),
                selectOptionsProviderAction: faker.lorem.words(),
                section: faker.lorem.words(),
                hidden: faker.lorem.words(),
                privacy: faker.helpers.arrayElement([
                  'normal',
                  'password',
                  'apiKey',
                  'userName',
                ]),
                placeholder: faker.lorem.words(),
                isFloat: faker.datatype.boolean(),
              })),
              presets: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => null),
            })),
          })),
          customFormatScore: faker.number.int(),
          indexerFlags: faker.number.int(),
          mediaInfo: {
            id: faker.number.int(),
            audioBitrate: faker.number.int(),
            audioChannels: faker.number.int(),
            audioCodec: faker.lorem.words(),
            audioLanguages: faker.lorem.words(),
            audioStreamCount: faker.number.int(),
            videoBitDepth: faker.number.int(),
            videoBitrate: faker.number.int(),
            videoCodec: faker.lorem.words(),
            videoFps: faker.number.int(),
            videoDynamicRange: faker.lorem.words(),
            videoDynamicRangeType: faker.lorem.words(),
            resolution: faker.lorem.words(),
            runTime: faker.lorem.words(),
            scanType: faker.lorem.words(),
            subtitles: faker.lorem.words(),
          },
          originalFilePath: faker.lorem.words(),
          qualityCutoffNotMet: faker.datatype.boolean(),
        },
        collection: {
          title: faker.lorem.words(),
          tmdbId: faker.number.int(),
        },
        popularity: faker.number.int(),
        lastSearchTime: faker.date.past(),
        statistics: {
          movieFileCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
        },
      },
    })),
  }
}

export function getGetApiV3HistorySince200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    movieId: faker.number.int(),
    sourceTitle: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    qualityCutoffNotMet: faker.datatype.boolean(),
    date: faker.date.past(),
    downloadId: faker.string.uuid(),
    eventType: faker.helpers.arrayElement([
      'unknown',
      'grabbed',
      'downloadFolderImported',
      'downloadFailed',
      'movieFileDeleted',
      'movieFolderImported',
      'movieFileRenamed',
      'downloadIgnored',
    ]),
    data: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: faker.lorem.words() }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    movie: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        sourceType: faker.helpers.arrayElement([
          'tmdb',
          'mappings',
          'user',
          'indexer',
        ]),
        movieMetadataId: faker.number.int(),
        title: faker.lorem.words(),
        cleanTitle: faker.lorem.words(),
      })),
      secondaryYear: faker.number.int(),
      secondaryYearSourceId: faker.number.int(),
      sortTitle: faker.lorem.words(),
      sizeOnDisk: faker.number.int(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      inCinemas: faker.date.past(),
      physicalRelease: faker.date.past(),
      digitalRelease: faker.date.past(),
      releaseDate: faker.date.past(),
      physicalReleaseNote: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      website: faker.lorem.words(),
      remotePoster: faker.lorem.words(),
      year: faker.number.int(),
      youTubeTrailerId: faker.string.uuid(),
      studio: faker.lorem.words(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      hasFile: faker.datatype.boolean(),
      movieFileId: faker.number.int(),
      monitored: faker.datatype.boolean(),
      minimumAvailability: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      isAvailable: faker.datatype.boolean(),
      folderName: faker.person.fullName(),
      runtime: faker.number.int(),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      tmdbId: faker.number.int(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'movieOnly',
          'movieAndCollection',
          'none',
        ]),
        searchForMovie: faker.datatype.boolean(),
        addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
      },
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      movieFile: {
        id: faker.number.int(),
        movieId: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        edition: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'cam',
              'telesync',
              'telecine',
              'workprint',
              'dvd',
              'tv',
              'webdl',
              'webrip',
              'bluray',
            ]),
            resolution: faker.number.int(),
            modifier: faker.helpers.arrayElement([
              'none',
              'regional',
              'screener',
              'rawhd',
              'brdisk',
              'remux',
            ]),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
                dividerAfter: faker.datatype.boolean(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        originalFilePath: faker.lorem.words(),
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      collection: {
        title: faker.lorem.words(),
        tmdbId: faker.number.int(),
      },
      popularity: faker.number.int(),
      lastSearchTime: faker.date.past(),
      statistics: {
        movieFileCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      },
    },
  }))
}

export function getGetApiV3HistoryMovie200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    movieId: faker.number.int(),
    sourceTitle: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    qualityCutoffNotMet: faker.datatype.boolean(),
    date: faker.date.past(),
    downloadId: faker.string.uuid(),
    eventType: faker.helpers.arrayElement([
      'unknown',
      'grabbed',
      'downloadFolderImported',
      'downloadFailed',
      'movieFileDeleted',
      'movieFolderImported',
      'movieFileRenamed',
      'downloadIgnored',
    ]),
    data: [...new Array(5).keys()]
      .map((_) => ({ [faker.lorem.word()]: faker.lorem.words() }))
      .reduce((acc, next) => Object.assign(acc, next), {}),
    movie: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        sourceType: faker.helpers.arrayElement([
          'tmdb',
          'mappings',
          'user',
          'indexer',
        ]),
        movieMetadataId: faker.number.int(),
        title: faker.lorem.words(),
        cleanTitle: faker.lorem.words(),
      })),
      secondaryYear: faker.number.int(),
      secondaryYearSourceId: faker.number.int(),
      sortTitle: faker.lorem.words(),
      sizeOnDisk: faker.number.int(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      inCinemas: faker.date.past(),
      physicalRelease: faker.date.past(),
      digitalRelease: faker.date.past(),
      releaseDate: faker.date.past(),
      physicalReleaseNote: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      website: faker.lorem.words(),
      remotePoster: faker.lorem.words(),
      year: faker.number.int(),
      youTubeTrailerId: faker.string.uuid(),
      studio: faker.lorem.words(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      hasFile: faker.datatype.boolean(),
      movieFileId: faker.number.int(),
      monitored: faker.datatype.boolean(),
      minimumAvailability: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      isAvailable: faker.datatype.boolean(),
      folderName: faker.person.fullName(),
      runtime: faker.number.int(),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      tmdbId: faker.number.int(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'movieOnly',
          'movieAndCollection',
          'none',
        ]),
        searchForMovie: faker.datatype.boolean(),
        addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
      },
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      movieFile: {
        id: faker.number.int(),
        movieId: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        edition: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'cam',
              'telesync',
              'telecine',
              'workprint',
              'dvd',
              'tv',
              'webdl',
              'webrip',
              'bluray',
            ]),
            resolution: faker.number.int(),
            modifier: faker.helpers.arrayElement([
              'none',
              'regional',
              'screener',
              'rawhd',
              'brdisk',
              'remux',
            ]),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
                dividerAfter: faker.datatype.boolean(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        originalFilePath: faker.lorem.words(),
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      collection: {
        title: faker.lorem.words(),
        tmdbId: faker.number.int(),
      },
      popularity: faker.number.int(),
      lastSearchTime: faker.date.past(),
      statistics: {
        movieFileCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      },
    },
  }))
}

export function getGetApiV3ConfigHost200Response() {
  return {
    id: faker.number.int(),
    bindAddress: faker.lorem.words(),
    port: faker.number.int(),
    sslPort: faker.number.int(),
    enableSsl: faker.datatype.boolean(),
    launchBrowser: faker.datatype.boolean(),
    authenticationMethod: faker.helpers.arrayElement([
      'none',
      'basic',
      'forms',
      'external',
    ]),
    authenticationRequired: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
    ]),
    analyticsEnabled: faker.datatype.boolean(),
    username: faker.person.fullName(),
    password: faker.lorem.words(),
    passwordConfirmation: faker.lorem.words(),
    logLevel: faker.lorem.words(),
    logSizeLimit: faker.number.int(),
    consoleLogLevel: faker.lorem.words(),
    branch: faker.lorem.words(),
    apiKey: faker.lorem.words(),
    sslCertPath: faker.lorem.words(),
    sslCertPassword: faker.lorem.words(),
    urlBase: faker.internet.url(),
    instanceName: faker.person.fullName(),
    applicationUrl: faker.internet.url(),
    updateAutomatically: faker.datatype.boolean(),
    updateMechanism: faker.helpers.arrayElement([
      'builtIn',
      'script',
      'external',
      'apt',
      'docker',
    ]),
    updateScriptPath: faker.lorem.words(),
    proxyEnabled: faker.datatype.boolean(),
    proxyType: faker.helpers.arrayElement(['http', 'socks4', 'socks5']),
    proxyHostname: faker.person.fullName(),
    proxyPort: faker.number.int(),
    proxyUsername: faker.person.fullName(),
    proxyPassword: faker.lorem.words(),
    proxyBypassFilter: faker.lorem.words(),
    proxyBypassLocalAddresses: faker.datatype.boolean(),
    certificateValidation: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
      'disabled',
    ]),
    backupFolder: faker.lorem.words(),
    backupInterval: faker.number.int(),
    backupRetention: faker.number.int(),
    trustCgnatIpAddresses: faker.datatype.boolean(),
  }
}

export function getPutApiV3ConfigHostId200Response() {
  return {
    id: faker.number.int(),
    bindAddress: faker.lorem.words(),
    port: faker.number.int(),
    sslPort: faker.number.int(),
    enableSsl: faker.datatype.boolean(),
    launchBrowser: faker.datatype.boolean(),
    authenticationMethod: faker.helpers.arrayElement([
      'none',
      'basic',
      'forms',
      'external',
    ]),
    authenticationRequired: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
    ]),
    analyticsEnabled: faker.datatype.boolean(),
    username: faker.person.fullName(),
    password: faker.lorem.words(),
    passwordConfirmation: faker.lorem.words(),
    logLevel: faker.lorem.words(),
    logSizeLimit: faker.number.int(),
    consoleLogLevel: faker.lorem.words(),
    branch: faker.lorem.words(),
    apiKey: faker.lorem.words(),
    sslCertPath: faker.lorem.words(),
    sslCertPassword: faker.lorem.words(),
    urlBase: faker.internet.url(),
    instanceName: faker.person.fullName(),
    applicationUrl: faker.internet.url(),
    updateAutomatically: faker.datatype.boolean(),
    updateMechanism: faker.helpers.arrayElement([
      'builtIn',
      'script',
      'external',
      'apt',
      'docker',
    ]),
    updateScriptPath: faker.lorem.words(),
    proxyEnabled: faker.datatype.boolean(),
    proxyType: faker.helpers.arrayElement(['http', 'socks4', 'socks5']),
    proxyHostname: faker.person.fullName(),
    proxyPort: faker.number.int(),
    proxyUsername: faker.person.fullName(),
    proxyPassword: faker.lorem.words(),
    proxyBypassFilter: faker.lorem.words(),
    proxyBypassLocalAddresses: faker.datatype.boolean(),
    certificateValidation: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
      'disabled',
    ]),
    backupFolder: faker.lorem.words(),
    backupInterval: faker.number.int(),
    backupRetention: faker.number.int(),
    trustCgnatIpAddresses: faker.datatype.boolean(),
  }
}

export function getGetApiV3ConfigHostId200Response() {
  return {
    id: faker.number.int(),
    bindAddress: faker.lorem.words(),
    port: faker.number.int(),
    sslPort: faker.number.int(),
    enableSsl: faker.datatype.boolean(),
    launchBrowser: faker.datatype.boolean(),
    authenticationMethod: faker.helpers.arrayElement([
      'none',
      'basic',
      'forms',
      'external',
    ]),
    authenticationRequired: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
    ]),
    analyticsEnabled: faker.datatype.boolean(),
    username: faker.person.fullName(),
    password: faker.lorem.words(),
    passwordConfirmation: faker.lorem.words(),
    logLevel: faker.lorem.words(),
    logSizeLimit: faker.number.int(),
    consoleLogLevel: faker.lorem.words(),
    branch: faker.lorem.words(),
    apiKey: faker.lorem.words(),
    sslCertPath: faker.lorem.words(),
    sslCertPassword: faker.lorem.words(),
    urlBase: faker.internet.url(),
    instanceName: faker.person.fullName(),
    applicationUrl: faker.internet.url(),
    updateAutomatically: faker.datatype.boolean(),
    updateMechanism: faker.helpers.arrayElement([
      'builtIn',
      'script',
      'external',
      'apt',
      'docker',
    ]),
    updateScriptPath: faker.lorem.words(),
    proxyEnabled: faker.datatype.boolean(),
    proxyType: faker.helpers.arrayElement(['http', 'socks4', 'socks5']),
    proxyHostname: faker.person.fullName(),
    proxyPort: faker.number.int(),
    proxyUsername: faker.person.fullName(),
    proxyPassword: faker.lorem.words(),
    proxyBypassFilter: faker.lorem.words(),
    proxyBypassLocalAddresses: faker.datatype.boolean(),
    certificateValidation: faker.helpers.arrayElement([
      'enabled',
      'disabledForLocalAddresses',
      'disabled',
    ]),
    backupFolder: faker.lorem.words(),
    backupInterval: faker.number.int(),
    backupRetention: faker.number.int(),
    trustCgnatIpAddresses: faker.datatype.boolean(),
  }
}

export function getGetApiV3Importlist200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enabled: faker.datatype.boolean(),
    enableAuto: faker.datatype.boolean(),
    monitor: faker.helpers.arrayElement([
      'movieOnly',
      'movieAndCollection',
      'none',
    ]),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    searchOnAdd: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    listType: faker.helpers.arrayElement([
      'program',
      'tmdb',
      'trakt',
      'plex',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }))
}

export function getPostApiV3Importlist200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enabled: faker.datatype.boolean(),
    enableAuto: faker.datatype.boolean(),
    monitor: faker.helpers.arrayElement([
      'movieOnly',
      'movieAndCollection',
      'none',
    ]),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    searchOnAdd: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    listType: faker.helpers.arrayElement([
      'program',
      'tmdb',
      'trakt',
      'plex',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }
}

export function getPutApiV3ImportlistId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enabled: faker.datatype.boolean(),
    enableAuto: faker.datatype.boolean(),
    monitor: faker.helpers.arrayElement([
      'movieOnly',
      'movieAndCollection',
      'none',
    ]),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    searchOnAdd: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    listType: faker.helpers.arrayElement([
      'program',
      'tmdb',
      'trakt',
      'plex',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }
}

export function getGetApiV3ImportlistId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enabled: faker.datatype.boolean(),
    enableAuto: faker.datatype.boolean(),
    monitor: faker.helpers.arrayElement([
      'movieOnly',
      'movieAndCollection',
      'none',
    ]),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    searchOnAdd: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    listType: faker.helpers.arrayElement([
      'program',
      'tmdb',
      'trakt',
      'plex',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }
}

export function getPutApiV3ImportlistBulk200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enabled: faker.datatype.boolean(),
    enableAuto: faker.datatype.boolean(),
    monitor: faker.helpers.arrayElement([
      'movieOnly',
      'movieAndCollection',
      'none',
    ]),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    searchOnAdd: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    listType: faker.helpers.arrayElement([
      'program',
      'tmdb',
      'trakt',
      'plex',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }
}

export function getGetApiV3ImportlistSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enabled: faker.datatype.boolean(),
    enableAuto: faker.datatype.boolean(),
    monitor: faker.helpers.arrayElement([
      'movieOnly',
      'movieAndCollection',
      'none',
    ]),
    rootFolderPath: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    searchOnAdd: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    listType: faker.helpers.arrayElement([
      'program',
      'tmdb',
      'trakt',
      'plex',
      'simkl',
      'other',
      'advanced',
    ]),
    listOrder: faker.number.int(),
    minRefreshInterval: faker.lorem.words(),
  }))
}

export function getGetApiV3ConfigImportlist200Response() {
  return {
    id: faker.number.int(),
    listSyncLevel: faker.lorem.words(),
  }
}

export function getPutApiV3ConfigImportlistId200Response() {
  return {
    id: faker.number.int(),
    listSyncLevel: faker.lorem.words(),
  }
}

export function getGetApiV3ConfigImportlistId200Response() {
  return {
    id: faker.number.int(),
    listSyncLevel: faker.lorem.words(),
  }
}

export function getGetApiV3Exclusions200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    tmdbId: faker.number.int(),
    movieTitle: faker.lorem.words(),
    movieYear: faker.number.int(),
  }))
}

export function getPostApiV3Exclusions200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    tmdbId: faker.number.int(),
    movieTitle: faker.lorem.words(),
    movieYear: faker.number.int(),
  }
}

export function getGetApiV3ExclusionsPaged200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      fields: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        order: faker.number.int(),
        name: faker.person.fullName(),
        label: faker.lorem.words(),
        unit: faker.lorem.words(),
        helpText: faker.lorem.words(),
        helpTextWarning: faker.lorem.words(),
        helpLink: faker.lorem.words(),
        value: null,
        type: faker.lorem.words(),
        advanced: faker.datatype.boolean(),
        selectOptions: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          value: faker.number.int(),
          name: faker.person.fullName(),
          order: faker.number.int(),
          hint: faker.lorem.words(),
          dividerAfter: faker.datatype.boolean(),
        })),
        selectOptionsProviderAction: faker.lorem.words(),
        section: faker.lorem.words(),
        hidden: faker.lorem.words(),
        privacy: faker.helpers.arrayElement([
          'normal',
          'password',
          'apiKey',
          'userName',
        ]),
        placeholder: faker.lorem.words(),
        isFloat: faker.datatype.boolean(),
      })),
      implementationName: faker.person.fullName(),
      implementation: faker.lorem.words(),
      configContract: faker.lorem.words(),
      infoLink: faker.lorem.words(),
      message: {
        message: faker.lorem.words(),
        type: faker.helpers.arrayElement(['info', 'warning', 'error']),
      },
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      presets: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      tmdbId: faker.number.int(),
      movieTitle: faker.lorem.words(),
      movieYear: faker.number.int(),
    })),
  }
}

export function getPutApiV3ExclusionsId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    tmdbId: faker.number.int(),
    movieTitle: faker.lorem.words(),
    movieYear: faker.number.int(),
  }
}

export function getGetApiV3ExclusionsId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    tmdbId: faker.number.int(),
    movieTitle: faker.lorem.words(),
    movieYear: faker.number.int(),
  }
}

export function getGetApiV3Indexer200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    downloadClientId: faker.number.int(),
  }))
}

export function getPostApiV3Indexer200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    downloadClientId: faker.number.int(),
  }
}

export function getPutApiV3IndexerId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    downloadClientId: faker.number.int(),
  }
}

export function getGetApiV3IndexerId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    downloadClientId: faker.number.int(),
  }
}

export function getPutApiV3IndexerBulk200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    downloadClientId: faker.number.int(),
  }
}

export function getGetApiV3IndexerSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enableRss: faker.datatype.boolean(),
    enableAutomaticSearch: faker.datatype.boolean(),
    enableInteractiveSearch: faker.datatype.boolean(),
    supportsRss: faker.datatype.boolean(),
    supportsSearch: faker.datatype.boolean(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    priority: faker.number.int(),
    downloadClientId: faker.number.int(),
  }))
}

export function getGetApiV3ConfigIndexer200Response() {
  return {
    id: faker.number.int(),
    minimumAge: faker.number.int(),
    maximumSize: faker.number.int(),
    retention: faker.number.int(),
    rssSyncInterval: faker.number.int(),
    preferIndexerFlags: faker.datatype.boolean(),
    availabilityDelay: faker.number.int(),
    allowHardcodedSubs: faker.datatype.boolean(),
    whitelistedHardcodedSubs: faker.lorem.words(),
  }
}

export function getPutApiV3ConfigIndexerId200Response() {
  return {
    id: faker.number.int(),
    minimumAge: faker.number.int(),
    maximumSize: faker.number.int(),
    retention: faker.number.int(),
    rssSyncInterval: faker.number.int(),
    preferIndexerFlags: faker.datatype.boolean(),
    availabilityDelay: faker.number.int(),
    allowHardcodedSubs: faker.datatype.boolean(),
    whitelistedHardcodedSubs: faker.lorem.words(),
  }
}

export function getGetApiV3ConfigIndexerId200Response() {
  return {
    id: faker.number.int(),
    minimumAge: faker.number.int(),
    maximumSize: faker.number.int(),
    retention: faker.number.int(),
    rssSyncInterval: faker.number.int(),
    preferIndexerFlags: faker.datatype.boolean(),
    availabilityDelay: faker.number.int(),
    allowHardcodedSubs: faker.datatype.boolean(),
    whitelistedHardcodedSubs: faker.lorem.words(),
  }
}

export function getGetApiV3Indexerflag200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    nameLower: faker.lorem.words(),
  }))
}

export function getGetApiV3Language200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    nameLower: faker.lorem.words(),
  }))
}

export function getGetApiV3LanguageId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    nameLower: faker.lorem.words(),
  }
}

export function getGetApiV3Localization200Response() {
  return faker.lorem.words()
}

export function getGetApiV3LocalizationLanguage200Response() {
  return {
    identifier: faker.lorem.words(),
  }
}

export function getGetApiV3Log200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      time: faker.date.past(),
      exception: faker.lorem.words(),
      exceptionType: faker.lorem.words(),
      level: faker.lorem.words(),
      logger: faker.lorem.words(),
      message: faker.lorem.words(),
      method: faker.lorem.words(),
    })),
  }
}

export function getGetApiV3LogFile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    filename: faker.person.fullName(),
    lastWriteTime: faker.date.past(),
    contentsUrl: faker.internet.url(),
    downloadUrl: faker.internet.url(),
  }))
}

export function getGetApiV3Manualimport200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    path: faker.lorem.words(),
    relativePath: faker.lorem.words(),
    folderName: faker.person.fullName(),
    name: faker.person.fullName(),
    size: faker.number.int(),
    movie: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        sourceType: faker.helpers.arrayElement([
          'tmdb',
          'mappings',
          'user',
          'indexer',
        ]),
        movieMetadataId: faker.number.int(),
        title: faker.lorem.words(),
        cleanTitle: faker.lorem.words(),
      })),
      secondaryYear: faker.number.int(),
      secondaryYearSourceId: faker.number.int(),
      sortTitle: faker.lorem.words(),
      sizeOnDisk: faker.number.int(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      inCinemas: faker.date.past(),
      physicalRelease: faker.date.past(),
      digitalRelease: faker.date.past(),
      releaseDate: faker.date.past(),
      physicalReleaseNote: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      website: faker.lorem.words(),
      remotePoster: faker.lorem.words(),
      year: faker.number.int(),
      youTubeTrailerId: faker.string.uuid(),
      studio: faker.lorem.words(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      hasFile: faker.datatype.boolean(),
      movieFileId: faker.number.int(),
      monitored: faker.datatype.boolean(),
      minimumAvailability: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      isAvailable: faker.datatype.boolean(),
      folderName: faker.person.fullName(),
      runtime: faker.number.int(),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      tmdbId: faker.number.int(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'movieOnly',
          'movieAndCollection',
          'none',
        ]),
        searchForMovie: faker.datatype.boolean(),
        addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
      },
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      movieFile: {
        id: faker.number.int(),
        movieId: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        edition: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'cam',
              'telesync',
              'telecine',
              'workprint',
              'dvd',
              'tv',
              'webdl',
              'webrip',
              'bluray',
            ]),
            resolution: faker.number.int(),
            modifier: faker.helpers.arrayElement([
              'none',
              'regional',
              'screener',
              'rawhd',
              'brdisk',
              'remux',
            ]),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
                dividerAfter: faker.datatype.boolean(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        originalFilePath: faker.lorem.words(),
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      collection: {
        title: faker.lorem.words(),
        tmdbId: faker.number.int(),
      },
      popularity: faker.number.int(),
      lastSearchTime: faker.date.past(),
      statistics: {
        movieFileCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      },
    },
    movieFileId: faker.number.int(),
    releaseGroup: faker.lorem.words(),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    qualityWeight: faker.number.int(),
    downloadId: faker.string.uuid(),
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    indexerFlags: faker.number.int(),
    rejections: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      reason: faker.lorem.words(),
      type: faker.helpers.arrayElement(['permanent', 'temporary']),
    })),
  }))
}

export function getGetApiV3ConfigMediamanagement200Response() {
  return {
    id: faker.number.int(),
    autoUnmonitorPreviouslyDownloadedMovies: faker.datatype.boolean(),
    recycleBin: faker.lorem.words(),
    recycleBinCleanupDays: faker.number.int(),
    downloadPropersAndRepacks: faker.helpers.arrayElement([
      'preferAndUpgrade',
      'doNotUpgrade',
      'doNotPrefer',
    ]),
    createEmptyMovieFolders: faker.datatype.boolean(),
    deleteEmptyFolders: faker.datatype.boolean(),
    fileDate: faker.helpers.arrayElement(['none', 'cinemas', 'release']),
    rescanAfterRefresh: faker.helpers.arrayElement([
      'always',
      'afterManual',
      'never',
    ]),
    autoRenameFolders: faker.datatype.boolean(),
    pathsDefaultStatic: faker.datatype.boolean(),
    setPermissionsLinux: faker.datatype.boolean(),
    chmodFolder: faker.lorem.words(),
    chownGroup: faker.lorem.words(),
    skipFreeSpaceCheckWhenImporting: faker.datatype.boolean(),
    minimumFreeSpaceWhenImporting: faker.number.int(),
    copyUsingHardlinks: faker.datatype.boolean(),
    useScriptImport: faker.datatype.boolean(),
    scriptImportPath: faker.lorem.words(),
    importExtraFiles: faker.datatype.boolean(),
    extraFileExtensions: faker.lorem.words(),
    enableMediaInfo: faker.datatype.boolean(),
  }
}

export function getPutApiV3ConfigMediamanagementId200Response() {
  return {
    id: faker.number.int(),
    autoUnmonitorPreviouslyDownloadedMovies: faker.datatype.boolean(),
    recycleBin: faker.lorem.words(),
    recycleBinCleanupDays: faker.number.int(),
    downloadPropersAndRepacks: faker.helpers.arrayElement([
      'preferAndUpgrade',
      'doNotUpgrade',
      'doNotPrefer',
    ]),
    createEmptyMovieFolders: faker.datatype.boolean(),
    deleteEmptyFolders: faker.datatype.boolean(),
    fileDate: faker.helpers.arrayElement(['none', 'cinemas', 'release']),
    rescanAfterRefresh: faker.helpers.arrayElement([
      'always',
      'afterManual',
      'never',
    ]),
    autoRenameFolders: faker.datatype.boolean(),
    pathsDefaultStatic: faker.datatype.boolean(),
    setPermissionsLinux: faker.datatype.boolean(),
    chmodFolder: faker.lorem.words(),
    chownGroup: faker.lorem.words(),
    skipFreeSpaceCheckWhenImporting: faker.datatype.boolean(),
    minimumFreeSpaceWhenImporting: faker.number.int(),
    copyUsingHardlinks: faker.datatype.boolean(),
    useScriptImport: faker.datatype.boolean(),
    scriptImportPath: faker.lorem.words(),
    importExtraFiles: faker.datatype.boolean(),
    extraFileExtensions: faker.lorem.words(),
    enableMediaInfo: faker.datatype.boolean(),
  }
}

export function getGetApiV3ConfigMediamanagementId200Response() {
  return {
    id: faker.number.int(),
    autoUnmonitorPreviouslyDownloadedMovies: faker.datatype.boolean(),
    recycleBin: faker.lorem.words(),
    recycleBinCleanupDays: faker.number.int(),
    downloadPropersAndRepacks: faker.helpers.arrayElement([
      'preferAndUpgrade',
      'doNotUpgrade',
      'doNotPrefer',
    ]),
    createEmptyMovieFolders: faker.datatype.boolean(),
    deleteEmptyFolders: faker.datatype.boolean(),
    fileDate: faker.helpers.arrayElement(['none', 'cinemas', 'release']),
    rescanAfterRefresh: faker.helpers.arrayElement([
      'always',
      'afterManual',
      'never',
    ]),
    autoRenameFolders: faker.datatype.boolean(),
    pathsDefaultStatic: faker.datatype.boolean(),
    setPermissionsLinux: faker.datatype.boolean(),
    chmodFolder: faker.lorem.words(),
    chownGroup: faker.lorem.words(),
    skipFreeSpaceCheckWhenImporting: faker.datatype.boolean(),
    minimumFreeSpaceWhenImporting: faker.number.int(),
    copyUsingHardlinks: faker.datatype.boolean(),
    useScriptImport: faker.datatype.boolean(),
    scriptImportPath: faker.lorem.words(),
    importExtraFiles: faker.datatype.boolean(),
    extraFileExtensions: faker.lorem.words(),
    enableMediaInfo: faker.datatype.boolean(),
  }
}

export function getGetApiV3Metadata200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }))
}

export function getPostApiV3Metadata200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }
}

export function getPutApiV3MetadataId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }
}

export function getGetApiV3MetadataId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }
}

export function getGetApiV3MetadataSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    enable: faker.datatype.boolean(),
  }))
}

export function getGetApiV3ConfigMetadata200Response() {
  return {
    id: faker.number.int(),
    certificationCountry: faker.helpers.arrayElement([
      'au',
      'br',
      'ca',
      'fr',
      'de',
      'gb',
      'in',
      'ie',
      'it',
      'nz',
      'ro',
      'es',
      'us',
    ]),
  }
}

export function getPutApiV3ConfigMetadataId200Response() {
  return {
    id: faker.number.int(),
    certificationCountry: faker.helpers.arrayElement([
      'au',
      'br',
      'ca',
      'fr',
      'de',
      'gb',
      'in',
      'ie',
      'it',
      'nz',
      'ro',
      'es',
      'us',
    ]),
  }
}

export function getGetApiV3ConfigMetadataId200Response() {
  return {
    id: faker.number.int(),
    certificationCountry: faker.helpers.arrayElement([
      'au',
      'br',
      'ca',
      'fr',
      'de',
      'gb',
      'in',
      'ie',
      'it',
      'nz',
      'ro',
      'es',
      'us',
    ]),
  }
}

export function getGetApiV3WantedMissing200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      title: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        sourceType: faker.helpers.arrayElement([
          'tmdb',
          'mappings',
          'user',
          'indexer',
        ]),
        movieMetadataId: faker.number.int(),
        title: faker.lorem.words(),
        cleanTitle: faker.lorem.words(),
      })),
      secondaryYear: faker.number.int(),
      secondaryYearSourceId: faker.number.int(),
      sortTitle: faker.lorem.words(),
      sizeOnDisk: faker.number.int(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      inCinemas: faker.date.past(),
      physicalRelease: faker.date.past(),
      digitalRelease: faker.date.past(),
      releaseDate: faker.date.past(),
      physicalReleaseNote: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      website: faker.lorem.words(),
      remotePoster: faker.lorem.words(),
      year: faker.number.int(),
      youTubeTrailerId: faker.string.uuid(),
      studio: faker.lorem.words(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      hasFile: faker.datatype.boolean(),
      movieFileId: faker.number.int(),
      monitored: faker.datatype.boolean(),
      minimumAvailability: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      isAvailable: faker.datatype.boolean(),
      folderName: faker.person.fullName(),
      runtime: faker.number.int(),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      tmdbId: faker.number.int(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'movieOnly',
          'movieAndCollection',
          'none',
        ]),
        searchForMovie: faker.datatype.boolean(),
        addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
      },
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      movieFile: {
        id: faker.number.int(),
        movieId: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        edition: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'cam',
              'telesync',
              'telecine',
              'workprint',
              'dvd',
              'tv',
              'webdl',
              'webrip',
              'bluray',
            ]),
            resolution: faker.number.int(),
            modifier: faker.helpers.arrayElement([
              'none',
              'regional',
              'screener',
              'rawhd',
              'brdisk',
              'remux',
            ]),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
                dividerAfter: faker.datatype.boolean(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        originalFilePath: faker.lorem.words(),
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      collection: {
        title: faker.lorem.words(),
        tmdbId: faker.number.int(),
      },
      popularity: faker.number.int(),
      lastSearchTime: faker.date.past(),
      statistics: {
        movieFileCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      },
    })),
  }
}

export function getGetApiV3Movie200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    title: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      sourceType: faker.helpers.arrayElement([
        'tmdb',
        'mappings',
        'user',
        'indexer',
      ]),
      movieMetadataId: faker.number.int(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
    })),
    secondaryYear: faker.number.int(),
    secondaryYearSourceId: faker.number.int(),
    sortTitle: faker.lorem.words(),
    sizeOnDisk: faker.number.int(),
    status: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    overview: faker.lorem.words(),
    inCinemas: faker.date.past(),
    physicalRelease: faker.date.past(),
    digitalRelease: faker.date.past(),
    releaseDate: faker.date.past(),
    physicalReleaseNote: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    website: faker.lorem.words(),
    remotePoster: faker.lorem.words(),
    year: faker.number.int(),
    youTubeTrailerId: faker.string.uuid(),
    studio: faker.lorem.words(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    hasFile: faker.datatype.boolean(),
    movieFileId: faker.number.int(),
    monitored: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    isAvailable: faker.datatype.boolean(),
    folderName: faker.person.fullName(),
    runtime: faker.number.int(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    tmdbId: faker.number.int(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'movieOnly',
        'movieAndCollection',
        'none',
      ]),
      searchForMovie: faker.datatype.boolean(),
      addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
    },
    ratings: {
      imdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      tmdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      metacritic: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      rottenTomatoes: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      trakt: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
    },
    movieFile: {
      id: faker.number.int(),
      movieId: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      edition: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      originalFilePath: faker.lorem.words(),
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    collection: {
      title: faker.lorem.words(),
      tmdbId: faker.number.int(),
    },
    popularity: faker.number.int(),
    lastSearchTime: faker.date.past(),
    statistics: {
      movieFileCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
  }))
}

export function getPostApiV3Movie200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      sourceType: faker.helpers.arrayElement([
        'tmdb',
        'mappings',
        'user',
        'indexer',
      ]),
      movieMetadataId: faker.number.int(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
    })),
    secondaryYear: faker.number.int(),
    secondaryYearSourceId: faker.number.int(),
    sortTitle: faker.lorem.words(),
    sizeOnDisk: faker.number.int(),
    status: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    overview: faker.lorem.words(),
    inCinemas: faker.date.past(),
    physicalRelease: faker.date.past(),
    digitalRelease: faker.date.past(),
    releaseDate: faker.date.past(),
    physicalReleaseNote: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    website: faker.lorem.words(),
    remotePoster: faker.lorem.words(),
    year: faker.number.int(),
    youTubeTrailerId: faker.string.uuid(),
    studio: faker.lorem.words(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    hasFile: faker.datatype.boolean(),
    movieFileId: faker.number.int(),
    monitored: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    isAvailable: faker.datatype.boolean(),
    folderName: faker.person.fullName(),
    runtime: faker.number.int(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    tmdbId: faker.number.int(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'movieOnly',
        'movieAndCollection',
        'none',
      ]),
      searchForMovie: faker.datatype.boolean(),
      addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
    },
    ratings: {
      imdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      tmdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      metacritic: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      rottenTomatoes: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      trakt: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
    },
    movieFile: {
      id: faker.number.int(),
      movieId: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      edition: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      originalFilePath: faker.lorem.words(),
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    collection: {
      title: faker.lorem.words(),
      tmdbId: faker.number.int(),
    },
    popularity: faker.number.int(),
    lastSearchTime: faker.date.past(),
    statistics: {
      movieFileCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
  }
}

export function getPutApiV3MovieId200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      sourceType: faker.helpers.arrayElement([
        'tmdb',
        'mappings',
        'user',
        'indexer',
      ]),
      movieMetadataId: faker.number.int(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
    })),
    secondaryYear: faker.number.int(),
    secondaryYearSourceId: faker.number.int(),
    sortTitle: faker.lorem.words(),
    sizeOnDisk: faker.number.int(),
    status: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    overview: faker.lorem.words(),
    inCinemas: faker.date.past(),
    physicalRelease: faker.date.past(),
    digitalRelease: faker.date.past(),
    releaseDate: faker.date.past(),
    physicalReleaseNote: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    website: faker.lorem.words(),
    remotePoster: faker.lorem.words(),
    year: faker.number.int(),
    youTubeTrailerId: faker.string.uuid(),
    studio: faker.lorem.words(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    hasFile: faker.datatype.boolean(),
    movieFileId: faker.number.int(),
    monitored: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    isAvailable: faker.datatype.boolean(),
    folderName: faker.person.fullName(),
    runtime: faker.number.int(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    tmdbId: faker.number.int(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'movieOnly',
        'movieAndCollection',
        'none',
      ]),
      searchForMovie: faker.datatype.boolean(),
      addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
    },
    ratings: {
      imdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      tmdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      metacritic: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      rottenTomatoes: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      trakt: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
    },
    movieFile: {
      id: faker.number.int(),
      movieId: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      edition: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      originalFilePath: faker.lorem.words(),
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    collection: {
      title: faker.lorem.words(),
      tmdbId: faker.number.int(),
    },
    popularity: faker.number.int(),
    lastSearchTime: faker.date.past(),
    statistics: {
      movieFileCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
  }
}

export function getGetApiV3MovieId200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      sourceType: faker.helpers.arrayElement([
        'tmdb',
        'mappings',
        'user',
        'indexer',
      ]),
      movieMetadataId: faker.number.int(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
    })),
    secondaryYear: faker.number.int(),
    secondaryYearSourceId: faker.number.int(),
    sortTitle: faker.lorem.words(),
    sizeOnDisk: faker.number.int(),
    status: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    overview: faker.lorem.words(),
    inCinemas: faker.date.past(),
    physicalRelease: faker.date.past(),
    digitalRelease: faker.date.past(),
    releaseDate: faker.date.past(),
    physicalReleaseNote: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    website: faker.lorem.words(),
    remotePoster: faker.lorem.words(),
    year: faker.number.int(),
    youTubeTrailerId: faker.string.uuid(),
    studio: faker.lorem.words(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    hasFile: faker.datatype.boolean(),
    movieFileId: faker.number.int(),
    monitored: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    isAvailable: faker.datatype.boolean(),
    folderName: faker.person.fullName(),
    runtime: faker.number.int(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    tmdbId: faker.number.int(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'movieOnly',
        'movieAndCollection',
        'none',
      ]),
      searchForMovie: faker.datatype.boolean(),
      addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
    },
    ratings: {
      imdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      tmdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      metacritic: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      rottenTomatoes: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      trakt: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
    },
    movieFile: {
      id: faker.number.int(),
      movieId: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      edition: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      originalFilePath: faker.lorem.words(),
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    collection: {
      title: faker.lorem.words(),
      tmdbId: faker.number.int(),
    },
    popularity: faker.number.int(),
    lastSearchTime: faker.date.past(),
    statistics: {
      movieFileCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
  }
}

export function getGetApiV3Moviefile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    movieId: faker.number.int(),
    relativePath: faker.lorem.words(),
    path: faker.lorem.words(),
    size: faker.number.int(),
    dateAdded: faker.date.past(),
    sceneName: faker.person.fullName(),
    releaseGroup: faker.lorem.words(),
    edition: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    indexerFlags: faker.number.int(),
    mediaInfo: {
      id: faker.number.int(),
      audioBitrate: faker.number.int(),
      audioChannels: faker.number.int(),
      audioCodec: faker.lorem.words(),
      audioLanguages: faker.lorem.words(),
      audioStreamCount: faker.number.int(),
      videoBitDepth: faker.number.int(),
      videoBitrate: faker.number.int(),
      videoCodec: faker.lorem.words(),
      videoFps: faker.number.int(),
      videoDynamicRange: faker.lorem.words(),
      videoDynamicRangeType: faker.lorem.words(),
      resolution: faker.lorem.words(),
      runTime: faker.lorem.words(),
      scanType: faker.lorem.words(),
      subtitles: faker.lorem.words(),
    },
    originalFilePath: faker.lorem.words(),
    qualityCutoffNotMet: faker.datatype.boolean(),
  }))
}

export function getPutApiV3MoviefileId200Response() {
  return {
    id: faker.number.int(),
    movieId: faker.number.int(),
    relativePath: faker.lorem.words(),
    path: faker.lorem.words(),
    size: faker.number.int(),
    dateAdded: faker.date.past(),
    sceneName: faker.person.fullName(),
    releaseGroup: faker.lorem.words(),
    edition: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    indexerFlags: faker.number.int(),
    mediaInfo: {
      id: faker.number.int(),
      audioBitrate: faker.number.int(),
      audioChannels: faker.number.int(),
      audioCodec: faker.lorem.words(),
      audioLanguages: faker.lorem.words(),
      audioStreamCount: faker.number.int(),
      videoBitDepth: faker.number.int(),
      videoBitrate: faker.number.int(),
      videoCodec: faker.lorem.words(),
      videoFps: faker.number.int(),
      videoDynamicRange: faker.lorem.words(),
      videoDynamicRangeType: faker.lorem.words(),
      resolution: faker.lorem.words(),
      runTime: faker.lorem.words(),
      scanType: faker.lorem.words(),
      subtitles: faker.lorem.words(),
    },
    originalFilePath: faker.lorem.words(),
    qualityCutoffNotMet: faker.datatype.boolean(),
  }
}

export function getGetApiV3MoviefileId200Response() {
  return {
    id: faker.number.int(),
    movieId: faker.number.int(),
    relativePath: faker.lorem.words(),
    path: faker.lorem.words(),
    size: faker.number.int(),
    dateAdded: faker.date.past(),
    sceneName: faker.person.fullName(),
    releaseGroup: faker.lorem.words(),
    edition: faker.lorem.words(),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    indexerFlags: faker.number.int(),
    mediaInfo: {
      id: faker.number.int(),
      audioBitrate: faker.number.int(),
      audioChannels: faker.number.int(),
      audioCodec: faker.lorem.words(),
      audioLanguages: faker.lorem.words(),
      audioStreamCount: faker.number.int(),
      videoBitDepth: faker.number.int(),
      videoBitrate: faker.number.int(),
      videoCodec: faker.lorem.words(),
      videoFps: faker.number.int(),
      videoDynamicRange: faker.lorem.words(),
      videoDynamicRangeType: faker.lorem.words(),
      resolution: faker.lorem.words(),
      runTime: faker.lorem.words(),
      scanType: faker.lorem.words(),
      subtitles: faker.lorem.words(),
    },
    originalFilePath: faker.lorem.words(),
    qualityCutoffNotMet: faker.datatype.boolean(),
  }
}

export function getPostApiV3MovieImport200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    title: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      sourceType: faker.helpers.arrayElement([
        'tmdb',
        'mappings',
        'user',
        'indexer',
      ]),
      movieMetadataId: faker.number.int(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
    })),
    secondaryYear: faker.number.int(),
    secondaryYearSourceId: faker.number.int(),
    sortTitle: faker.lorem.words(),
    sizeOnDisk: faker.number.int(),
    status: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    overview: faker.lorem.words(),
    inCinemas: faker.date.past(),
    physicalRelease: faker.date.past(),
    digitalRelease: faker.date.past(),
    releaseDate: faker.date.past(),
    physicalReleaseNote: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    website: faker.lorem.words(),
    remotePoster: faker.lorem.words(),
    year: faker.number.int(),
    youTubeTrailerId: faker.string.uuid(),
    studio: faker.lorem.words(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    hasFile: faker.datatype.boolean(),
    movieFileId: faker.number.int(),
    monitored: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    isAvailable: faker.datatype.boolean(),
    folderName: faker.person.fullName(),
    runtime: faker.number.int(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    tmdbId: faker.number.int(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'movieOnly',
        'movieAndCollection',
        'none',
      ]),
      searchForMovie: faker.datatype.boolean(),
      addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
    },
    ratings: {
      imdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      tmdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      metacritic: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      rottenTomatoes: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      trakt: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
    },
    movieFile: {
      id: faker.number.int(),
      movieId: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      edition: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      originalFilePath: faker.lorem.words(),
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    collection: {
      title: faker.lorem.words(),
      tmdbId: faker.number.int(),
    },
    popularity: faker.number.int(),
    lastSearchTime: faker.date.past(),
    statistics: {
      movieFileCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
  }))
}

export function getGetApiV3MovieLookupTmdb200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      sourceType: faker.helpers.arrayElement([
        'tmdb',
        'mappings',
        'user',
        'indexer',
      ]),
      movieMetadataId: faker.number.int(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
    })),
    secondaryYear: faker.number.int(),
    secondaryYearSourceId: faker.number.int(),
    sortTitle: faker.lorem.words(),
    sizeOnDisk: faker.number.int(),
    status: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    overview: faker.lorem.words(),
    inCinemas: faker.date.past(),
    physicalRelease: faker.date.past(),
    digitalRelease: faker.date.past(),
    releaseDate: faker.date.past(),
    physicalReleaseNote: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    website: faker.lorem.words(),
    remotePoster: faker.lorem.words(),
    year: faker.number.int(),
    youTubeTrailerId: faker.string.uuid(),
    studio: faker.lorem.words(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    hasFile: faker.datatype.boolean(),
    movieFileId: faker.number.int(),
    monitored: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    isAvailable: faker.datatype.boolean(),
    folderName: faker.person.fullName(),
    runtime: faker.number.int(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    tmdbId: faker.number.int(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'movieOnly',
        'movieAndCollection',
        'none',
      ]),
      searchForMovie: faker.datatype.boolean(),
      addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
    },
    ratings: {
      imdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      tmdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      metacritic: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      rottenTomatoes: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      trakt: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
    },
    movieFile: {
      id: faker.number.int(),
      movieId: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      edition: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      originalFilePath: faker.lorem.words(),
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    collection: {
      title: faker.lorem.words(),
      tmdbId: faker.number.int(),
    },
    popularity: faker.number.int(),
    lastSearchTime: faker.date.past(),
    statistics: {
      movieFileCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
  }
}

export function getGetApiV3MovieLookupImdb200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      sourceType: faker.helpers.arrayElement([
        'tmdb',
        'mappings',
        'user',
        'indexer',
      ]),
      movieMetadataId: faker.number.int(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
    })),
    secondaryYear: faker.number.int(),
    secondaryYearSourceId: faker.number.int(),
    sortTitle: faker.lorem.words(),
    sizeOnDisk: faker.number.int(),
    status: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    overview: faker.lorem.words(),
    inCinemas: faker.date.past(),
    physicalRelease: faker.date.past(),
    digitalRelease: faker.date.past(),
    releaseDate: faker.date.past(),
    physicalReleaseNote: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    website: faker.lorem.words(),
    remotePoster: faker.lorem.words(),
    year: faker.number.int(),
    youTubeTrailerId: faker.string.uuid(),
    studio: faker.lorem.words(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    hasFile: faker.datatype.boolean(),
    movieFileId: faker.number.int(),
    monitored: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    isAvailable: faker.datatype.boolean(),
    folderName: faker.person.fullName(),
    runtime: faker.number.int(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    tmdbId: faker.number.int(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'movieOnly',
        'movieAndCollection',
        'none',
      ]),
      searchForMovie: faker.datatype.boolean(),
      addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
    },
    ratings: {
      imdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      tmdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      metacritic: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      rottenTomatoes: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      trakt: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
    },
    movieFile: {
      id: faker.number.int(),
      movieId: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      edition: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      originalFilePath: faker.lorem.words(),
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    collection: {
      title: faker.lorem.words(),
      tmdbId: faker.number.int(),
    },
    popularity: faker.number.int(),
    lastSearchTime: faker.date.past(),
    statistics: {
      movieFileCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
  }
}

export function getGetApiV3MovieLookup200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    title: faker.lorem.words(),
    originalTitle: faker.lorem.words(),
    originalLanguage: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
    alternateTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      sourceType: faker.helpers.arrayElement([
        'tmdb',
        'mappings',
        'user',
        'indexer',
      ]),
      movieMetadataId: faker.number.int(),
      title: faker.lorem.words(),
      cleanTitle: faker.lorem.words(),
    })),
    secondaryYear: faker.number.int(),
    secondaryYearSourceId: faker.number.int(),
    sortTitle: faker.lorem.words(),
    sizeOnDisk: faker.number.int(),
    status: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    overview: faker.lorem.words(),
    inCinemas: faker.date.past(),
    physicalRelease: faker.date.past(),
    digitalRelease: faker.date.past(),
    releaseDate: faker.date.past(),
    physicalReleaseNote: faker.lorem.words(),
    images: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      coverType: faker.helpers.arrayElement([
        'unknown',
        'poster',
        'banner',
        'fanart',
        'screenshot',
        'headshot',
        'clearlogo',
      ]),
      url: faker.internet.url(),
      remoteUrl: faker.internet.url(),
    })),
    website: faker.lorem.words(),
    remotePoster: faker.lorem.words(),
    year: faker.number.int(),
    youTubeTrailerId: faker.string.uuid(),
    studio: faker.lorem.words(),
    path: faker.lorem.words(),
    qualityProfileId: faker.number.int(),
    hasFile: faker.datatype.boolean(),
    movieFileId: faker.number.int(),
    monitored: faker.datatype.boolean(),
    minimumAvailability: faker.helpers.arrayElement([
      'tba',
      'announced',
      'inCinemas',
      'released',
      'deleted',
    ]),
    isAvailable: faker.datatype.boolean(),
    folderName: faker.person.fullName(),
    runtime: faker.number.int(),
    cleanTitle: faker.lorem.words(),
    imdbId: faker.string.uuid(),
    tmdbId: faker.number.int(),
    titleSlug: faker.lorem.words(),
    rootFolderPath: faker.lorem.words(),
    folder: faker.lorem.words(),
    certification: faker.lorem.words(),
    genres: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    added: faker.date.past(),
    addOptions: {
      ignoreEpisodesWithFiles: faker.datatype.boolean(),
      ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
      monitor: faker.helpers.arrayElement([
        'movieOnly',
        'movieAndCollection',
        'none',
      ]),
      searchForMovie: faker.datatype.boolean(),
      addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
    },
    ratings: {
      imdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      tmdb: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      metacritic: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      rottenTomatoes: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
      trakt: {
        votes: faker.number.int(),
        value: faker.number.int(),
        type: faker.helpers.arrayElement(['user', 'critic']),
      },
    },
    movieFile: {
      id: faker.number.int(),
      movieId: faker.number.int(),
      relativePath: faker.lorem.words(),
      path: faker.lorem.words(),
      size: faker.number.int(),
      dateAdded: faker.date.past(),
      sceneName: faker.person.fullName(),
      releaseGroup: faker.lorem.words(),
      edition: faker.lorem.words(),
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      indexerFlags: faker.number.int(),
      mediaInfo: {
        id: faker.number.int(),
        audioBitrate: faker.number.int(),
        audioChannels: faker.number.int(),
        audioCodec: faker.lorem.words(),
        audioLanguages: faker.lorem.words(),
        audioStreamCount: faker.number.int(),
        videoBitDepth: faker.number.int(),
        videoBitrate: faker.number.int(),
        videoCodec: faker.lorem.words(),
        videoFps: faker.number.int(),
        videoDynamicRange: faker.lorem.words(),
        videoDynamicRangeType: faker.lorem.words(),
        resolution: faker.lorem.words(),
        runTime: faker.lorem.words(),
        scanType: faker.lorem.words(),
        subtitles: faker.lorem.words(),
      },
      originalFilePath: faker.lorem.words(),
      qualityCutoffNotMet: faker.datatype.boolean(),
    },
    collection: {
      title: faker.lorem.words(),
      tmdbId: faker.number.int(),
    },
    popularity: faker.number.int(),
    lastSearchTime: faker.date.past(),
    statistics: {
      movieFileCount: faker.number.int(),
      sizeOnDisk: faker.number.int(),
      releaseGroups: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
  }))
}

export function getGetApiV3ConfigNaming200Response() {
  return {
    id: faker.number.int(),
    renameMovies: faker.datatype.boolean(),
    replaceIllegalCharacters: faker.datatype.boolean(),
    colonReplacementFormat: faker.helpers.arrayElement([
      'delete',
      'dash',
      'spaceDash',
      'spaceDashSpace',
      'smart',
    ]),
    standardMovieFormat: faker.lorem.words(),
    movieFolderFormat: faker.lorem.words(),
  }
}

export function getPutApiV3ConfigNamingId200Response() {
  return {
    id: faker.number.int(),
    renameMovies: faker.datatype.boolean(),
    replaceIllegalCharacters: faker.datatype.boolean(),
    colonReplacementFormat: faker.helpers.arrayElement([
      'delete',
      'dash',
      'spaceDash',
      'spaceDashSpace',
      'smart',
    ]),
    standardMovieFormat: faker.lorem.words(),
    movieFolderFormat: faker.lorem.words(),
  }
}

export function getGetApiV3ConfigNamingId200Response() {
  return {
    id: faker.number.int(),
    renameMovies: faker.datatype.boolean(),
    replaceIllegalCharacters: faker.datatype.boolean(),
    colonReplacementFormat: faker.helpers.arrayElement([
      'delete',
      'dash',
      'spaceDash',
      'spaceDashSpace',
      'smart',
    ]),
    standardMovieFormat: faker.lorem.words(),
    movieFolderFormat: faker.lorem.words(),
  }
}

export function getGetApiV3Notification200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onMovieAdded: faker.datatype.boolean(),
    onMovieDelete: faker.datatype.boolean(),
    onMovieFileDelete: faker.datatype.boolean(),
    onMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnMovieAdded: faker.datatype.boolean(),
    supportsOnMovieDelete: faker.datatype.boolean(),
    supportsOnMovieFileDelete: faker.datatype.boolean(),
    supportsOnMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }))
}

export function getPostApiV3Notification200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onMovieAdded: faker.datatype.boolean(),
    onMovieDelete: faker.datatype.boolean(),
    onMovieFileDelete: faker.datatype.boolean(),
    onMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnMovieAdded: faker.datatype.boolean(),
    supportsOnMovieDelete: faker.datatype.boolean(),
    supportsOnMovieFileDelete: faker.datatype.boolean(),
    supportsOnMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }
}

export function getPutApiV3NotificationId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onMovieAdded: faker.datatype.boolean(),
    onMovieDelete: faker.datatype.boolean(),
    onMovieFileDelete: faker.datatype.boolean(),
    onMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnMovieAdded: faker.datatype.boolean(),
    supportsOnMovieDelete: faker.datatype.boolean(),
    supportsOnMovieFileDelete: faker.datatype.boolean(),
    supportsOnMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }
}

export function getGetApiV3NotificationId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onMovieAdded: faker.datatype.boolean(),
    onMovieDelete: faker.datatype.boolean(),
    onMovieFileDelete: faker.datatype.boolean(),
    onMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnMovieAdded: faker.datatype.boolean(),
    supportsOnMovieDelete: faker.datatype.boolean(),
    supportsOnMovieFileDelete: faker.datatype.boolean(),
    supportsOnMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }
}

export function getGetApiV3NotificationSchema200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    fields: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      order: faker.number.int(),
      name: faker.person.fullName(),
      label: faker.lorem.words(),
      unit: faker.lorem.words(),
      helpText: faker.lorem.words(),
      helpTextWarning: faker.lorem.words(),
      helpLink: faker.lorem.words(),
      value: null,
      type: faker.lorem.words(),
      advanced: faker.datatype.boolean(),
      selectOptions: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        value: faker.number.int(),
        name: faker.person.fullName(),
        order: faker.number.int(),
        hint: faker.lorem.words(),
        dividerAfter: faker.datatype.boolean(),
      })),
      selectOptionsProviderAction: faker.lorem.words(),
      section: faker.lorem.words(),
      hidden: faker.lorem.words(),
      privacy: faker.helpers.arrayElement([
        'normal',
        'password',
        'apiKey',
        'userName',
      ]),
      placeholder: faker.lorem.words(),
      isFloat: faker.datatype.boolean(),
    })),
    implementationName: faker.person.fullName(),
    implementation: faker.lorem.words(),
    configContract: faker.lorem.words(),
    infoLink: faker.lorem.words(),
    message: {
      message: faker.lorem.words(),
      type: faker.helpers.arrayElement(['info', 'warning', 'error']),
    },
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    presets: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => null),
    link: faker.lorem.words(),
    onGrab: faker.datatype.boolean(),
    onDownload: faker.datatype.boolean(),
    onUpgrade: faker.datatype.boolean(),
    onRename: faker.datatype.boolean(),
    onMovieAdded: faker.datatype.boolean(),
    onMovieDelete: faker.datatype.boolean(),
    onMovieFileDelete: faker.datatype.boolean(),
    onMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    onHealthIssue: faker.datatype.boolean(),
    includeHealthWarnings: faker.datatype.boolean(),
    onHealthRestored: faker.datatype.boolean(),
    onApplicationUpdate: faker.datatype.boolean(),
    onManualInteractionRequired: faker.datatype.boolean(),
    supportsOnGrab: faker.datatype.boolean(),
    supportsOnDownload: faker.datatype.boolean(),
    supportsOnUpgrade: faker.datatype.boolean(),
    supportsOnRename: faker.datatype.boolean(),
    supportsOnMovieAdded: faker.datatype.boolean(),
    supportsOnMovieDelete: faker.datatype.boolean(),
    supportsOnMovieFileDelete: faker.datatype.boolean(),
    supportsOnMovieFileDeleteForUpgrade: faker.datatype.boolean(),
    supportsOnHealthIssue: faker.datatype.boolean(),
    supportsOnHealthRestored: faker.datatype.boolean(),
    supportsOnApplicationUpdate: faker.datatype.boolean(),
    supportsOnManualInteractionRequired: faker.datatype.boolean(),
    testCommand: faker.lorem.words(),
  }))
}

export function getGetApiV3Parse200Response() {
  return {
    id: faker.number.int(),
    title: faker.lorem.words(),
    parsedMovieInfo: {
      movieTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      originalTitle: faker.lorem.words(),
      releaseTitle: faker.lorem.words(),
      simpleReleaseTitle: faker.lorem.words(),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      releaseGroup: faker.lorem.words(),
      releaseHash: faker.lorem.words(),
      edition: faker.lorem.words(),
      year: faker.number.int(),
      imdbId: faker.string.uuid(),
      tmdbId: faker.number.int(),
      hardcodedSubs: faker.lorem.words(),
      movieTitle: faker.lorem.words(),
      primaryMovieTitle: faker.lorem.words(),
    },
    movie: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        sourceType: faker.helpers.arrayElement([
          'tmdb',
          'mappings',
          'user',
          'indexer',
        ]),
        movieMetadataId: faker.number.int(),
        title: faker.lorem.words(),
        cleanTitle: faker.lorem.words(),
      })),
      secondaryYear: faker.number.int(),
      secondaryYearSourceId: faker.number.int(),
      sortTitle: faker.lorem.words(),
      sizeOnDisk: faker.number.int(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      inCinemas: faker.date.past(),
      physicalRelease: faker.date.past(),
      digitalRelease: faker.date.past(),
      releaseDate: faker.date.past(),
      physicalReleaseNote: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      website: faker.lorem.words(),
      remotePoster: faker.lorem.words(),
      year: faker.number.int(),
      youTubeTrailerId: faker.string.uuid(),
      studio: faker.lorem.words(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      hasFile: faker.datatype.boolean(),
      movieFileId: faker.number.int(),
      monitored: faker.datatype.boolean(),
      minimumAvailability: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      isAvailable: faker.datatype.boolean(),
      folderName: faker.person.fullName(),
      runtime: faker.number.int(),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      tmdbId: faker.number.int(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'movieOnly',
          'movieAndCollection',
          'none',
        ]),
        searchForMovie: faker.datatype.boolean(),
        addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
      },
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      movieFile: {
        id: faker.number.int(),
        movieId: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        edition: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'cam',
              'telesync',
              'telecine',
              'workprint',
              'dvd',
              'tv',
              'webdl',
              'webrip',
              'bluray',
            ]),
            resolution: faker.number.int(),
            modifier: faker.helpers.arrayElement([
              'none',
              'regional',
              'screener',
              'rawhd',
              'brdisk',
              'remux',
            ]),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
                dividerAfter: faker.datatype.boolean(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        originalFilePath: faker.lorem.words(),
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      collection: {
        title: faker.lorem.words(),
        tmdbId: faker.number.int(),
      },
      popularity: faker.number.int(),
      lastSearchTime: faker.date.past(),
      statistics: {
        movieFileCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      },
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
  }
}

export function getGetPing200Response() {
  return {
    status: faker.lorem.words(),
  }
}

export function getHeadPing200Response() {
  return {
    status: faker.lorem.words(),
  }
}

export function getPutApiV3QualitydefinitionId200Response() {
  return {
    id: faker.number.int(),
    quality: {
      id: faker.number.int(),
      name: faker.person.fullName(),
      source: faker.helpers.arrayElement([
        'unknown',
        'cam',
        'telesync',
        'telecine',
        'workprint',
        'dvd',
        'tv',
        'webdl',
        'webrip',
        'bluray',
      ]),
      resolution: faker.number.int(),
      modifier: faker.helpers.arrayElement([
        'none',
        'regional',
        'screener',
        'rawhd',
        'brdisk',
        'remux',
      ]),
    },
    title: faker.lorem.words(),
    weight: faker.number.int(),
    minSize: faker.number.int(),
    maxSize: faker.number.int(),
    preferredSize: faker.number.int(),
  }
}

export function getGetApiV3QualitydefinitionId200Response() {
  return {
    id: faker.number.int(),
    quality: {
      id: faker.number.int(),
      name: faker.person.fullName(),
      source: faker.helpers.arrayElement([
        'unknown',
        'cam',
        'telesync',
        'telecine',
        'workprint',
        'dvd',
        'tv',
        'webdl',
        'webrip',
        'bluray',
      ]),
      resolution: faker.number.int(),
      modifier: faker.helpers.arrayElement([
        'none',
        'regional',
        'screener',
        'rawhd',
        'brdisk',
        'remux',
      ]),
    },
    title: faker.lorem.words(),
    weight: faker.number.int(),
    minSize: faker.number.int(),
    maxSize: faker.number.int(),
    preferredSize: faker.number.int(),
  }
}

export function getGetApiV3Qualitydefinition200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    quality: {
      id: faker.number.int(),
      name: faker.person.fullName(),
      source: faker.helpers.arrayElement([
        'unknown',
        'cam',
        'telesync',
        'telecine',
        'workprint',
        'dvd',
        'tv',
        'webdl',
        'webrip',
        'bluray',
      ]),
      resolution: faker.number.int(),
      modifier: faker.helpers.arrayElement([
        'none',
        'regional',
        'screener',
        'rawhd',
        'brdisk',
        'remux',
      ]),
    },
    title: faker.lorem.words(),
    weight: faker.number.int(),
    minSize: faker.number.int(),
    maxSize: faker.number.int(),
    preferredSize: faker.number.int(),
  }))
}

export function getPostApiV3Qualityprofile200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
    language: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
  }
}

export function getGetApiV3Qualityprofile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
    language: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
  }))
}

export function getPutApiV3QualityprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
    language: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
  }
}

export function getGetApiV3QualityprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
    language: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
  }
}

export function getGetApiV3QualityprofileSchema200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    upgradeAllowed: faker.datatype.boolean(),
    cutoff: faker.number.int(),
    items: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      items: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => null),
      allowed: faker.datatype.boolean(),
    })),
    minFormatScore: faker.number.int(),
    cutoffFormatScore: faker.number.int(),
    minUpgradeFormatScore: faker.number.int(),
    formatItems: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      format: faker.number.int(),
      name: faker.person.fullName(),
      score: faker.number.int(),
    })),
    language: {
      id: faker.number.int(),
      name: faker.person.fullName(),
    },
  }
}

export function getGetApiV3Queue200Response() {
  return {
    page: faker.number.int(),
    pageSize: faker.number.int(),
    sortKey: faker.lorem.words(),
    sortDirection: faker.helpers.arrayElement([
      'default',
      'ascending',
      'descending',
    ]),
    totalRecords: faker.number.int(),
    records: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      movieId: faker.number.int(),
      movie: {
        id: faker.number.int(),
        title: faker.lorem.words(),
        originalTitle: faker.lorem.words(),
        originalLanguage: {
          id: faker.number.int(),
          name: faker.person.fullName(),
        },
        alternateTitles: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          sourceType: faker.helpers.arrayElement([
            'tmdb',
            'mappings',
            'user',
            'indexer',
          ]),
          movieMetadataId: faker.number.int(),
          title: faker.lorem.words(),
          cleanTitle: faker.lorem.words(),
        })),
        secondaryYear: faker.number.int(),
        secondaryYearSourceId: faker.number.int(),
        sortTitle: faker.lorem.words(),
        sizeOnDisk: faker.number.int(),
        status: faker.helpers.arrayElement([
          'tba',
          'announced',
          'inCinemas',
          'released',
          'deleted',
        ]),
        overview: faker.lorem.words(),
        inCinemas: faker.date.past(),
        physicalRelease: faker.date.past(),
        digitalRelease: faker.date.past(),
        releaseDate: faker.date.past(),
        physicalReleaseNote: faker.lorem.words(),
        images: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          coverType: faker.helpers.arrayElement([
            'unknown',
            'poster',
            'banner',
            'fanart',
            'screenshot',
            'headshot',
            'clearlogo',
          ]),
          url: faker.internet.url(),
          remoteUrl: faker.internet.url(),
        })),
        website: faker.lorem.words(),
        remotePoster: faker.lorem.words(),
        year: faker.number.int(),
        youTubeTrailerId: faker.string.uuid(),
        studio: faker.lorem.words(),
        path: faker.lorem.words(),
        qualityProfileId: faker.number.int(),
        hasFile: faker.datatype.boolean(),
        movieFileId: faker.number.int(),
        monitored: faker.datatype.boolean(),
        minimumAvailability: faker.helpers.arrayElement([
          'tba',
          'announced',
          'inCinemas',
          'released',
          'deleted',
        ]),
        isAvailable: faker.datatype.boolean(),
        folderName: faker.person.fullName(),
        runtime: faker.number.int(),
        cleanTitle: faker.lorem.words(),
        imdbId: faker.string.uuid(),
        tmdbId: faker.number.int(),
        titleSlug: faker.lorem.words(),
        rootFolderPath: faker.lorem.words(),
        folder: faker.lorem.words(),
        certification: faker.lorem.words(),
        genres: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
        tags: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.number.int()),
        added: faker.date.past(),
        addOptions: {
          ignoreEpisodesWithFiles: faker.datatype.boolean(),
          ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
          monitor: faker.helpers.arrayElement([
            'movieOnly',
            'movieAndCollection',
            'none',
          ]),
          searchForMovie: faker.datatype.boolean(),
          addMethod: faker.helpers.arrayElement([
            'manual',
            'list',
            'collection',
          ]),
        },
        ratings: {
          imdb: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          tmdb: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          metacritic: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          rottenTomatoes: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
          trakt: {
            votes: faker.number.int(),
            value: faker.number.int(),
            type: faker.helpers.arrayElement(['user', 'critic']),
          },
        },
        movieFile: {
          id: faker.number.int(),
          movieId: faker.number.int(),
          relativePath: faker.lorem.words(),
          path: faker.lorem.words(),
          size: faker.number.int(),
          dateAdded: faker.date.past(),
          sceneName: faker.person.fullName(),
          releaseGroup: faker.lorem.words(),
          edition: faker.lorem.words(),
          languages: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
          })),
          quality: {
            quality: {
              id: faker.number.int(),
              name: faker.person.fullName(),
              source: faker.helpers.arrayElement([
                'unknown',
                'cam',
                'telesync',
                'telecine',
                'workprint',
                'dvd',
                'tv',
                'webdl',
                'webrip',
                'bluray',
              ]),
              resolution: faker.number.int(),
              modifier: faker.helpers.arrayElement([
                'none',
                'regional',
                'screener',
                'rawhd',
                'brdisk',
                'remux',
              ]),
            },
            revision: {
              version: faker.number.int(),
              real: faker.number.int(),
              isRepack: faker.datatype.boolean(),
            },
          },
          customFormats: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            includeCustomFormatWhenRenaming: faker.datatype.boolean(),
            specifications: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              id: faker.number.int(),
              name: faker.person.fullName(),
              implementation: faker.lorem.words(),
              implementationName: faker.person.fullName(),
              infoLink: faker.lorem.words(),
              negate: faker.datatype.boolean(),
              required: faker.datatype.boolean(),
              fields: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                order: faker.number.int(),
                name: faker.person.fullName(),
                label: faker.lorem.words(),
                unit: faker.lorem.words(),
                helpText: faker.lorem.words(),
                helpTextWarning: faker.lorem.words(),
                helpLink: faker.lorem.words(),
                value: null,
                type: faker.lorem.words(),
                advanced: faker.datatype.boolean(),
                selectOptions: [
                  ...new Array(
                    faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                  ).keys(),
                ].map((_) => ({
                  value: faker.number.int(),
                  name: faker.person.fullName(),
                  order: faker.number.int(),
                  hint: faker.lorem.words(),
                  dividerAfter: faker.datatype.boolean(),
                })),
                selectOptionsProviderAction: faker.lorem.words(),
                section: faker.lorem.words(),
                hidden: faker.lorem.words(),
                privacy: faker.helpers.arrayElement([
                  'normal',
                  'password',
                  'apiKey',
                  'userName',
                ]),
                placeholder: faker.lorem.words(),
                isFloat: faker.datatype.boolean(),
              })),
              presets: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => null),
            })),
          })),
          customFormatScore: faker.number.int(),
          indexerFlags: faker.number.int(),
          mediaInfo: {
            id: faker.number.int(),
            audioBitrate: faker.number.int(),
            audioChannels: faker.number.int(),
            audioCodec: faker.lorem.words(),
            audioLanguages: faker.lorem.words(),
            audioStreamCount: faker.number.int(),
            videoBitDepth: faker.number.int(),
            videoBitrate: faker.number.int(),
            videoCodec: faker.lorem.words(),
            videoFps: faker.number.int(),
            videoDynamicRange: faker.lorem.words(),
            videoDynamicRangeType: faker.lorem.words(),
            resolution: faker.lorem.words(),
            runTime: faker.lorem.words(),
            scanType: faker.lorem.words(),
            subtitles: faker.lorem.words(),
          },
          originalFilePath: faker.lorem.words(),
          qualityCutoffNotMet: faker.datatype.boolean(),
        },
        collection: {
          title: faker.lorem.words(),
          tmdbId: faker.number.int(),
        },
        popularity: faker.number.int(),
        lastSearchTime: faker.date.past(),
        statistics: {
          movieFileCount: faker.number.int(),
          sizeOnDisk: faker.number.int(),
          releaseGroups: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => faker.lorem.words()),
        },
      },
      languages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
      })),
      quality: {
        quality: {
          id: faker.number.int(),
          name: faker.person.fullName(),
          source: faker.helpers.arrayElement([
            'unknown',
            'cam',
            'telesync',
            'telecine',
            'workprint',
            'dvd',
            'tv',
            'webdl',
            'webrip',
            'bluray',
          ]),
          resolution: faker.number.int(),
          modifier: faker.helpers.arrayElement([
            'none',
            'regional',
            'screener',
            'rawhd',
            'brdisk',
            'remux',
          ]),
        },
        revision: {
          version: faker.number.int(),
          real: faker.number.int(),
          isRepack: faker.datatype.boolean(),
        },
      },
      customFormats: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        includeCustomFormatWhenRenaming: faker.datatype.boolean(),
        specifications: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          implementation: faker.lorem.words(),
          implementationName: faker.person.fullName(),
          infoLink: faker.lorem.words(),
          negate: faker.datatype.boolean(),
          required: faker.datatype.boolean(),
          fields: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            order: faker.number.int(),
            name: faker.person.fullName(),
            label: faker.lorem.words(),
            unit: faker.lorem.words(),
            helpText: faker.lorem.words(),
            helpTextWarning: faker.lorem.words(),
            helpLink: faker.lorem.words(),
            value: null,
            type: faker.lorem.words(),
            advanced: faker.datatype.boolean(),
            selectOptions: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              value: faker.number.int(),
              name: faker.person.fullName(),
              order: faker.number.int(),
              hint: faker.lorem.words(),
              dividerAfter: faker.datatype.boolean(),
            })),
            selectOptionsProviderAction: faker.lorem.words(),
            section: faker.lorem.words(),
            hidden: faker.lorem.words(),
            privacy: faker.helpers.arrayElement([
              'normal',
              'password',
              'apiKey',
              'userName',
            ]),
            placeholder: faker.lorem.words(),
            isFloat: faker.datatype.boolean(),
          })),
          presets: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => null),
        })),
      })),
      customFormatScore: faker.number.int(),
      size: faker.number.int(),
      title: faker.lorem.words(),
      estimatedCompletionTime: faker.date.past(),
      added: faker.date.past(),
      status: faker.helpers.arrayElement([
        'unknown',
        'queued',
        'paused',
        'downloading',
        'completed',
        'failed',
        'warning',
        'delay',
        'downloadClientUnavailable',
        'fallback',
      ]),
      trackedDownloadStatus: faker.helpers.arrayElement([
        'ok',
        'warning',
        'error',
      ]),
      trackedDownloadState: faker.helpers.arrayElement([
        'downloading',
        'importBlocked',
        'importPending',
        'importing',
        'imported',
        'failedPending',
        'failed',
        'ignored',
      ]),
      statusMessages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        title: faker.lorem.words(),
        messages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      })),
      errorMessage: faker.lorem.words(),
      downloadId: faker.string.uuid(),
      protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
      downloadClient: faker.lorem.words(),
      downloadClientHasPostImportCategory: faker.datatype.boolean(),
      indexer: faker.lorem.words(),
      outputPath: faker.lorem.words(),
      sizeleft: faker.number.int(),
      timeleft: faker.lorem.words(),
    })),
  }
}

export function getGetApiV3QueueDetails200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    movieId: faker.number.int(),
    movie: {
      id: faker.number.int(),
      title: faker.lorem.words(),
      originalTitle: faker.lorem.words(),
      originalLanguage: {
        id: faker.number.int(),
        name: faker.person.fullName(),
      },
      alternateTitles: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        sourceType: faker.helpers.arrayElement([
          'tmdb',
          'mappings',
          'user',
          'indexer',
        ]),
        movieMetadataId: faker.number.int(),
        title: faker.lorem.words(),
        cleanTitle: faker.lorem.words(),
      })),
      secondaryYear: faker.number.int(),
      secondaryYearSourceId: faker.number.int(),
      sortTitle: faker.lorem.words(),
      sizeOnDisk: faker.number.int(),
      status: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      overview: faker.lorem.words(),
      inCinemas: faker.date.past(),
      physicalRelease: faker.date.past(),
      digitalRelease: faker.date.past(),
      releaseDate: faker.date.past(),
      physicalReleaseNote: faker.lorem.words(),
      images: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        coverType: faker.helpers.arrayElement([
          'unknown',
          'poster',
          'banner',
          'fanart',
          'screenshot',
          'headshot',
          'clearlogo',
        ]),
        url: faker.internet.url(),
        remoteUrl: faker.internet.url(),
      })),
      website: faker.lorem.words(),
      remotePoster: faker.lorem.words(),
      year: faker.number.int(),
      youTubeTrailerId: faker.string.uuid(),
      studio: faker.lorem.words(),
      path: faker.lorem.words(),
      qualityProfileId: faker.number.int(),
      hasFile: faker.datatype.boolean(),
      movieFileId: faker.number.int(),
      monitored: faker.datatype.boolean(),
      minimumAvailability: faker.helpers.arrayElement([
        'tba',
        'announced',
        'inCinemas',
        'released',
        'deleted',
      ]),
      isAvailable: faker.datatype.boolean(),
      folderName: faker.person.fullName(),
      runtime: faker.number.int(),
      cleanTitle: faker.lorem.words(),
      imdbId: faker.string.uuid(),
      tmdbId: faker.number.int(),
      titleSlug: faker.lorem.words(),
      rootFolderPath: faker.lorem.words(),
      folder: faker.lorem.words(),
      certification: faker.lorem.words(),
      genres: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      tags: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.number.int()),
      added: faker.date.past(),
      addOptions: {
        ignoreEpisodesWithFiles: faker.datatype.boolean(),
        ignoreEpisodesWithoutFiles: faker.datatype.boolean(),
        monitor: faker.helpers.arrayElement([
          'movieOnly',
          'movieAndCollection',
          'none',
        ]),
        searchForMovie: faker.datatype.boolean(),
        addMethod: faker.helpers.arrayElement(['manual', 'list', 'collection']),
      },
      ratings: {
        imdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        tmdb: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        metacritic: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        rottenTomatoes: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
        trakt: {
          votes: faker.number.int(),
          value: faker.number.int(),
          type: faker.helpers.arrayElement(['user', 'critic']),
        },
      },
      movieFile: {
        id: faker.number.int(),
        movieId: faker.number.int(),
        relativePath: faker.lorem.words(),
        path: faker.lorem.words(),
        size: faker.number.int(),
        dateAdded: faker.date.past(),
        sceneName: faker.person.fullName(),
        releaseGroup: faker.lorem.words(),
        edition: faker.lorem.words(),
        languages: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
        })),
        quality: {
          quality: {
            id: faker.number.int(),
            name: faker.person.fullName(),
            source: faker.helpers.arrayElement([
              'unknown',
              'cam',
              'telesync',
              'telecine',
              'workprint',
              'dvd',
              'tv',
              'webdl',
              'webrip',
              'bluray',
            ]),
            resolution: faker.number.int(),
            modifier: faker.helpers.arrayElement([
              'none',
              'regional',
              'screener',
              'rawhd',
              'brdisk',
              'remux',
            ]),
          },
          revision: {
            version: faker.number.int(),
            real: faker.number.int(),
            isRepack: faker.datatype.boolean(),
          },
        },
        customFormats: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          id: faker.number.int(),
          name: faker.person.fullName(),
          includeCustomFormatWhenRenaming: faker.datatype.boolean(),
          specifications: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            id: faker.number.int(),
            name: faker.person.fullName(),
            implementation: faker.lorem.words(),
            implementationName: faker.person.fullName(),
            infoLink: faker.lorem.words(),
            negate: faker.datatype.boolean(),
            required: faker.datatype.boolean(),
            fields: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => ({
              order: faker.number.int(),
              name: faker.person.fullName(),
              label: faker.lorem.words(),
              unit: faker.lorem.words(),
              helpText: faker.lorem.words(),
              helpTextWarning: faker.lorem.words(),
              helpLink: faker.lorem.words(),
              value: null,
              type: faker.lorem.words(),
              advanced: faker.datatype.boolean(),
              selectOptions: [
                ...new Array(
                  faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
                ).keys(),
              ].map((_) => ({
                value: faker.number.int(),
                name: faker.person.fullName(),
                order: faker.number.int(),
                hint: faker.lorem.words(),
                dividerAfter: faker.datatype.boolean(),
              })),
              selectOptionsProviderAction: faker.lorem.words(),
              section: faker.lorem.words(),
              hidden: faker.lorem.words(),
              privacy: faker.helpers.arrayElement([
                'normal',
                'password',
                'apiKey',
                'userName',
              ]),
              placeholder: faker.lorem.words(),
              isFloat: faker.datatype.boolean(),
            })),
            presets: [
              ...new Array(
                faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
              ).keys(),
            ].map((_) => null),
          })),
        })),
        customFormatScore: faker.number.int(),
        indexerFlags: faker.number.int(),
        mediaInfo: {
          id: faker.number.int(),
          audioBitrate: faker.number.int(),
          audioChannels: faker.number.int(),
          audioCodec: faker.lorem.words(),
          audioLanguages: faker.lorem.words(),
          audioStreamCount: faker.number.int(),
          videoBitDepth: faker.number.int(),
          videoBitrate: faker.number.int(),
          videoCodec: faker.lorem.words(),
          videoFps: faker.number.int(),
          videoDynamicRange: faker.lorem.words(),
          videoDynamicRangeType: faker.lorem.words(),
          resolution: faker.lorem.words(),
          runTime: faker.lorem.words(),
          scanType: faker.lorem.words(),
          subtitles: faker.lorem.words(),
        },
        originalFilePath: faker.lorem.words(),
        qualityCutoffNotMet: faker.datatype.boolean(),
      },
      collection: {
        title: faker.lorem.words(),
        tmdbId: faker.number.int(),
      },
      popularity: faker.number.int(),
      lastSearchTime: faker.date.past(),
      statistics: {
        movieFileCount: faker.number.int(),
        sizeOnDisk: faker.number.int(),
        releaseGroups: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => faker.lorem.words()),
      },
    },
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    size: faker.number.int(),
    title: faker.lorem.words(),
    estimatedCompletionTime: faker.date.past(),
    added: faker.date.past(),
    status: faker.helpers.arrayElement([
      'unknown',
      'queued',
      'paused',
      'downloading',
      'completed',
      'failed',
      'warning',
      'delay',
      'downloadClientUnavailable',
      'fallback',
    ]),
    trackedDownloadStatus: faker.helpers.arrayElement([
      'ok',
      'warning',
      'error',
    ]),
    trackedDownloadState: faker.helpers.arrayElement([
      'downloading',
      'importBlocked',
      'importPending',
      'importing',
      'imported',
      'failedPending',
      'failed',
      'ignored',
    ]),
    statusMessages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      title: faker.lorem.words(),
      messages: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    })),
    errorMessage: faker.lorem.words(),
    downloadId: faker.string.uuid(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    downloadClient: faker.lorem.words(),
    downloadClientHasPostImportCategory: faker.datatype.boolean(),
    indexer: faker.lorem.words(),
    outputPath: faker.lorem.words(),
    sizeleft: faker.number.int(),
    timeleft: faker.lorem.words(),
  }))
}

export function getGetApiV3QueueStatus200Response() {
  return {
    id: faker.number.int(),
    totalCount: faker.number.int(),
    count: faker.number.int(),
    unknownCount: faker.number.int(),
    errors: faker.datatype.boolean(),
    warnings: faker.datatype.boolean(),
    unknownErrors: faker.datatype.boolean(),
    unknownWarnings: faker.datatype.boolean(),
  }
}

export function getGetApiV3Release200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    guid: faker.string.uuid(),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    qualityWeight: faker.number.int(),
    age: faker.number.int(),
    ageHours: faker.number.int(),
    ageMinutes: faker.number.int(),
    size: faker.number.int(),
    indexerId: faker.number.int(),
    indexer: faker.lorem.words(),
    releaseGroup: faker.lorem.words(),
    subGroup: faker.lorem.words(),
    releaseHash: faker.lorem.words(),
    title: faker.lorem.words(),
    sceneSource: faker.datatype.boolean(),
    movieTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    mappedMovieId: faker.number.int(),
    approved: faker.datatype.boolean(),
    temporarilyRejected: faker.datatype.boolean(),
    rejected: faker.datatype.boolean(),
    tmdbId: faker.number.int(),
    imdbId: faker.number.int(),
    rejections: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    publishDate: faker.date.past(),
    commentUrl: faker.internet.url(),
    downloadUrl: faker.internet.url(),
    infoUrl: faker.internet.url(),
    movieRequested: faker.datatype.boolean(),
    downloadAllowed: faker.datatype.boolean(),
    releaseWeight: faker.number.int(),
    edition: faker.lorem.words(),
    magnetUrl: faker.internet.url(),
    infoHash: faker.lorem.words(),
    seeders: faker.number.int(),
    leechers: faker.number.int(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    indexerFlags: null,
    movieId: faker.number.int(),
    downloadClientId: faker.number.int(),
    downloadClient: faker.lorem.words(),
    shouldOverride: faker.datatype.boolean(),
  }))
}

export function getPostApiV3Releaseprofile200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    enabled: faker.datatype.boolean(),
    required: null,
    ignored: null,
    indexerId: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3Releaseprofile200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    enabled: faker.datatype.boolean(),
    required: null,
    ignored: null,
    indexerId: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }))
}

export function getPutApiV3ReleaseprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    enabled: faker.datatype.boolean(),
    required: null,
    ignored: null,
    indexerId: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3ReleaseprofileId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    enabled: faker.datatype.boolean(),
    required: null,
    ignored: null,
    indexerId: faker.number.int(),
    tags: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getPostApiV3ReleasePush200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    guid: faker.string.uuid(),
    quality: {
      quality: {
        id: faker.number.int(),
        name: faker.person.fullName(),
        source: faker.helpers.arrayElement([
          'unknown',
          'cam',
          'telesync',
          'telecine',
          'workprint',
          'dvd',
          'tv',
          'webdl',
          'webrip',
          'bluray',
        ]),
        resolution: faker.number.int(),
        modifier: faker.helpers.arrayElement([
          'none',
          'regional',
          'screener',
          'rawhd',
          'brdisk',
          'remux',
        ]),
      },
      revision: {
        version: faker.number.int(),
        real: faker.number.int(),
        isRepack: faker.datatype.boolean(),
      },
    },
    customFormats: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
      includeCustomFormatWhenRenaming: faker.datatype.boolean(),
      specifications: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => ({
        id: faker.number.int(),
        name: faker.person.fullName(),
        implementation: faker.lorem.words(),
        implementationName: faker.person.fullName(),
        infoLink: faker.lorem.words(),
        negate: faker.datatype.boolean(),
        required: faker.datatype.boolean(),
        fields: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => ({
          order: faker.number.int(),
          name: faker.person.fullName(),
          label: faker.lorem.words(),
          unit: faker.lorem.words(),
          helpText: faker.lorem.words(),
          helpTextWarning: faker.lorem.words(),
          helpLink: faker.lorem.words(),
          value: null,
          type: faker.lorem.words(),
          advanced: faker.datatype.boolean(),
          selectOptions: [
            ...new Array(
              faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
            ).keys(),
          ].map((_) => ({
            value: faker.number.int(),
            name: faker.person.fullName(),
            order: faker.number.int(),
            hint: faker.lorem.words(),
            dividerAfter: faker.datatype.boolean(),
          })),
          selectOptionsProviderAction: faker.lorem.words(),
          section: faker.lorem.words(),
          hidden: faker.lorem.words(),
          privacy: faker.helpers.arrayElement([
            'normal',
            'password',
            'apiKey',
            'userName',
          ]),
          placeholder: faker.lorem.words(),
          isFloat: faker.datatype.boolean(),
        })),
        presets: [
          ...new Array(
            faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
          ).keys(),
        ].map((_) => null),
      })),
    })),
    customFormatScore: faker.number.int(),
    qualityWeight: faker.number.int(),
    age: faker.number.int(),
    ageHours: faker.number.int(),
    ageMinutes: faker.number.int(),
    size: faker.number.int(),
    indexerId: faker.number.int(),
    indexer: faker.lorem.words(),
    releaseGroup: faker.lorem.words(),
    subGroup: faker.lorem.words(),
    releaseHash: faker.lorem.words(),
    title: faker.lorem.words(),
    sceneSource: faker.datatype.boolean(),
    movieTitles: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    languages: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      id: faker.number.int(),
      name: faker.person.fullName(),
    })),
    mappedMovieId: faker.number.int(),
    approved: faker.datatype.boolean(),
    temporarilyRejected: faker.datatype.boolean(),
    rejected: faker.datatype.boolean(),
    tmdbId: faker.number.int(),
    imdbId: faker.number.int(),
    rejections: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.lorem.words()),
    publishDate: faker.date.past(),
    commentUrl: faker.internet.url(),
    downloadUrl: faker.internet.url(),
    infoUrl: faker.internet.url(),
    movieRequested: faker.datatype.boolean(),
    downloadAllowed: faker.datatype.boolean(),
    releaseWeight: faker.number.int(),
    edition: faker.lorem.words(),
    magnetUrl: faker.internet.url(),
    infoHash: faker.lorem.words(),
    seeders: faker.number.int(),
    leechers: faker.number.int(),
    protocol: faker.helpers.arrayElement(['unknown', 'usenet', 'torrent']),
    indexerFlags: null,
    movieId: faker.number.int(),
    downloadClientId: faker.number.int(),
    downloadClient: faker.lorem.words(),
    shouldOverride: faker.datatype.boolean(),
  }))
}

export function getPostApiV3Remotepathmapping200Response() {
  return {
    id: faker.number.int(),
    host: faker.lorem.words(),
    remotePath: faker.lorem.words(),
    localPath: faker.lorem.words(),
  }
}

export function getGetApiV3Remotepathmapping200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    host: faker.lorem.words(),
    remotePath: faker.lorem.words(),
    localPath: faker.lorem.words(),
  }))
}

export function getPutApiV3RemotepathmappingId200Response() {
  return {
    id: faker.number.int(),
    host: faker.lorem.words(),
    remotePath: faker.lorem.words(),
    localPath: faker.lorem.words(),
  }
}

export function getGetApiV3RemotepathmappingId200Response() {
  return {
    id: faker.number.int(),
    host: faker.lorem.words(),
    remotePath: faker.lorem.words(),
    localPath: faker.lorem.words(),
  }
}

export function getGetApiV3Rename200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    movieId: faker.number.int(),
    movieFileId: faker.number.int(),
    existingPath: faker.lorem.words(),
    newPath: faker.lorem.words(),
  }))
}

export function getPostApiV3Rootfolder200Response() {
  return {
    id: faker.number.int(),
    path: faker.lorem.words(),
    accessible: faker.datatype.boolean(),
    freeSpace: faker.number.int(),
    unmappedFolders: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      path: faker.lorem.words(),
      relativePath: faker.lorem.words(),
    })),
  }
}

export function getGetApiV3Rootfolder200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    path: faker.lorem.words(),
    accessible: faker.datatype.boolean(),
    freeSpace: faker.number.int(),
    unmappedFolders: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      path: faker.lorem.words(),
      relativePath: faker.lorem.words(),
    })),
  }))
}

export function getGetApiV3RootfolderId200Response() {
  return {
    id: faker.number.int(),
    path: faker.lorem.words(),
    accessible: faker.datatype.boolean(),
    freeSpace: faker.number.int(),
    unmappedFolders: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => ({
      name: faker.person.fullName(),
      path: faker.lorem.words(),
      relativePath: faker.lorem.words(),
    })),
  }
}

export function getGetApiV3SystemStatus200Response() {
  return {
    appName: faker.person.fullName(),
    instanceName: faker.person.fullName(),
    version: faker.lorem.words(),
    buildTime: faker.date.past(),
    isDebug: faker.datatype.boolean(),
    isProduction: faker.datatype.boolean(),
    isAdmin: faker.datatype.boolean(),
    isUserInteractive: faker.datatype.boolean(),
    startupPath: faker.lorem.words(),
    appData: faker.lorem.words(),
    osName: faker.person.fullName(),
    osVersion: faker.lorem.words(),
    isNetCore: faker.datatype.boolean(),
    isLinux: faker.datatype.boolean(),
    isOsx: faker.datatype.boolean(),
    isWindows: faker.datatype.boolean(),
    isDocker: faker.datatype.boolean(),
    mode: faker.helpers.arrayElement(['console', 'service', 'tray']),
    branch: faker.lorem.words(),
    databaseType: faker.helpers.arrayElement(['sqLite', 'postgreSQL']),
    databaseVersion: faker.lorem.words(),
    authentication: faker.helpers.arrayElement([
      'none',
      'basic',
      'forms',
      'external',
    ]),
    migrationVersion: faker.number.int(),
    urlBase: faker.internet.url(),
    runtimeVersion: faker.lorem.words(),
    runtimeName: faker.person.fullName(),
    startTime: faker.date.past(),
    packageVersion: faker.lorem.words(),
    packageAuthor: faker.lorem.words(),
    packageUpdateMechanism: faker.helpers.arrayElement([
      'builtIn',
      'script',
      'external',
      'apt',
      'docker',
    ]),
    packageUpdateMechanismMessage: faker.lorem.words(),
  }
}

export function getGetApiV3Tag200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    label: faker.lorem.words(),
  }))
}

export function getPostApiV3Tag200Response() {
  return {
    id: faker.number.int(),
    label: faker.lorem.words(),
  }
}

export function getPutApiV3TagId200Response() {
  return {
    id: faker.number.int(),
    label: faker.lorem.words(),
  }
}

export function getGetApiV3TagId200Response() {
  return {
    id: faker.number.int(),
    label: faker.lorem.words(),
  }
}

export function getGetApiV3TagDetail200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    label: faker.lorem.words(),
    delayProfileIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    importListIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    notificationIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    releaseProfileIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    indexerIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    downloadClientIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    autoTagIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    movieIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }))
}

export function getGetApiV3TagDetailId200Response() {
  return {
    id: faker.number.int(),
    label: faker.lorem.words(),
    delayProfileIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    importListIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    notificationIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    releaseProfileIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    indexerIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    downloadClientIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    autoTagIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
    movieIds: [
      ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
    ].map((_) => faker.number.int()),
  }
}

export function getGetApiV3SystemTask200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    name: faker.person.fullName(),
    taskName: faker.person.fullName(),
    interval: faker.number.int(),
    lastExecution: faker.date.past(),
    lastStartTime: faker.date.past(),
    nextExecution: faker.date.past(),
    lastDuration: faker.lorem.words(),
  }))
}

export function getGetApiV3SystemTaskId200Response() {
  return {
    id: faker.number.int(),
    name: faker.person.fullName(),
    taskName: faker.person.fullName(),
    interval: faker.number.int(),
    lastExecution: faker.date.past(),
    lastStartTime: faker.date.past(),
    nextExecution: faker.date.past(),
    lastDuration: faker.lorem.words(),
  }
}

export function getPutApiV3ConfigUiId200Response() {
  return {
    id: faker.number.int(),
    firstDayOfWeek: faker.number.int(),
    calendarWeekColumnHeader: faker.lorem.words(),
    movieRuntimeFormat: faker.helpers.arrayElement(['hoursMinutes', 'minutes']),
    shortDateFormat: faker.lorem.words(),
    longDateFormat: faker.lorem.words(),
    timeFormat: faker.lorem.words(),
    showRelativeDates: faker.datatype.boolean(),
    enableColorImpairedMode: faker.datatype.boolean(),
    movieInfoLanguage: faker.number.int(),
    uiLanguage: faker.number.int(),
    theme: faker.lorem.words(),
  }
}

export function getGetApiV3ConfigUiId200Response() {
  return {
    id: faker.number.int(),
    firstDayOfWeek: faker.number.int(),
    calendarWeekColumnHeader: faker.lorem.words(),
    movieRuntimeFormat: faker.helpers.arrayElement(['hoursMinutes', 'minutes']),
    shortDateFormat: faker.lorem.words(),
    longDateFormat: faker.lorem.words(),
    timeFormat: faker.lorem.words(),
    showRelativeDates: faker.datatype.boolean(),
    enableColorImpairedMode: faker.datatype.boolean(),
    movieInfoLanguage: faker.number.int(),
    uiLanguage: faker.number.int(),
    theme: faker.lorem.words(),
  }
}

export function getGetApiV3ConfigUi200Response() {
  return {
    id: faker.number.int(),
    firstDayOfWeek: faker.number.int(),
    calendarWeekColumnHeader: faker.lorem.words(),
    movieRuntimeFormat: faker.helpers.arrayElement(['hoursMinutes', 'minutes']),
    shortDateFormat: faker.lorem.words(),
    longDateFormat: faker.lorem.words(),
    timeFormat: faker.lorem.words(),
    showRelativeDates: faker.datatype.boolean(),
    enableColorImpairedMode: faker.datatype.boolean(),
    movieInfoLanguage: faker.number.int(),
    uiLanguage: faker.number.int(),
    theme: faker.lorem.words(),
  }
}

export function getGetApiV3Update200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    version: faker.lorem.words(),
    branch: faker.lorem.words(),
    releaseDate: faker.date.past(),
    fileName: faker.person.fullName(),
    url: faker.internet.url(),
    installed: faker.datatype.boolean(),
    installedOn: faker.date.past(),
    installable: faker.datatype.boolean(),
    latest: faker.datatype.boolean(),
    changes: {
      new: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
      fixed: [
        ...new Array(
          faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH }),
        ).keys(),
      ].map((_) => faker.lorem.words()),
    },
    hash: faker.lorem.words(),
  }))
}

export function getGetApiV3LogFileUpdate200Response() {
  return [
    ...new Array(faker.number.int({ min: 1, max: MAX_ARRAY_LENGTH })).keys(),
  ].map((_) => ({
    id: faker.number.int(),
    filename: faker.person.fullName(),
    lastWriteTime: faker.date.past(),
    contentsUrl: faker.internet.url(),
    downloadUrl: faker.internet.url(),
  }))
}
